/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/leaflet.markercluster";
exports.ids = ["vendor-chunks/leaflet.markercluster"];
exports.modules = {

/***/ "(ssr)/./node_modules/leaflet.markercluster/dist/leaflet.markercluster-src.js":
/*!******************************************************************************!*\
  !*** ./node_modules/leaflet.markercluster/dist/leaflet.markercluster-src.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("/*\n * Leaflet.markercluster 1.5.3+master.e5124b2,\n * Provides Beautiful Animated Marker Clustering functionality for Leaflet, a JS library for interactive maps.\n * https://github.com/Leaflet/Leaflet.markercluster\n * (c) 2012-2017, Dave Leaver, smartrak\n */\n(function (global, factory) {\n\t true ? factory(exports) :\n\t0;\n}(this, function (exports) { 'use strict';\n\n\t/*\n\t * L.MarkerClusterGroup extends L.FeatureGroup by clustering the markers contained within\n\t */\n\n\tvar MarkerClusterGroup = L.MarkerClusterGroup = L.FeatureGroup.extend({\n\n\t\toptions: {\n\t\t\tmaxClusterRadius: 80, //A cluster will cover at most this many pixels from its center\n\t\t\ticonCreateFunction: null,\n\t\t\tclusterPane: L.Marker.prototype.options.pane,\n\n\t\t\tspiderfyOnEveryZoom: false,\n\t\t\tspiderfyOnMaxZoom: true,\n\t\t\tshowCoverageOnHover: true,\n\t\t\tzoomToBoundsOnClick: true,\n\t\t\tsingleMarkerMode: false,\n\n\t\t\tdisableClusteringAtZoom: null,\n\n\t\t\t// Setting this to false prevents the removal of any clusters outside of the viewpoint, which\n\t\t\t// is the default behaviour for performance reasons.\n\t\t\tremoveOutsideVisibleBounds: true,\n\n\t\t\t// Set to false to disable all animations (zoom and spiderfy).\n\t\t\t// If false, option animateAddingMarkers below has no effect.\n\t\t\t// If L.DomUtil.TRANSITION is falsy, this option has no effect.\n\t\t\tanimate: true,\n\n\t\t\t//Whether to animate adding markers after adding the MarkerClusterGroup to the map\n\t\t\t// If you are adding individual markers set to true, if adding bulk markers leave false for massive performance gains.\n\t\t\tanimateAddingMarkers: false,\n\n\t\t\t// Make it possible to provide custom function to calculate spiderfy shape positions\n\t\t\tspiderfyShapePositions: null,\n\n\t\t\t//Increase to increase the distance away that spiderfied markers appear from the center\n\t\t\tspiderfyDistanceMultiplier: 1,\n\n\t\t\t// Make it possible to specify a polyline options on a spider leg\n\t\t\tspiderLegPolylineOptions: { weight: 1.5, color: '#222', opacity: 0.5 },\n\n\t\t\t// When bulk adding layers, adds markers in chunks. Means addLayers may not add all the layers in the call, others will be loaded during setTimeouts\n\t\t\tchunkedLoading: false,\n\t\t\tchunkInterval: 200, // process markers for a maximum of ~ n milliseconds (then trigger the chunkProgress callback)\n\t\t\tchunkDelay: 50, // at the end of each interval, give n milliseconds back to system/browser\n\t\t\tchunkProgress: null, // progress callback: function(processed, total, elapsed) (e.g. for a progress indicator)\n\n\t\t\t//Options to pass to the L.Polygon constructor\n\t\t\tpolygonOptions: {}\n\t\t},\n\n\t\tinitialize: function (options) {\n\t\t\tL.Util.setOptions(this, options);\n\t\t\tif (!this.options.iconCreateFunction) {\n\t\t\t\tthis.options.iconCreateFunction = this._defaultIconCreateFunction;\n\t\t\t}\n\n\t\t\tthis._featureGroup = L.featureGroup();\n\t\t\tthis._featureGroup.addEventParent(this);\n\n\t\t\tthis._nonPointGroup = L.featureGroup();\n\t\t\tthis._nonPointGroup.addEventParent(this);\n\n\t\t\tthis._inZoomAnimation = 0;\n\t\t\tthis._needsClustering = [];\n\t\t\tthis._needsRemoving = []; //Markers removed while we aren't on the map need to be kept track of\n\t\t\t//The bounds of the currently shown area (from _getExpandedVisibleBounds) Updated on zoom/move\n\t\t\tthis._currentShownBounds = null;\n\n\t\t\tthis._queue = [];\n\n\t\t\tthis._childMarkerEventHandlers = {\n\t\t\t\t'dragstart': this._childMarkerDragStart,\n\t\t\t\t'move': this._childMarkerMoved,\n\t\t\t\t'dragend': this._childMarkerDragEnd,\n\t\t\t};\n\n\t\t\t// Hook the appropriate animation methods.\n\t\t\tvar animate = L.DomUtil.TRANSITION && this.options.animate;\n\t\t\tL.extend(this, animate ? this._withAnimation : this._noAnimation);\n\t\t\t// Remember which MarkerCluster class to instantiate (animated or not).\n\t\t\tthis._markerCluster = animate ? L.MarkerCluster : L.MarkerClusterNonAnimated;\n\t\t},\n\n\t\taddLayer: function (layer) {\n\n\t\t\tif (layer instanceof L.LayerGroup) {\n\t\t\t\treturn this.addLayers([layer]);\n\t\t\t}\n\n\t\t\t//Don't cluster non point data\n\t\t\tif (!layer.getLatLng) {\n\t\t\t\tthis._nonPointGroup.addLayer(layer);\n\t\t\t\tthis.fire('layeradd', { layer: layer });\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tif (!this._map) {\n\t\t\t\tthis._needsClustering.push(layer);\n\t\t\t\tthis.fire('layeradd', { layer: layer });\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tif (this.hasLayer(layer)) {\n\t\t\t\treturn this;\n\t\t\t}\n\n\n\t\t\t//If we have already clustered we'll need to add this one to a cluster\n\n\t\t\tif (this._unspiderfy) {\n\t\t\t\tthis._unspiderfy();\n\t\t\t}\n\n\t\t\tthis._addLayer(layer, this._maxZoom);\n\t\t\tthis.fire('layeradd', { layer: layer });\n\n\t\t\t// Refresh bounds and weighted positions.\n\t\t\tthis._topClusterLevel._recalculateBounds();\n\n\t\t\tthis._refreshClustersIcons();\n\n\t\t\t//Work out what is visible\n\t\t\tvar visibleLayer = layer,\n\t\t\t    currentZoom = this._zoom;\n\t\t\tif (layer.__parent) {\n\t\t\t\twhile (visibleLayer.__parent._zoom >= currentZoom) {\n\t\t\t\t\tvisibleLayer = visibleLayer.__parent;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this._currentShownBounds.contains(visibleLayer.getLatLng())) {\n\t\t\t\tif (this.options.animateAddingMarkers) {\n\t\t\t\t\tthis._animationAddLayer(layer, visibleLayer);\n\t\t\t\t} else {\n\t\t\t\t\tthis._animationAddLayerNonAnimated(layer, visibleLayer);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\n\t\tremoveLayer: function (layer) {\n\n\t\t\tif (layer instanceof L.LayerGroup) {\n\t\t\t\treturn this.removeLayers([layer]);\n\t\t\t}\n\n\t\t\t//Non point layers\n\t\t\tif (!layer.getLatLng) {\n\t\t\t\tthis._nonPointGroup.removeLayer(layer);\n\t\t\t\tthis.fire('layerremove', { layer: layer });\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tif (!this._map) {\n\t\t\t\tif (!this._arraySplice(this._needsClustering, layer) && this.hasLayer(layer)) {\n\t\t\t\t\tthis._needsRemoving.push({ layer: layer, latlng: layer._latlng });\n\t\t\t\t}\n\t\t\t\tthis.fire('layerremove', { layer: layer });\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tif (!layer.__parent) {\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tif (this._unspiderfy) {\n\t\t\t\tthis._unspiderfy();\n\t\t\t\tthis._unspiderfyLayer(layer);\n\t\t\t}\n\n\t\t\t//Remove the marker from clusters\n\t\t\tthis._removeLayer(layer, true);\n\t\t\tthis.fire('layerremove', { layer: layer });\n\n\t\t\t// Refresh bounds and weighted positions.\n\t\t\tthis._topClusterLevel._recalculateBounds();\n\n\t\t\tthis._refreshClustersIcons();\n\n\t\t\tlayer.off(this._childMarkerEventHandlers, this);\n\n\t\t\tif (this._featureGroup.hasLayer(layer)) {\n\t\t\t\tthis._featureGroup.removeLayer(layer);\n\t\t\t\tif (layer.clusterShow) {\n\t\t\t\t\tlayer.clusterShow();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\n\t\t//Takes an array of markers and adds them in bulk\n\t\taddLayers: function (layersArray, skipLayerAddEvent) {\n\t\t\tif (!L.Util.isArray(layersArray)) {\n\t\t\t\treturn this.addLayer(layersArray);\n\t\t\t}\n\n\t\t\tvar fg = this._featureGroup,\n\t\t\t    npg = this._nonPointGroup,\n\t\t\t    chunked = this.options.chunkedLoading,\n\t\t\t    chunkInterval = this.options.chunkInterval,\n\t\t\t    chunkProgress = this.options.chunkProgress,\n\t\t\t    l = layersArray.length,\n\t\t\t    offset = 0,\n\t\t\t    originalArray = true,\n\t\t\t    m;\n\n\t\t\tif (this._map) {\n\t\t\t\tvar started = (new Date()).getTime();\n\t\t\t\tvar process = L.bind(function () {\n\t\t\t\t\tvar start = (new Date()).getTime();\n\n\t\t\t\t\t// Make sure to unspiderfy before starting to add some layers\n\t\t\t\t\tif (this._map && this._unspiderfy) {\n\t\t\t\t\t\tthis._unspiderfy();\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (; offset < l; offset++) {\n\t\t\t\t\t\tif (chunked && offset % 200 === 0) {\n\t\t\t\t\t\t\t// every couple hundred markers, instrument the time elapsed since processing started:\n\t\t\t\t\t\t\tvar elapsed = (new Date()).getTime() - start;\n\t\t\t\t\t\t\tif (elapsed > chunkInterval) {\n\t\t\t\t\t\t\t\tbreak; // been working too hard, time to take a break :-)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tm = layersArray[offset];\n\n\t\t\t\t\t\t// Group of layers, append children to layersArray and skip.\n\t\t\t\t\t\t// Side effects:\n\t\t\t\t\t\t// - Total increases, so chunkProgress ratio jumps backward.\n\t\t\t\t\t\t// - Groups are not included in this group, only their non-group child layers (hasLayer).\n\t\t\t\t\t\t// Changing array length while looping does not affect performance in current browsers:\n\t\t\t\t\t\t// http://jsperf.com/for-loop-changing-length/6\n\t\t\t\t\t\tif (m instanceof L.LayerGroup) {\n\t\t\t\t\t\t\tif (originalArray) {\n\t\t\t\t\t\t\t\tlayersArray = layersArray.slice();\n\t\t\t\t\t\t\t\toriginalArray = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis._extractNonGroupLayers(m, layersArray);\n\t\t\t\t\t\t\tl = layersArray.length;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//Not point data, can't be clustered\n\t\t\t\t\t\tif (!m.getLatLng) {\n\t\t\t\t\t\t\tnpg.addLayer(m);\n\t\t\t\t\t\t\tif (!skipLayerAddEvent) {\n\t\t\t\t\t\t\t\tthis.fire('layeradd', { layer: m });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (this.hasLayer(m)) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis._addLayer(m, this._maxZoom);\n\t\t\t\t\t\tif (!skipLayerAddEvent) {\n\t\t\t\t\t\t\tthis.fire('layeradd', { layer: m });\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//If we just made a cluster of size 2 then we need to remove the other marker from the map (if it is) or we never will\n\t\t\t\t\t\tif (m.__parent) {\n\t\t\t\t\t\t\tif (m.__parent.getChildCount() === 2) {\n\t\t\t\t\t\t\t\tvar markers = m.__parent.getAllChildMarkers(),\n\t\t\t\t\t\t\t\t    otherMarker = markers[0] === m ? markers[1] : markers[0];\n\t\t\t\t\t\t\t\tfg.removeLayer(otherMarker);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (chunkProgress) {\n\t\t\t\t\t\t// report progress and time elapsed:\n\t\t\t\t\t\tchunkProgress(offset, l, (new Date()).getTime() - started);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Completed processing all markers.\n\t\t\t\t\tif (offset === l) {\n\n\t\t\t\t\t\t// Refresh bounds and weighted positions.\n\t\t\t\t\t\tthis._topClusterLevel._recalculateBounds();\n\n\t\t\t\t\t\tthis._refreshClustersIcons();\n\n\t\t\t\t\t\tthis._topClusterLevel._recursivelyAddChildrenToMap(null, this._zoom, this._currentShownBounds);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsetTimeout(process, this.options.chunkDelay);\n\t\t\t\t\t}\n\t\t\t\t}, this);\n\n\t\t\t\tprocess();\n\t\t\t} else {\n\t\t\t\tvar needsClustering = this._needsClustering;\n\n\t\t\t\tfor (; offset < l; offset++) {\n\t\t\t\t\tm = layersArray[offset];\n\n\t\t\t\t\t// Group of layers, append children to layersArray and skip.\n\t\t\t\t\tif (m instanceof L.LayerGroup) {\n\t\t\t\t\t\tif (originalArray) {\n\t\t\t\t\t\t\tlayersArray = layersArray.slice();\n\t\t\t\t\t\t\toriginalArray = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis._extractNonGroupLayers(m, layersArray);\n\t\t\t\t\t\tl = layersArray.length;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t//Not point data, can't be clustered\n\t\t\t\t\tif (!m.getLatLng) {\n\t\t\t\t\t\tnpg.addLayer(m);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this.hasLayer(m)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tneedsClustering.push(m);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\n\t\t//Takes an array of markers and removes them in bulk\n\t\tremoveLayers: function (layersArray) {\n\t\t\tvar i, m,\n\t\t\t    l = layersArray.length,\n\t\t\t    fg = this._featureGroup,\n\t\t\t    npg = this._nonPointGroup,\n\t\t\t    originalArray = true;\n\n\t\t\tif (!this._map) {\n\t\t\t\tfor (i = 0; i < l; i++) {\n\t\t\t\t\tm = layersArray[i];\n\n\t\t\t\t\t// Group of layers, append children to layersArray and skip.\n\t\t\t\t\tif (m instanceof L.LayerGroup) {\n\t\t\t\t\t\tif (originalArray) {\n\t\t\t\t\t\t\tlayersArray = layersArray.slice();\n\t\t\t\t\t\t\toriginalArray = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis._extractNonGroupLayers(m, layersArray);\n\t\t\t\t\t\tl = layersArray.length;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._arraySplice(this._needsClustering, m);\n\t\t\t\t\tnpg.removeLayer(m);\n\t\t\t\t\tif (this.hasLayer(m)) {\n\t\t\t\t\t\tthis._needsRemoving.push({ layer: m, latlng: m._latlng });\n\t\t\t\t\t}\n\t\t\t\t\tthis.fire('layerremove', { layer: m });\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tif (this._unspiderfy) {\n\t\t\t\tthis._unspiderfy();\n\n\t\t\t\t// Work on a copy of the array, so that next loop is not affected.\n\t\t\t\tvar layersArray2 = layersArray.slice(),\n\t\t\t\t    l2 = l;\n\t\t\t\tfor (i = 0; i < l2; i++) {\n\t\t\t\t\tm = layersArray2[i];\n\n\t\t\t\t\t// Group of layers, append children to layersArray and skip.\n\t\t\t\t\tif (m instanceof L.LayerGroup) {\n\t\t\t\t\t\tthis._extractNonGroupLayers(m, layersArray2);\n\t\t\t\t\t\tl2 = layersArray2.length;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._unspiderfyLayer(m);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (i = 0; i < l; i++) {\n\t\t\t\tm = layersArray[i];\n\n\t\t\t\t// Group of layers, append children to layersArray and skip.\n\t\t\t\tif (m instanceof L.LayerGroup) {\n\t\t\t\t\tif (originalArray) {\n\t\t\t\t\t\tlayersArray = layersArray.slice();\n\t\t\t\t\t\toriginalArray = false;\n\t\t\t\t\t}\n\t\t\t\t\tthis._extractNonGroupLayers(m, layersArray);\n\t\t\t\t\tl = layersArray.length;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (!m.__parent) {\n\t\t\t\t\tnpg.removeLayer(m);\n\t\t\t\t\tthis.fire('layerremove', { layer: m });\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tthis._removeLayer(m, true, true);\n\t\t\t\tthis.fire('layerremove', { layer: m });\n\n\t\t\t\tif (fg.hasLayer(m)) {\n\t\t\t\t\tfg.removeLayer(m);\n\t\t\t\t\tif (m.clusterShow) {\n\t\t\t\t\t\tm.clusterShow();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Refresh bounds and weighted positions.\n\t\t\tthis._topClusterLevel._recalculateBounds();\n\n\t\t\tthis._refreshClustersIcons();\n\n\t\t\t//Fix up the clusters and markers on the map\n\t\t\tthis._topClusterLevel._recursivelyAddChildrenToMap(null, this._zoom, this._currentShownBounds);\n\n\t\t\treturn this;\n\t\t},\n\n\t\t//Removes all layers from the MarkerClusterGroup\n\t\tclearLayers: function () {\n\t\t\t//Need our own special implementation as the LayerGroup one doesn't work for us\n\n\t\t\t//If we aren't on the map (yet), blow away the markers we know of\n\t\t\tif (!this._map) {\n\t\t\t\tthis._needsClustering = [];\n\t\t\t\tthis._needsRemoving = [];\n\t\t\t\tdelete this._gridClusters;\n\t\t\t\tdelete this._gridUnclustered;\n\t\t\t}\n\n\t\t\tif (this._noanimationUnspiderfy) {\n\t\t\t\tthis._noanimationUnspiderfy();\n\t\t\t}\n\n\t\t\t//Remove all the visible layers\n\t\t\tthis._featureGroup.clearLayers();\n\t\t\tthis._nonPointGroup.clearLayers();\n\n\t\t\tthis.eachLayer(function (marker) {\n\t\t\t\tmarker.off(this._childMarkerEventHandlers, this);\n\t\t\t\tdelete marker.__parent;\n\t\t\t}, this);\n\n\t\t\tif (this._map) {\n\t\t\t\t//Reset _topClusterLevel and the DistanceGrids\n\t\t\t\tthis._generateInitialClusters();\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\n\t\t//Override FeatureGroup.getBounds as it doesn't work\n\t\tgetBounds: function () {\n\t\t\tvar bounds = new L.LatLngBounds();\n\n\t\t\tif (this._topClusterLevel) {\n\t\t\t\tbounds.extend(this._topClusterLevel._bounds);\n\t\t\t}\n\n\t\t\tfor (var i = this._needsClustering.length - 1; i >= 0; i--) {\n\t\t\t\tbounds.extend(this._needsClustering[i].getLatLng());\n\t\t\t}\n\n\t\t\tbounds.extend(this._nonPointGroup.getBounds());\n\n\t\t\treturn bounds;\n\t\t},\n\n\t\t//Overrides LayerGroup.eachLayer\n\t\teachLayer: function (method, context) {\n\t\t\tvar markers = this._needsClustering.slice(),\n\t\t\t\tneedsRemoving = this._needsRemoving,\n\t\t\t\tthisNeedsRemoving, i, j;\n\n\t\t\tif (this._topClusterLevel) {\n\t\t\t\tthis._topClusterLevel.getAllChildMarkers(markers);\n\t\t\t}\n\n\t\t\tfor (i = markers.length - 1; i >= 0; i--) {\n\t\t\t\tthisNeedsRemoving = true;\n\n\t\t\t\tfor (j = needsRemoving.length - 1; j >= 0; j--) {\n\t\t\t\t\tif (needsRemoving[j].layer === markers[i]) {\n\t\t\t\t\t\tthisNeedsRemoving = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (thisNeedsRemoving) {\n\t\t\t\t\tmethod.call(context, markers[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._nonPointGroup.eachLayer(method, context);\n\t\t},\n\n\t\t//Overrides LayerGroup.getLayers\n\t\tgetLayers: function () {\n\t\t\tvar layers = [];\n\t\t\tthis.eachLayer(function (l) {\n\t\t\t\tlayers.push(l);\n\t\t\t});\n\t\t\treturn layers;\n\t\t},\n\n\t\t//Overrides LayerGroup.getLayer, WARNING: Really bad performance\n\t\tgetLayer: function (id) {\n\t\t\tvar result = null;\n\n\t\t\tid = parseInt(id, 10);\n\n\t\t\tthis.eachLayer(function (l) {\n\t\t\t\tif (L.stamp(l) === id) {\n\t\t\t\t\tresult = l;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn result;\n\t\t},\n\n\t\t//Returns true if the given layer is in this MarkerClusterGroup\n\t\thasLayer: function (layer) {\n\t\t\tif (!layer) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tvar i, anArray = this._needsClustering;\n\n\t\t\tfor (i = anArray.length - 1; i >= 0; i--) {\n\t\t\t\tif (anArray[i] === layer) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tanArray = this._needsRemoving;\n\t\t\tfor (i = anArray.length - 1; i >= 0; i--) {\n\t\t\t\tif (anArray[i].layer === layer) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn !!(layer.__parent && layer.__parent._group === this) || this._nonPointGroup.hasLayer(layer);\n\t\t},\n\n\t\t//Zoom down to show the given layer (spiderfying if necessary) then calls the callback\n\t\tzoomToShowLayer: function (layer, callback) {\n\n\t\t\tvar map = this._map;\n\n\t\t\tif (typeof callback !== 'function') {\n\t\t\t\tcallback = function () {};\n\t\t\t}\n\n\t\t\tvar showMarker = function () {\n\t\t\t\t// Assumes that map.hasLayer checks for direct appearance on map, not recursively calling\n\t\t\t\t// hasLayer on Layer Groups that are on map (typically not calling this MarkerClusterGroup.hasLayer, which would always return true)\n\t\t\t\tif ((map.hasLayer(layer) || map.hasLayer(layer.__parent)) && !this._inZoomAnimation) {\n\t\t\t\t\tthis._map.off('moveend', showMarker, this);\n\t\t\t\t\tthis.off('animationend', showMarker, this);\n\n\t\t\t\t\tif (map.hasLayer(layer)) {\n\t\t\t\t\t\tcallback();\n\t\t\t\t\t} else if (layer.__parent._icon) {\n\t\t\t\t\t\tthis.once('spiderfied', callback, this);\n\t\t\t\t\t\tlayer.__parent.spiderfy();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tif (layer._icon && this._map.getBounds().contains(layer.getLatLng())) {\n\t\t\t\t//Layer is visible ond on screen, immediate return\n\t\t\t\tcallback();\n\t\t\t} else if (layer.__parent._zoom < Math.round(this._map._zoom)) {\n\t\t\t\t//Layer should be visible at this zoom level. It must not be on screen so just pan over to it\n\t\t\t\tthis._map.on('moveend', showMarker, this);\n\t\t\t\tthis._map.panTo(layer.getLatLng());\n\t\t\t} else {\n\t\t\t\tthis._map.on('moveend', showMarker, this);\n\t\t\t\tthis.on('animationend', showMarker, this);\n\t\t\t\tlayer.__parent.zoomToBounds();\n\t\t\t}\n\t\t},\n\n\t\t//Overrides FeatureGroup.onAdd\n\t\tonAdd: function (map) {\n\t\t\tthis._map = map;\n\t\t\tvar i, l, layer;\n\n\t\t\tif (!isFinite(this._map.getMaxZoom())) {\n\t\t\t\tthrow \"Map has no maxZoom specified\";\n\t\t\t}\n\n\t\t\tthis._featureGroup.addTo(map);\n\t\t\tthis._nonPointGroup.addTo(map);\n\n\t\t\tif (!this._gridClusters) {\n\t\t\t\tthis._generateInitialClusters();\n\t\t\t}\n\n\t\t\tthis._maxLat = map.options.crs.projection.MAX_LATITUDE;\n\n\t\t\t//Restore all the positions as they are in the MCG before removing them\n\t\t\tfor (i = 0, l = this._needsRemoving.length; i < l; i++) {\n\t\t\t\tlayer = this._needsRemoving[i];\n\t\t\t\tlayer.newlatlng = layer.layer._latlng;\n\t\t\t\tlayer.layer._latlng = layer.latlng;\n\t\t\t}\n\t\t\t//Remove them, then restore their new positions\n\t\t\tfor (i = 0, l = this._needsRemoving.length; i < l; i++) {\n\t\t\t\tlayer = this._needsRemoving[i];\n\t\t\t\tthis._removeLayer(layer.layer, true);\n\t\t\t\tlayer.layer._latlng = layer.newlatlng;\n\t\t\t}\n\t\t\tthis._needsRemoving = [];\n\n\t\t\t//Remember the current zoom level and bounds\n\t\t\tthis._zoom = Math.round(this._map._zoom);\n\t\t\tthis._currentShownBounds = this._getExpandedVisibleBounds();\n\n\t\t\tthis._map.on('zoomend', this._zoomEnd, this);\n\t\t\tthis._map.on('moveend', this._moveEnd, this);\n\n\t\t\tif (this._spiderfierOnAdd) { //TODO FIXME: Not sure how to have spiderfier add something on here nicely\n\t\t\t\tthis._spiderfierOnAdd();\n\t\t\t}\n\n\t\t\tthis._bindEvents();\n\n\t\t\t//Actually add our markers to the map:\n\t\t\tl = this._needsClustering;\n\t\t\tthis._needsClustering = [];\n\t\t\tthis.addLayers(l, true);\n\t\t},\n\n\t\t//Overrides FeatureGroup.onRemove\n\t\tonRemove: function (map) {\n\t\t\tmap.off('zoomend', this._zoomEnd, this);\n\t\t\tmap.off('moveend', this._moveEnd, this);\n\n\t\t\tthis._unbindEvents();\n\n\t\t\t//In case we are in a cluster animation\n\t\t\tthis._map._mapPane.className = this._map._mapPane.className.replace(' leaflet-cluster-anim', '');\n\n\t\t\tif (this._spiderfierOnRemove) { //TODO FIXME: Not sure how to have spiderfier add something on here nicely\n\t\t\t\tthis._spiderfierOnRemove();\n\t\t\t}\n\n\t\t\tdelete this._maxLat;\n\n\t\t\t//Clean up all the layers we added to the map\n\t\t\tthis._hideCoverage();\n\t\t\tthis._featureGroup.remove();\n\t\t\tthis._nonPointGroup.remove();\n\n\t\t\tthis._featureGroup.clearLayers();\n\n\t\t\tthis._map = null;\n\t\t},\n\n\t\tgetVisibleParent: function (marker) {\n\t\t\tvar vMarker = marker;\n\t\t\twhile (vMarker && !vMarker._icon) {\n\t\t\t\tvMarker = vMarker.__parent;\n\t\t\t}\n\t\t\treturn vMarker || null;\n\t\t},\n\n\t\t//Remove the given object from the given array\n\t\t_arraySplice: function (anArray, obj) {\n\t\t\tfor (var i = anArray.length - 1; i >= 0; i--) {\n\t\t\t\tif (anArray[i] === obj) {\n\t\t\t\t\tanArray.splice(i, 1);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Removes a marker from all _gridUnclustered zoom levels, starting at the supplied zoom.\n\t\t * @param marker to be removed from _gridUnclustered.\n\t\t * @param z integer bottom start zoom level (included)\n\t\t * @private\n\t\t */\n\t\t_removeFromGridUnclustered: function (marker, z) {\n\t\t\tvar map = this._map,\n\t\t\t    gridUnclustered = this._gridUnclustered,\n\t\t\t\tminZoom = Math.floor(this._map.getMinZoom());\n\n\t\t\tfor (; z >= minZoom; z--) {\n\t\t\t\tif (!gridUnclustered[z].removeObject(marker, map.project(marker.getLatLng(), z))) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t_childMarkerDragStart: function (e) {\n\t\t\te.target.__dragStart = e.target._latlng;\n\t\t},\n\n\t\t_childMarkerMoved: function (e) {\n\t\t\tif (!this._ignoreMove && !e.target.__dragStart) {\n\t\t\t\tvar isPopupOpen = e.target._popup && e.target._popup.isOpen();\n\n\t\t\t\tthis._moveChild(e.target, e.oldLatLng, e.latlng);\n\n\t\t\t\tif (isPopupOpen) {\n\t\t\t\t\te.target.openPopup();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t_moveChild: function (layer, from, to) {\n\t\t\tlayer._latlng = from;\n\t\t\tthis.removeLayer(layer);\n\n\t\t\tlayer._latlng = to;\n\t\t\tthis.addLayer(layer);\n\t\t},\n\n\t\t_childMarkerDragEnd: function (e) {\n\t\t\tvar dragStart = e.target.__dragStart;\n\t\t\tdelete e.target.__dragStart;\n\t\t\tif (dragStart) {\n\t\t\t\tthis._moveChild(e.target, dragStart, e.target._latlng);\n\t\t\t}\t\t\n\t\t},\n\n\n\t\t//Internal function for removing a marker from everything.\n\t\t//dontUpdateMap: set to true if you will handle updating the map manually (for bulk functions)\n\t\t_removeLayer: function (marker, removeFromDistanceGrid, dontUpdateMap) {\n\t\t\tvar gridClusters = this._gridClusters,\n\t\t\t\tgridUnclustered = this._gridUnclustered,\n\t\t\t\tfg = this._featureGroup,\n\t\t\t\tmap = this._map,\n\t\t\t\tminZoom = Math.floor(this._map.getMinZoom());\n\n\t\t\t//Remove the marker from distance clusters it might be in\n\t\t\tif (removeFromDistanceGrid) {\n\t\t\t\tthis._removeFromGridUnclustered(marker, this._maxZoom);\n\t\t\t}\n\n\t\t\t//Work our way up the clusters removing them as we go if required\n\t\t\tvar cluster = marker.__parent,\n\t\t\t\tmarkers = cluster._markers,\n\t\t\t\totherMarker;\n\n\t\t\t//Remove the marker from the immediate parents marker list\n\t\t\tthis._arraySplice(markers, marker);\n\n\t\t\twhile (cluster) {\n\t\t\t\tcluster._childCount--;\n\t\t\t\tcluster._boundsNeedUpdate = true;\n\n\t\t\t\tif (cluster._zoom < minZoom) {\n\t\t\t\t\t//Top level, do nothing\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (removeFromDistanceGrid && cluster._childCount <= 1) { //Cluster no longer required\n\t\t\t\t\t//We need to push the other marker up to the parent\n\t\t\t\t\totherMarker = cluster._markers[0] === marker ? cluster._markers[1] : cluster._markers[0];\n\n\t\t\t\t\t//Update distance grid\n\t\t\t\t\tgridClusters[cluster._zoom].removeObject(cluster, map.project(cluster._cLatLng, cluster._zoom));\n\t\t\t\t\tgridUnclustered[cluster._zoom].addObject(otherMarker, map.project(otherMarker.getLatLng(), cluster._zoom));\n\n\t\t\t\t\t//Move otherMarker up to parent\n\t\t\t\t\tthis._arraySplice(cluster.__parent._childClusters, cluster);\n\t\t\t\t\tcluster.__parent._markers.push(otherMarker);\n\t\t\t\t\totherMarker.__parent = cluster.__parent;\n\n\t\t\t\t\tif (cluster._icon) {\n\t\t\t\t\t\t//Cluster is currently on the map, need to put the marker on the map instead\n\t\t\t\t\t\tfg.removeLayer(cluster);\n\t\t\t\t\t\tif (!dontUpdateMap) {\n\t\t\t\t\t\t\tfg.addLayer(otherMarker);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcluster._iconNeedsUpdate = true;\n\t\t\t\t}\n\n\t\t\t\tcluster = cluster.__parent;\n\t\t\t}\n\n\t\t\tdelete marker.__parent;\n\t\t},\n\n\t\t_isOrIsParent: function (el, oel) {\n\t\t\twhile (oel) {\n\t\t\t\tif (el === oel) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\toel = oel.parentNode;\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\n\t\t//Override L.Evented.fire\n\t\tfire: function (type, data, propagate) {\n\t\t\tif (data && data.layer instanceof L.MarkerCluster) {\n\t\t\t\t//Prevent multiple clustermouseover/off events if the icon is made up of stacked divs (Doesn't work in ie <= 8, no relatedTarget)\n\t\t\t\tif (data.originalEvent && this._isOrIsParent(data.layer._icon, data.originalEvent.relatedTarget)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\ttype = 'cluster' + type;\n\t\t\t}\n\n\t\t\tL.FeatureGroup.prototype.fire.call(this, type, data, propagate);\n\t\t},\n\n\t\t//Override L.Evented.listens\n\t\tlistens: function (type, propagate) {\n\t\t\treturn L.FeatureGroup.prototype.listens.call(this, type, propagate) || L.FeatureGroup.prototype.listens.call(this, 'cluster' + type, propagate);\n\t\t},\n\n\t\t//Default functionality\n\t\t_defaultIconCreateFunction: function (cluster) {\n\t\t\tvar childCount = cluster.getChildCount();\n\n\t\t\tvar c = ' marker-cluster-';\n\t\t\tif (childCount < 10) {\n\t\t\t\tc += 'small';\n\t\t\t} else if (childCount < 100) {\n\t\t\t\tc += 'medium';\n\t\t\t} else {\n\t\t\t\tc += 'large';\n\t\t\t}\n\n\t\t\treturn new L.DivIcon({ html: '<div><span>' + childCount + '</span></div>', className: 'marker-cluster' + c, iconSize: new L.Point(40, 40) });\n\t\t},\n\n\t\t_bindEvents: function () {\n\t\t\tvar map = this._map,\n\t\t\t    spiderfyOnMaxZoom = this.options.spiderfyOnMaxZoom,\n\t\t\t    showCoverageOnHover = this.options.showCoverageOnHover,\n\t\t\t    zoomToBoundsOnClick = this.options.zoomToBoundsOnClick,\n\t\t\t    spiderfyOnEveryZoom = this.options.spiderfyOnEveryZoom;\n\n\t\t\t//Zoom on cluster click or spiderfy if we are at the lowest level\n\t\t\tif (spiderfyOnMaxZoom || zoomToBoundsOnClick || spiderfyOnEveryZoom) {\n\t\t\t\tthis.on('clusterclick clusterkeypress', this._zoomOrSpiderfy, this);\n\t\t\t}\n\n\t\t\t//Show convex hull (boundary) polygon on mouse over\n\t\t\tif (showCoverageOnHover) {\n\t\t\t\tthis.on('clustermouseover', this._showCoverage, this);\n\t\t\t\tthis.on('clustermouseout', this._hideCoverage, this);\n\t\t\t\tmap.on('zoomend', this._hideCoverage, this);\n\t\t\t}\n\t\t},\n\n\t\t_zoomOrSpiderfy: function (e) {\n\t\t\tvar cluster = e.layer,\n\t\t\t    bottomCluster = cluster;\n\n\t\t\tif (e.type === 'clusterkeypress' && e.originalEvent && e.originalEvent.keyCode !== 13) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\twhile (bottomCluster._childClusters.length === 1) {\n\t\t\t\tbottomCluster = bottomCluster._childClusters[0];\n\t\t\t}\n\n\t\t\tif (bottomCluster._zoom === this._maxZoom &&\n\t\t\t\tbottomCluster._childCount === cluster._childCount &&\n\t\t\t\tthis.options.spiderfyOnMaxZoom) {\n\n\t\t\t\t// All child markers are contained in a single cluster from this._maxZoom to this cluster.\n\t\t\t\tcluster.spiderfy();\n\t\t\t} else if (this.options.zoomToBoundsOnClick) {\n\t\t\t\tcluster.zoomToBounds();\n\t\t\t}\n\n\t\t\tif (this.options.spiderfyOnEveryZoom) {\n\t\t\t\tcluster.spiderfy();\n\t\t\t}\n\n\t\t\t// Focus the map again for keyboard users.\n\t\t\tif (e.originalEvent && e.originalEvent.keyCode === 13) {\n\t\t\t\tthis._map._container.focus();\n\t\t\t}\n\t\t},\n\n\t\t_showCoverage: function (e) {\n\t\t\tvar map = this._map;\n\t\t\tif (this._inZoomAnimation) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (this._shownPolygon) {\n\t\t\t\tmap.removeLayer(this._shownPolygon);\n\t\t\t}\n\t\t\tif (e.layer.getChildCount() > 2 && e.layer !== this._spiderfied) {\n\t\t\t\tthis._shownPolygon = new L.Polygon(e.layer.getConvexHull(), this.options.polygonOptions);\n\t\t\t\tmap.addLayer(this._shownPolygon);\n\t\t\t}\n\t\t},\n\n\t\t_hideCoverage: function () {\n\t\t\tif (this._shownPolygon) {\n\t\t\t\tthis._map.removeLayer(this._shownPolygon);\n\t\t\t\tthis._shownPolygon = null;\n\t\t\t}\n\t\t},\n\n\t\t_unbindEvents: function () {\n\t\t\tvar spiderfyOnMaxZoom = this.options.spiderfyOnMaxZoom,\n\t\t\t\tshowCoverageOnHover = this.options.showCoverageOnHover,\n\t\t\t\tzoomToBoundsOnClick = this.options.zoomToBoundsOnClick,\n\t\t\t\tspiderfyOnEveryZoom = this.options.spiderfyOnEveryZoom,\n\t\t\t\tmap = this._map;\n\n\t\t\tif (spiderfyOnMaxZoom || zoomToBoundsOnClick || spiderfyOnEveryZoom) {\n\t\t\t\tthis.off('clusterclick clusterkeypress', this._zoomOrSpiderfy, this);\n\t\t\t}\n\t\t\tif (showCoverageOnHover) {\n\t\t\t\tthis.off('clustermouseover', this._showCoverage, this);\n\t\t\t\tthis.off('clustermouseout', this._hideCoverage, this);\n\t\t\t\tmap.off('zoomend', this._hideCoverage, this);\n\t\t\t}\n\t\t},\n\n\t\t_zoomEnd: function () {\n\t\t\tif (!this._map) { //May have been removed from the map by a zoomEnd handler\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis._mergeSplitClusters();\n\n\t\t\tthis._zoom = Math.round(this._map._zoom);\n\t\t\tthis._currentShownBounds = this._getExpandedVisibleBounds();\n\t\t},\n\n\t\t_moveEnd: function () {\n\t\t\tif (this._inZoomAnimation) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar newBounds = this._getExpandedVisibleBounds();\n\n\t\t\tthis._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), this._zoom, newBounds);\n\t\t\tthis._topClusterLevel._recursivelyAddChildrenToMap(null, Math.round(this._map._zoom), newBounds);\n\n\t\t\tthis._currentShownBounds = newBounds;\n\t\t\treturn;\n\t\t},\n\n\t\t_generateInitialClusters: function () {\n\t\t\tvar maxZoom = Math.ceil(this._map.getMaxZoom()),\n\t\t\t\tminZoom = Math.floor(this._map.getMinZoom()),\n\t\t\t\tradius = this.options.maxClusterRadius,\n\t\t\t\tradiusFn = radius;\n\n\t\t\t//If we just set maxClusterRadius to a single number, we need to create\n\t\t\t//a simple function to return that number. Otherwise, we just have to\n\t\t\t//use the function we've passed in.\n\t\t\tif (typeof radius !== \"function\") {\n\t\t\t\tradiusFn = function () { return radius; };\n\t\t\t}\n\n\t\t\tif (this.options.disableClusteringAtZoom !== null) {\n\t\t\t\tmaxZoom = this.options.disableClusteringAtZoom - 1;\n\t\t\t}\n\t\t\tthis._maxZoom = maxZoom;\n\t\t\tthis._gridClusters = {};\n\t\t\tthis._gridUnclustered = {};\n\n\t\t\t//Set up DistanceGrids for each zoom\n\t\t\tfor (var zoom = maxZoom; zoom >= minZoom; zoom--) {\n\t\t\t\tthis._gridClusters[zoom] = new L.DistanceGrid(radiusFn(zoom));\n\t\t\t\tthis._gridUnclustered[zoom] = new L.DistanceGrid(radiusFn(zoom));\n\t\t\t}\n\n\t\t\t// Instantiate the appropriate L.MarkerCluster class (animated or not).\n\t\t\tthis._topClusterLevel = new this._markerCluster(this, minZoom - 1);\n\t\t},\n\n\t\t//Zoom: Zoom to start adding at (Pass this._maxZoom to start at the bottom)\n\t\t_addLayer: function (layer, zoom) {\n\t\t\tvar gridClusters = this._gridClusters,\n\t\t\t    gridUnclustered = this._gridUnclustered,\n\t\t\t\tminZoom = Math.floor(this._map.getMinZoom()),\n\t\t\t    markerPoint, z;\n\n\t\t\tif (this.options.singleMarkerMode) {\n\t\t\t\tthis._overrideMarkerIcon(layer);\n\t\t\t}\n\n\t\t\tlayer.on(this._childMarkerEventHandlers, this);\n\n\t\t\t//Find the lowest zoom level to slot this one in\n\t\t\tfor (; zoom >= minZoom; zoom--) {\n\t\t\t\tmarkerPoint = this._map.project(layer.getLatLng(), zoom); // calculate pixel position\n\n\t\t\t\t//Try find a cluster close by\n\t\t\t\tvar closest = gridClusters[zoom].getNearObject(markerPoint);\n\t\t\t\tif (closest) {\n\t\t\t\t\tclosest._addChild(layer);\n\t\t\t\t\tlayer.__parent = closest;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t//Try find a marker close by to form a new cluster with\n\t\t\t\tclosest = gridUnclustered[zoom].getNearObject(markerPoint);\n\t\t\t\tif (closest) {\n\t\t\t\t\tvar parent = closest.__parent;\n\t\t\t\t\tif (parent) {\n\t\t\t\t\t\tthis._removeLayer(closest, false);\n\t\t\t\t\t}\n\n\t\t\t\t\t//Create new cluster with these 2 in it\n\n\t\t\t\t\tvar newCluster = new this._markerCluster(this, zoom, closest, layer);\n\t\t\t\t\tgridClusters[zoom].addObject(newCluster, this._map.project(newCluster._cLatLng, zoom));\n\t\t\t\t\tclosest.__parent = newCluster;\n\t\t\t\t\tlayer.__parent = newCluster;\n\n\t\t\t\t\t//First create any new intermediate parent clusters that don't exist\n\t\t\t\t\tvar lastParent = newCluster;\n\t\t\t\t\tfor (z = zoom - 1; z > parent._zoom; z--) {\n\t\t\t\t\t\tlastParent = new this._markerCluster(this, z, lastParent);\n\t\t\t\t\t\tgridClusters[z].addObject(lastParent, this._map.project(closest.getLatLng(), z));\n\t\t\t\t\t}\n\t\t\t\t\tparent._addChild(lastParent);\n\n\t\t\t\t\t//Remove closest from this zoom level and any above that it is in, replace with newCluster\n\t\t\t\t\tthis._removeFromGridUnclustered(closest, zoom);\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t//Didn't manage to cluster in at this zoom, record us as a marker here and continue upwards\n\t\t\t\tgridUnclustered[zoom].addObject(layer, markerPoint);\n\t\t\t}\n\n\t\t\t//Didn't get in anything, add us to the top\n\t\t\tthis._topClusterLevel._addChild(layer);\n\t\t\tlayer.__parent = this._topClusterLevel;\n\t\t\treturn;\n\t\t},\n\n\t\t/**\n\t\t * Refreshes the icon of all \"dirty\" visible clusters.\n\t\t * Non-visible \"dirty\" clusters will be updated when they are added to the map.\n\t\t * @private\n\t\t */\n\t\t_refreshClustersIcons: function () {\n\t\t\tthis._featureGroup.eachLayer(function (c) {\n\t\t\t\tif (c instanceof L.MarkerCluster && c._iconNeedsUpdate) {\n\t\t\t\t\tc._updateIcon();\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\t//Enqueue code to fire after the marker expand/contract has happened\n\t\t_enqueue: function (fn) {\n\t\t\tthis._queue.push(fn);\n\t\t\tif (!this._queueTimeout) {\n\t\t\t\tthis._queueTimeout = setTimeout(L.bind(this._processQueue, this), 300);\n\t\t\t}\n\t\t},\n\t\t_processQueue: function () {\n\t\t\tfor (var i = 0; i < this._queue.length; i++) {\n\t\t\t\tthis._queue[i].call(this);\n\t\t\t}\n\t\t\tthis._queue.length = 0;\n\t\t\tclearTimeout(this._queueTimeout);\n\t\t\tthis._queueTimeout = null;\n\t\t},\n\n\t\t//Merge and split any existing clusters that are too big or small\n\t\t_mergeSplitClusters: function () {\n\t\t\tvar mapZoom = Math.round(this._map._zoom);\n\n\t\t\t//In case we are starting to split before the animation finished\n\t\t\tthis._processQueue();\n\n\t\t\tif (this._zoom < mapZoom && this._currentShownBounds.intersects(this._getExpandedVisibleBounds())) { //Zoom in, split\n\t\t\t\tthis._animationStart();\n\t\t\t\t//Remove clusters now off screen\n\t\t\t\tthis._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), this._zoom, this._getExpandedVisibleBounds());\n\n\t\t\t\tthis._animationZoomIn(this._zoom, mapZoom);\n\n\t\t\t} else if (this._zoom > mapZoom) { //Zoom out, merge\n\t\t\t\tthis._animationStart();\n\n\t\t\t\tthis._animationZoomOut(this._zoom, mapZoom);\n\t\t\t} else {\n\t\t\t\tthis._moveEnd();\n\t\t\t}\n\t\t},\n\n\t\t//Gets the maps visible bounds expanded in each direction by the size of the screen (so the user cannot see an area we do not cover in one pan)\n\t\t_getExpandedVisibleBounds: function () {\n\t\t\tif (!this.options.removeOutsideVisibleBounds) {\n\t\t\t\treturn this._mapBoundsInfinite;\n\t\t\t} else if (L.Browser.mobile) {\n\t\t\t\treturn this._checkBoundsMaxLat(this._map.getBounds());\n\t\t\t}\n\n\t\t\treturn this._checkBoundsMaxLat(this._map.getBounds().pad(1)); // Padding expands the bounds by its own dimensions but scaled with the given factor.\n\t\t},\n\n\t\t/**\n\t\t * Expands the latitude to Infinity (or -Infinity) if the input bounds reach the map projection maximum defined latitude\n\t\t * (in the case of Web/Spherical Mercator, it is 85.0511287798 / see https://en.wikipedia.org/wiki/Web_Mercator#Formulas).\n\t\t * Otherwise, the removeOutsideVisibleBounds option will remove markers beyond that limit, whereas the same markers without\n\t\t * this option (or outside MCG) will have their position floored (ceiled) by the projection and rendered at that limit,\n\t\t * making the user think that MCG \"eats\" them and never displays them again.\n\t\t * @param bounds L.LatLngBounds\n\t\t * @returns {L.LatLngBounds}\n\t\t * @private\n\t\t */\n\t\t_checkBoundsMaxLat: function (bounds) {\n\t\t\tvar maxLat = this._maxLat;\n\n\t\t\tif (maxLat !== undefined) {\n\t\t\t\tif (bounds.getNorth() >= maxLat) {\n\t\t\t\t\tbounds._northEast.lat = Infinity;\n\t\t\t\t}\n\t\t\t\tif (bounds.getSouth() <= -maxLat) {\n\t\t\t\t\tbounds._southWest.lat = -Infinity;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn bounds;\n\t\t},\n\n\t\t//Shared animation code\n\t\t_animationAddLayerNonAnimated: function (layer, newCluster) {\n\t\t\tif (newCluster === layer) {\n\t\t\t\tthis._featureGroup.addLayer(layer);\n\t\t\t} else if (newCluster._childCount === 2) {\n\t\t\t\tnewCluster._addToMap();\n\n\t\t\t\tvar markers = newCluster.getAllChildMarkers();\n\t\t\t\tthis._featureGroup.removeLayer(markers[0]);\n\t\t\t\tthis._featureGroup.removeLayer(markers[1]);\n\t\t\t} else {\n\t\t\t\tnewCluster._updateIcon();\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Extracts individual (i.e. non-group) layers from a Layer Group.\n\t\t * @param group to extract layers from.\n\t\t * @param output {Array} in which to store the extracted layers.\n\t\t * @returns {*|Array}\n\t\t * @private\n\t\t */\n\t\t_extractNonGroupLayers: function (group, output) {\n\t\t\tvar layers = group.getLayers(),\n\t\t\t    i = 0,\n\t\t\t    layer;\n\n\t\t\toutput = output || [];\n\n\t\t\tfor (; i < layers.length; i++) {\n\t\t\t\tlayer = layers[i];\n\n\t\t\t\tif (layer instanceof L.LayerGroup) {\n\t\t\t\t\tthis._extractNonGroupLayers(layer, output);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\toutput.push(layer);\n\t\t\t}\n\n\t\t\treturn output;\n\t\t},\n\n\t\t/**\n\t\t * Implements the singleMarkerMode option.\n\t\t * @param layer Marker to re-style using the Clusters iconCreateFunction.\n\t\t * @returns {L.Icon} The newly created icon.\n\t\t * @private\n\t\t */\n\t\t_overrideMarkerIcon: function (layer) {\n\t\t\tvar icon = layer.options.icon = this.options.iconCreateFunction({\n\t\t\t\tgetChildCount: function () {\n\t\t\t\t\treturn 1;\n\t\t\t\t},\n\t\t\t\tgetAllChildMarkers: function () {\n\t\t\t\t\treturn [layer];\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn icon;\n\t\t}\n\t});\n\n\t// Constant bounds used in case option \"removeOutsideVisibleBounds\" is set to false.\n\tL.MarkerClusterGroup.include({\n\t\t_mapBoundsInfinite: new L.LatLngBounds(new L.LatLng(-Infinity, -Infinity), new L.LatLng(Infinity, Infinity))\n\t});\n\n\tL.MarkerClusterGroup.include({\n\t\t_noAnimation: {\n\t\t\t//Non Animated versions of everything\n\t\t\t_animationStart: function () {\n\t\t\t\t//Do nothing...\n\t\t\t},\n\t\t\t_animationZoomIn: function (previousZoomLevel, newZoomLevel) {\n\t\t\t\tthis._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), previousZoomLevel);\n\t\t\t\tthis._topClusterLevel._recursivelyAddChildrenToMap(null, newZoomLevel, this._getExpandedVisibleBounds());\n\n\t\t\t\t//We didn't actually animate, but we use this event to mean \"clustering animations have finished\"\n\t\t\t\tthis.fire('animationend');\n\t\t\t},\n\t\t\t_animationZoomOut: function (previousZoomLevel, newZoomLevel) {\n\t\t\t\tthis._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), previousZoomLevel);\n\t\t\t\tthis._topClusterLevel._recursivelyAddChildrenToMap(null, newZoomLevel, this._getExpandedVisibleBounds());\n\n\t\t\t\t//We didn't actually animate, but we use this event to mean \"clustering animations have finished\"\n\t\t\t\tthis.fire('animationend');\n\t\t\t},\n\t\t\t_animationAddLayer: function (layer, newCluster) {\n\t\t\t\tthis._animationAddLayerNonAnimated(layer, newCluster);\n\t\t\t}\n\t\t},\n\n\t\t_withAnimation: {\n\t\t\t//Animated versions here\n\t\t\t_animationStart: function () {\n\t\t\t\tthis._map._mapPane.className += ' leaflet-cluster-anim';\n\t\t\t\tthis._inZoomAnimation++;\n\t\t\t},\n\n\t\t\t_animationZoomIn: function (previousZoomLevel, newZoomLevel) {\n\t\t\t\tvar bounds = this._getExpandedVisibleBounds(),\n\t\t\t\t    fg = this._featureGroup,\n\t\t\t\t\tminZoom = Math.floor(this._map.getMinZoom()),\n\t\t\t\t    i;\n\n\t\t\t\tthis._ignoreMove = true;\n\n\t\t\t\t//Add all children of current clusters to map and remove those clusters from map\n\t\t\t\tthis._topClusterLevel._recursively(bounds, previousZoomLevel, minZoom, function (c) {\n\t\t\t\t\tvar startPos = c._latlng,\n\t\t\t\t\t    markers  = c._markers,\n\t\t\t\t\t    m;\n\n\t\t\t\t\tif (!bounds.contains(startPos)) {\n\t\t\t\t\t\tstartPos = null;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (c._isSingleParent() && previousZoomLevel + 1 === newZoomLevel) { //Immediately add the new child and remove us\n\t\t\t\t\t\tfg.removeLayer(c);\n\t\t\t\t\t\tc._recursivelyAddChildrenToMap(null, newZoomLevel, bounds);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t//Fade out old cluster\n\t\t\t\t\t\tc.clusterHide();\n\t\t\t\t\t\tc._recursivelyAddChildrenToMap(startPos, newZoomLevel, bounds);\n\t\t\t\t\t}\n\n\t\t\t\t\t//Remove all markers that aren't visible any more\n\t\t\t\t\t//TODO: Do we actually need to do this on the higher levels too?\n\t\t\t\t\tfor (i = markers.length - 1; i >= 0; i--) {\n\t\t\t\t\t\tm = markers[i];\n\t\t\t\t\t\tif (!bounds.contains(m._latlng)) {\n\t\t\t\t\t\t\tfg.removeLayer(m);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t});\n\n\t\t\t\tthis._forceLayout();\n\n\t\t\t\t//Update opacities\n\t\t\t\tthis._topClusterLevel._recursivelyBecomeVisible(bounds, newZoomLevel);\n\t\t\t\t//TODO Maybe? Update markers in _recursivelyBecomeVisible\n\t\t\t\tfg.eachLayer(function (n) {\n\t\t\t\t\tif (!(n instanceof L.MarkerCluster) && n._icon) {\n\t\t\t\t\t\tn.clusterShow();\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t//update the positions of the just added clusters/markers\n\t\t\t\tthis._topClusterLevel._recursively(bounds, previousZoomLevel, newZoomLevel, function (c) {\n\t\t\t\t\tc._recursivelyRestoreChildPositions(newZoomLevel);\n\t\t\t\t});\n\n\t\t\t\tthis._ignoreMove = false;\n\n\t\t\t\t//Remove the old clusters and close the zoom animation\n\t\t\t\tthis._enqueue(function () {\n\t\t\t\t\t//update the positions of the just added clusters/markers\n\t\t\t\t\tthis._topClusterLevel._recursively(bounds, previousZoomLevel, minZoom, function (c) {\n\t\t\t\t\t\tfg.removeLayer(c);\n\t\t\t\t\t\tc.clusterShow();\n\t\t\t\t\t});\n\n\t\t\t\t\tthis._animationEnd();\n\t\t\t\t});\n\t\t\t},\n\n\t\t\t_animationZoomOut: function (previousZoomLevel, newZoomLevel) {\n\t\t\t\tthis._animationZoomOutSingle(this._topClusterLevel, previousZoomLevel - 1, newZoomLevel);\n\n\t\t\t\t//Need to add markers for those that weren't on the map before but are now\n\t\t\t\tthis._topClusterLevel._recursivelyAddChildrenToMap(null, newZoomLevel, this._getExpandedVisibleBounds());\n\t\t\t\t//Remove markers that were on the map before but won't be now\n\t\t\t\tthis._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), previousZoomLevel, this._getExpandedVisibleBounds());\n\t\t\t},\n\n\t\t\t_animationAddLayer: function (layer, newCluster) {\n\t\t\t\tvar me = this,\n\t\t\t\t    fg = this._featureGroup;\n\n\t\t\t\tfg.addLayer(layer);\n\t\t\t\tif (newCluster !== layer) {\n\t\t\t\t\tif (newCluster._childCount > 2) { //Was already a cluster\n\n\t\t\t\t\t\tnewCluster._updateIcon();\n\t\t\t\t\t\tthis._forceLayout();\n\t\t\t\t\t\tthis._animationStart();\n\n\t\t\t\t\t\tlayer._setPos(this._map.latLngToLayerPoint(newCluster.getLatLng()));\n\t\t\t\t\t\tlayer.clusterHide();\n\n\t\t\t\t\t\tthis._enqueue(function () {\n\t\t\t\t\t\t\tfg.removeLayer(layer);\n\t\t\t\t\t\t\tlayer.clusterShow();\n\n\t\t\t\t\t\t\tme._animationEnd();\n\t\t\t\t\t\t});\n\n\t\t\t\t\t} else { //Just became a cluster\n\t\t\t\t\t\tthis._forceLayout();\n\n\t\t\t\t\t\tme._animationStart();\n\t\t\t\t\t\tme._animationZoomOutSingle(newCluster, this._map.getMaxZoom(), this._zoom);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t// Private methods for animated versions.\n\t\t_animationZoomOutSingle: function (cluster, previousZoomLevel, newZoomLevel) {\n\t\t\tvar bounds = this._getExpandedVisibleBounds(),\n\t\t\t\tminZoom = Math.floor(this._map.getMinZoom());\n\n\t\t\t//Animate all of the markers in the clusters to move to their cluster center point\n\t\t\tcluster._recursivelyAnimateChildrenInAndAddSelfToMap(bounds, minZoom, previousZoomLevel + 1, newZoomLevel);\n\n\t\t\tvar me = this;\n\n\t\t\t//Update the opacity (If we immediately set it they won't animate)\n\t\t\tthis._forceLayout();\n\t\t\tcluster._recursivelyBecomeVisible(bounds, newZoomLevel);\n\n\t\t\t//TODO: Maybe use the transition timing stuff to make this more reliable\n\t\t\t//When the animations are done, tidy up\n\t\t\tthis._enqueue(function () {\n\n\t\t\t\t//This cluster stopped being a cluster before the timeout fired\n\t\t\t\tif (cluster._childCount === 1) {\n\t\t\t\t\tvar m = cluster._markers[0];\n\t\t\t\t\t//If we were in a cluster animation at the time then the opacity and position of our child could be wrong now, so fix it\n\t\t\t\t\tthis._ignoreMove = true;\n\t\t\t\t\tm.setLatLng(m.getLatLng());\n\t\t\t\t\tthis._ignoreMove = false;\n\t\t\t\t\tif (m.clusterShow) {\n\t\t\t\t\t\tm.clusterShow();\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcluster._recursively(bounds, newZoomLevel, minZoom, function (c) {\n\t\t\t\t\t\tc._recursivelyRemoveChildrenFromMap(bounds, minZoom, previousZoomLevel + 1);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tme._animationEnd();\n\t\t\t});\n\t\t},\n\n\t\t_animationEnd: function () {\n\t\t\tif (this._map) {\n\t\t\t\tthis._map._mapPane.className = this._map._mapPane.className.replace(' leaflet-cluster-anim', '');\n\t\t\t}\n\t\t\tthis._inZoomAnimation--;\n\t\t\tthis.fire('animationend');\n\t\t},\n\n\t\t//Force a browser layout of stuff in the map\n\t\t// Should apply the current opacity and location to all elements so we can update them again for an animation\n\t\t_forceLayout: function () {\n\t\t\t//In my testing this works, infact offsetWidth of any element seems to work.\n\t\t\t//Could loop all this._layers and do this for each _icon if it stops working\n\n\t\t\tL.Util.falseFn(document.body.offsetWidth);\n\t\t}\n\t});\n\n\tL.markerClusterGroup = function (options) {\n\t\treturn new L.MarkerClusterGroup(options);\n\t};\n\n\tvar MarkerCluster = L.MarkerCluster = L.Marker.extend({\n\t\toptions: L.Icon.prototype.options,\n\n\t\tinitialize: function (group, zoom, a, b) {\n\n\t\t\tL.Marker.prototype.initialize.call(this, a ? (a._cLatLng || a.getLatLng()) : new L.LatLng(0, 0),\n\t            { icon: this, pane: group.options.clusterPane });\n\n\t\t\tthis._group = group;\n\t\t\tthis._zoom = zoom;\n\n\t\t\tthis._markers = [];\n\t\t\tthis._childClusters = [];\n\t\t\tthis._childCount = 0;\n\t\t\tthis._iconNeedsUpdate = true;\n\t\t\tthis._boundsNeedUpdate = true;\n\n\t\t\tthis._bounds = new L.LatLngBounds();\n\n\t\t\tif (a) {\n\t\t\t\tthis._addChild(a);\n\t\t\t}\n\t\t\tif (b) {\n\t\t\t\tthis._addChild(b);\n\t\t\t}\n\t\t},\n\n\t\t//Recursively retrieve all child markers of this cluster\n\t\tgetAllChildMarkers: function (storageArray, ignoreDraggedMarker) {\n\t\t\tstorageArray = storageArray || [];\n\n\t\t\tfor (var i = this._childClusters.length - 1; i >= 0; i--) {\n\t\t\t\tthis._childClusters[i].getAllChildMarkers(storageArray, ignoreDraggedMarker);\n\t\t\t}\n\n\t\t\tfor (var j = this._markers.length - 1; j >= 0; j--) {\n\t\t\t\tif (ignoreDraggedMarker && this._markers[j].__dragStart) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tstorageArray.push(this._markers[j]);\n\t\t\t}\n\n\t\t\treturn storageArray;\n\t\t},\n\n\t\t//Returns the count of how many child markers we have\n\t\tgetChildCount: function () {\n\t\t\treturn this._childCount;\n\t\t},\n\n\t\t//Zoom to the minimum of showing all of the child markers, or the extents of this cluster\n\t\tzoomToBounds: function (fitBoundsOptions) {\n\t\t\tvar childClusters = this._childClusters.slice(),\n\t\t\t\tmap = this._group._map,\n\t\t\t\tboundsZoom = map.getBoundsZoom(this._bounds),\n\t\t\t\tzoom = this._zoom + 1,\n\t\t\t\tmapZoom = map.getZoom(),\n\t\t\t\ti;\n\n\t\t\t//calculate how far we need to zoom down to see all of the markers\n\t\t\twhile (childClusters.length > 0 && boundsZoom > zoom) {\n\t\t\t\tzoom++;\n\t\t\t\tvar newClusters = [];\n\t\t\t\tfor (i = 0; i < childClusters.length; i++) {\n\t\t\t\t\tnewClusters = newClusters.concat(childClusters[i]._childClusters);\n\t\t\t\t}\n\t\t\t\tchildClusters = newClusters;\n\t\t\t}\n\n\t\t\tif (boundsZoom > zoom) {\n\t\t\t\tthis._group._map.setView(this._latlng, zoom);\n\t\t\t} else if (boundsZoom <= mapZoom) { //If fitBounds wouldn't zoom us down, zoom us down instead\n\t\t\t\tthis._group._map.setView(this._latlng, mapZoom + 1);\n\t\t\t} else {\n\t\t\t\tthis._group._map.fitBounds(this._bounds, fitBoundsOptions);\n\t\t\t}\n\t\t},\n\n\t\tgetBounds: function () {\n\t\t\tvar bounds = new L.LatLngBounds();\n\t\t\tbounds.extend(this._bounds);\n\t\t\treturn bounds;\n\t\t},\n\n\t\t_updateIcon: function () {\n\t\t\tthis._iconNeedsUpdate = true;\n\t\t\tif (this._icon) {\n\t\t\t\tthis.setIcon(this);\n\t\t\t}\n\t\t},\n\n\t\t//Cludge for Icon, we pretend to be an icon for performance\n\t\tcreateIcon: function () {\n\t\t\tif (this._iconNeedsUpdate) {\n\t\t\t\tthis._iconObj = this._group.options.iconCreateFunction(this);\n\t\t\t\tthis._iconNeedsUpdate = false;\n\t\t\t}\n\t\t\treturn this._iconObj.createIcon();\n\t\t},\n\t\tcreateShadow: function () {\n\t\t\treturn this._iconObj.createShadow();\n\t\t},\n\n\n\t\t_addChild: function (new1, isNotificationFromChild) {\n\n\t\t\tthis._iconNeedsUpdate = true;\n\n\t\t\tthis._boundsNeedUpdate = true;\n\t\t\tthis._setClusterCenter(new1);\n\n\t\t\tif (new1 instanceof L.MarkerCluster) {\n\t\t\t\tif (!isNotificationFromChild) {\n\t\t\t\t\tthis._childClusters.push(new1);\n\t\t\t\t\tnew1.__parent = this;\n\t\t\t\t}\n\t\t\t\tthis._childCount += new1._childCount;\n\t\t\t} else {\n\t\t\t\tif (!isNotificationFromChild) {\n\t\t\t\t\tthis._markers.push(new1);\n\t\t\t\t}\n\t\t\t\tthis._childCount++;\n\t\t\t}\n\n\t\t\tif (this.__parent) {\n\t\t\t\tthis.__parent._addChild(new1, true);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Makes sure the cluster center is set. If not, uses the child center if it is a cluster, or the marker position.\n\t\t * @param child L.MarkerCluster|L.Marker that will be used as cluster center if not defined yet.\n\t\t * @private\n\t\t */\n\t\t_setClusterCenter: function (child) {\n\t\t\tif (!this._cLatLng) {\n\t\t\t\t// when clustering, take position of the first point as the cluster center\n\t\t\t\tthis._cLatLng = child._cLatLng || child._latlng;\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Assigns impossible bounding values so that the next extend entirely determines the new bounds.\n\t\t * This method avoids having to trash the previous L.LatLngBounds object and to create a new one, which is much slower for this class.\n\t\t * As long as the bounds are not extended, most other methods would probably fail, as they would with bounds initialized but not extended.\n\t\t * @private\n\t\t */\n\t\t_resetBounds: function () {\n\t\t\tvar bounds = this._bounds;\n\n\t\t\tif (bounds._southWest) {\n\t\t\t\tbounds._southWest.lat = Infinity;\n\t\t\t\tbounds._southWest.lng = Infinity;\n\t\t\t}\n\t\t\tif (bounds._northEast) {\n\t\t\t\tbounds._northEast.lat = -Infinity;\n\t\t\t\tbounds._northEast.lng = -Infinity;\n\t\t\t}\n\t\t},\n\n\t\t_recalculateBounds: function () {\n\t\t\tvar markers = this._markers,\n\t\t\t    childClusters = this._childClusters,\n\t\t\t    latSum = 0,\n\t\t\t    lngSum = 0,\n\t\t\t    totalCount = this._childCount,\n\t\t\t    i, child, childLatLng, childCount;\n\n\t\t\t// Case where all markers are removed from the map and we are left with just an empty _topClusterLevel.\n\t\t\tif (totalCount === 0) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Reset rather than creating a new object, for performance.\n\t\t\tthis._resetBounds();\n\n\t\t\t// Child markers.\n\t\t\tfor (i = 0; i < markers.length; i++) {\n\t\t\t\tchildLatLng = markers[i]._latlng;\n\n\t\t\t\tthis._bounds.extend(childLatLng);\n\n\t\t\t\tlatSum += childLatLng.lat;\n\t\t\t\tlngSum += childLatLng.lng;\n\t\t\t}\n\n\t\t\t// Child clusters.\n\t\t\tfor (i = 0; i < childClusters.length; i++) {\n\t\t\t\tchild = childClusters[i];\n\n\t\t\t\t// Re-compute child bounds and weighted position first if necessary.\n\t\t\t\tif (child._boundsNeedUpdate) {\n\t\t\t\t\tchild._recalculateBounds();\n\t\t\t\t}\n\n\t\t\t\tthis._bounds.extend(child._bounds);\n\n\t\t\t\tchildLatLng = child._wLatLng;\n\t\t\t\tchildCount = child._childCount;\n\n\t\t\t\tlatSum += childLatLng.lat * childCount;\n\t\t\t\tlngSum += childLatLng.lng * childCount;\n\t\t\t}\n\n\t\t\tthis._latlng = this._wLatLng = new L.LatLng(latSum / totalCount, lngSum / totalCount);\n\n\t\t\t// Reset dirty flag.\n\t\t\tthis._boundsNeedUpdate = false;\n\t\t},\n\n\t\t//Set our markers position as given and add it to the map\n\t\t_addToMap: function (startPos) {\n\t\t\tif (startPos) {\n\t\t\t\tthis._backupLatlng = this._latlng;\n\t\t\t\tthis.setLatLng(startPos);\n\t\t\t}\n\t\t\tthis._group._featureGroup.addLayer(this);\n\t\t},\n\n\t\t_recursivelyAnimateChildrenIn: function (bounds, center, maxZoom) {\n\t\t\tthis._recursively(bounds, this._group._map.getMinZoom(), maxZoom - 1,\n\t\t\t\tfunction (c) {\n\t\t\t\t\tvar markers = c._markers,\n\t\t\t\t\t\ti, m;\n\t\t\t\t\tfor (i = markers.length - 1; i >= 0; i--) {\n\t\t\t\t\t\tm = markers[i];\n\n\t\t\t\t\t\t//Only do it if the icon is still on the map\n\t\t\t\t\t\tif (m._icon) {\n\t\t\t\t\t\t\tm._setPos(center);\n\t\t\t\t\t\t\tm.clusterHide();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tfunction (c) {\n\t\t\t\t\tvar childClusters = c._childClusters,\n\t\t\t\t\t\tj, cm;\n\t\t\t\t\tfor (j = childClusters.length - 1; j >= 0; j--) {\n\t\t\t\t\t\tcm = childClusters[j];\n\t\t\t\t\t\tif (cm._icon) {\n\t\t\t\t\t\t\tcm._setPos(center);\n\t\t\t\t\t\t\tcm.clusterHide();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t},\n\n\t\t_recursivelyAnimateChildrenInAndAddSelfToMap: function (bounds, mapMinZoom, previousZoomLevel, newZoomLevel) {\n\t\t\tthis._recursively(bounds, newZoomLevel, mapMinZoom,\n\t\t\t\tfunction (c) {\n\t\t\t\t\tc._recursivelyAnimateChildrenIn(bounds, c._group._map.latLngToLayerPoint(c.getLatLng()).round(), previousZoomLevel);\n\n\t\t\t\t\t//TODO: depthToAnimateIn affects _isSingleParent, if there is a multizoom we may/may not be.\n\t\t\t\t\t//As a hack we only do a animation free zoom on a single level zoom, if someone does multiple levels then we always animate\n\t\t\t\t\tif (c._isSingleParent() && previousZoomLevel - 1 === newZoomLevel) {\n\t\t\t\t\t\tc.clusterShow();\n\t\t\t\t\t\tc._recursivelyRemoveChildrenFromMap(bounds, mapMinZoom, previousZoomLevel); //Immediately remove our children as we are replacing them. TODO previousBounds not bounds\n\t\t\t\t\t} else {\n\t\t\t\t\t\tc.clusterHide();\n\t\t\t\t\t}\n\n\t\t\t\t\tc._addToMap();\n\t\t\t\t}\n\t\t\t);\n\t\t},\n\n\t\t_recursivelyBecomeVisible: function (bounds, zoomLevel) {\n\t\t\tthis._recursively(bounds, this._group._map.getMinZoom(), zoomLevel, null, function (c) {\n\t\t\t\tc.clusterShow();\n\t\t\t});\n\t\t},\n\n\t\t_recursivelyAddChildrenToMap: function (startPos, zoomLevel, bounds) {\n\t\t\tthis._recursively(bounds, this._group._map.getMinZoom() - 1, zoomLevel,\n\t\t\t\tfunction (c) {\n\t\t\t\t\tif (zoomLevel === c._zoom) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t//Add our child markers at startPos (so they can be animated out)\n\t\t\t\t\tfor (var i = c._markers.length - 1; i >= 0; i--) {\n\t\t\t\t\t\tvar nm = c._markers[i];\n\n\t\t\t\t\t\tif (!bounds.contains(nm._latlng)) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (startPos) {\n\t\t\t\t\t\t\tnm._backupLatlng = nm.getLatLng();\n\n\t\t\t\t\t\t\tnm.setLatLng(startPos);\n\t\t\t\t\t\t\tif (nm.clusterHide) {\n\t\t\t\t\t\t\t\tnm.clusterHide();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tc._group._featureGroup.addLayer(nm);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tfunction (c) {\n\t\t\t\t\tc._addToMap(startPos);\n\t\t\t\t}\n\t\t\t);\n\t\t},\n\n\t\t_recursivelyRestoreChildPositions: function (zoomLevel) {\n\t\t\t//Fix positions of child markers\n\t\t\tfor (var i = this._markers.length - 1; i >= 0; i--) {\n\t\t\t\tvar nm = this._markers[i];\n\t\t\t\tif (nm._backupLatlng) {\n\t\t\t\t\tnm.setLatLng(nm._backupLatlng);\n\t\t\t\t\tdelete nm._backupLatlng;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (zoomLevel - 1 === this._zoom) {\n\t\t\t\t//Reposition child clusters\n\t\t\t\tfor (var j = this._childClusters.length - 1; j >= 0; j--) {\n\t\t\t\t\tthis._childClusters[j]._restorePosition();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (var k = this._childClusters.length - 1; k >= 0; k--) {\n\t\t\t\t\tthis._childClusters[k]._recursivelyRestoreChildPositions(zoomLevel);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t_restorePosition: function () {\n\t\t\tif (this._backupLatlng) {\n\t\t\t\tthis.setLatLng(this._backupLatlng);\n\t\t\t\tdelete this._backupLatlng;\n\t\t\t}\n\t\t},\n\n\t\t//exceptBounds: If set, don't remove any markers/clusters in it\n\t\t_recursivelyRemoveChildrenFromMap: function (previousBounds, mapMinZoom, zoomLevel, exceptBounds) {\n\t\t\tvar m, i;\n\t\t\tthis._recursively(previousBounds, mapMinZoom - 1, zoomLevel - 1,\n\t\t\t\tfunction (c) {\n\t\t\t\t\t//Remove markers at every level\n\t\t\t\t\tfor (i = c._markers.length - 1; i >= 0; i--) {\n\t\t\t\t\t\tm = c._markers[i];\n\t\t\t\t\t\tif (!exceptBounds || !exceptBounds.contains(m._latlng)) {\n\t\t\t\t\t\t\tc._group._featureGroup.removeLayer(m);\n\t\t\t\t\t\t\tif (m.clusterShow) {\n\t\t\t\t\t\t\t\tm.clusterShow();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tfunction (c) {\n\t\t\t\t\t//Remove child clusters at just the bottom level\n\t\t\t\t\tfor (i = c._childClusters.length - 1; i >= 0; i--) {\n\t\t\t\t\t\tm = c._childClusters[i];\n\t\t\t\t\t\tif (!exceptBounds || !exceptBounds.contains(m._latlng)) {\n\t\t\t\t\t\t\tc._group._featureGroup.removeLayer(m);\n\t\t\t\t\t\t\tif (m.clusterShow) {\n\t\t\t\t\t\t\t\tm.clusterShow();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t},\n\n\t\t//Run the given functions recursively to this and child clusters\n\t\t// boundsToApplyTo: a L.LatLngBounds representing the bounds of what clusters to recurse in to\n\t\t// zoomLevelToStart: zoom level to start running functions (inclusive)\n\t\t// zoomLevelToStop: zoom level to stop running functions (inclusive)\n\t\t// runAtEveryLevel: function that takes an L.MarkerCluster as an argument that should be applied on every level\n\t\t// runAtBottomLevel: function that takes an L.MarkerCluster as an argument that should be applied at only the bottom level\n\t\t_recursively: function (boundsToApplyTo, zoomLevelToStart, zoomLevelToStop, runAtEveryLevel, runAtBottomLevel) {\n\t\t\tvar childClusters = this._childClusters,\n\t\t\t    zoom = this._zoom,\n\t\t\t    i, c;\n\n\t\t\tif (zoomLevelToStart <= zoom) {\n\t\t\t\tif (runAtEveryLevel) {\n\t\t\t\t\trunAtEveryLevel(this);\n\t\t\t\t}\n\t\t\t\tif (runAtBottomLevel && zoom === zoomLevelToStop) {\n\t\t\t\t\trunAtBottomLevel(this);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (zoom < zoomLevelToStart || zoom < zoomLevelToStop) {\n\t\t\t\tfor (i = childClusters.length - 1; i >= 0; i--) {\n\t\t\t\t\tc = childClusters[i];\n\t\t\t\t\tif (c._boundsNeedUpdate) {\n\t\t\t\t\t\tc._recalculateBounds();\n\t\t\t\t\t}\n\t\t\t\t\tif (boundsToApplyTo.intersects(c._bounds)) {\n\t\t\t\t\t\tc._recursively(boundsToApplyTo, zoomLevelToStart, zoomLevelToStop, runAtEveryLevel, runAtBottomLevel);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t//Returns true if we are the parent of only one cluster and that cluster is the same as us\n\t\t_isSingleParent: function () {\n\t\t\t//Don't need to check this._markers as the rest won't work if there are any\n\t\t\treturn this._childClusters.length > 0 && this._childClusters[0]._childCount === this._childCount;\n\t\t}\n\t});\n\n\t/*\n\t* Extends L.Marker to include two extra methods: clusterHide and clusterShow.\n\t* \n\t* They work as setOpacity(0) and setOpacity(1) respectively, but\n\t* don't overwrite the options.opacity\n\t* \n\t*/\n\n\tL.Marker.include({\n\t\tclusterHide: function () {\n\t\t\tvar backup = this.options.opacity;\n\t\t\tthis.setOpacity(0);\n\t\t\tthis.options.opacity = backup;\n\t\t\treturn this;\n\t\t},\n\t\t\n\t\tclusterShow: function () {\n\t\t\treturn this.setOpacity(this.options.opacity);\n\t\t}\n\t});\n\n\tL.DistanceGrid = function (cellSize) {\n\t\tthis._cellSize = cellSize;\n\t\tthis._sqCellSize = cellSize * cellSize;\n\t\tthis._grid = {};\n\t\tthis._objectPoint = { };\n\t};\n\n\tL.DistanceGrid.prototype = {\n\n\t\taddObject: function (obj, point) {\n\t\t\tvar x = this._getCoord(point.x),\n\t\t\t    y = this._getCoord(point.y),\n\t\t\t    grid = this._grid,\n\t\t\t    row = grid[y] = grid[y] || {},\n\t\t\t    cell = row[x] = row[x] || [],\n\t\t\t    stamp = L.Util.stamp(obj);\n\n\t\t\tthis._objectPoint[stamp] = point;\n\n\t\t\tcell.push(obj);\n\t\t},\n\n\t\tupdateObject: function (obj, point) {\n\t\t\tthis.removeObject(obj);\n\t\t\tthis.addObject(obj, point);\n\t\t},\n\n\t\t//Returns true if the object was found\n\t\tremoveObject: function (obj, point) {\n\t\t\tvar x = this._getCoord(point.x),\n\t\t\t    y = this._getCoord(point.y),\n\t\t\t    grid = this._grid,\n\t\t\t    row = grid[y] = grid[y] || {},\n\t\t\t    cell = row[x] = row[x] || [],\n\t\t\t    i, len;\n\n\t\t\tdelete this._objectPoint[L.Util.stamp(obj)];\n\n\t\t\tfor (i = 0, len = cell.length; i < len; i++) {\n\t\t\t\tif (cell[i] === obj) {\n\n\t\t\t\t\tcell.splice(i, 1);\n\n\t\t\t\t\tif (len === 1) {\n\t\t\t\t\t\tdelete row[x];\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t},\n\n\t\teachObject: function (fn, context) {\n\t\t\tvar i, j, k, len, row, cell, removed,\n\t\t\t    grid = this._grid;\n\n\t\t\tfor (i in grid) {\n\t\t\t\trow = grid[i];\n\n\t\t\t\tfor (j in row) {\n\t\t\t\t\tcell = row[j];\n\n\t\t\t\t\tfor (k = 0, len = cell.length; k < len; k++) {\n\t\t\t\t\t\tremoved = fn.call(context, cell[k]);\n\t\t\t\t\t\tif (removed) {\n\t\t\t\t\t\t\tk--;\n\t\t\t\t\t\t\tlen--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tgetNearObject: function (point) {\n\t\t\tvar x = this._getCoord(point.x),\n\t\t\t    y = this._getCoord(point.y),\n\t\t\t    i, j, k, row, cell, len, obj, dist,\n\t\t\t    objectPoint = this._objectPoint,\n\t\t\t    closestDistSq = this._sqCellSize,\n\t\t\t    closest = null;\n\n\t\t\tfor (i = y - 1; i <= y + 1; i++) {\n\t\t\t\trow = this._grid[i];\n\t\t\t\tif (row) {\n\n\t\t\t\t\tfor (j = x - 1; j <= x + 1; j++) {\n\t\t\t\t\t\tcell = row[j];\n\t\t\t\t\t\tif (cell) {\n\n\t\t\t\t\t\t\tfor (k = 0, len = cell.length; k < len; k++) {\n\t\t\t\t\t\t\t\tobj = cell[k];\n\t\t\t\t\t\t\t\tdist = this._sqDist(objectPoint[L.Util.stamp(obj)], point);\n\t\t\t\t\t\t\t\tif (dist < closestDistSq ||\n\t\t\t\t\t\t\t\t\tdist <= closestDistSq && closest === null) {\n\t\t\t\t\t\t\t\t\tclosestDistSq = dist;\n\t\t\t\t\t\t\t\t\tclosest = obj;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn closest;\n\t\t},\n\n\t\t_getCoord: function (x) {\n\t\t\tvar coord = Math.floor(x / this._cellSize);\n\t\t\treturn isFinite(coord) ? coord : x;\n\t\t},\n\n\t\t_sqDist: function (p, p2) {\n\t\t\tvar dx = p2.x - p.x,\n\t\t\t    dy = p2.y - p.y;\n\t\t\treturn dx * dx + dy * dy;\n\t\t}\n\t};\n\n\t/* Copyright (c) 2012 the authors listed at the following URL, and/or\n\tthe authors of referenced articles or incorporated external code:\n\thttp://en.literateprograms.org/Quickhull_(Javascript)?action=history&offset=20120410175256\n\n\tPermission is hereby granted, free of charge, to any person obtaining\n\ta copy of this software and associated documentation files (the\n\t\"Software\"), to deal in the Software without restriction, including\n\twithout limitation the rights to use, copy, modify, merge, publish,\n\tdistribute, sublicense, and/or sell copies of the Software, and to\n\tpermit persons to whom the Software is furnished to do so, subject to\n\tthe following conditions:\n\n\tThe above copyright notice and this permission notice shall be\n\tincluded in all copies or substantial portions of the Software.\n\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n\tEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n\tMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n\tIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n\tCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n\tTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n\tSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\tRetrieved from: http://en.literateprograms.org/Quickhull_(Javascript)?oldid=18434\n\t*/\n\n\t(function () {\n\t\tL.QuickHull = {\n\n\t\t\t/*\n\t\t\t * @param {Object} cpt a point to be measured from the baseline\n\t\t\t * @param {Array} bl the baseline, as represented by a two-element\n\t\t\t *   array of latlng objects.\n\t\t\t * @returns {Number} an approximate distance measure\n\t\t\t */\n\t\t\tgetDistant: function (cpt, bl) {\n\t\t\t\tvar vY = bl[1].lat - bl[0].lat,\n\t\t\t\t\tvX = bl[0].lng - bl[1].lng;\n\t\t\t\treturn (vX * (cpt.lat - bl[0].lat) + vY * (cpt.lng - bl[0].lng));\n\t\t\t},\n\n\t\t\t/*\n\t\t\t * @param {Array} baseLine a two-element array of latlng objects\n\t\t\t *   representing the baseline to project from\n\t\t\t * @param {Array} latLngs an array of latlng objects\n\t\t\t * @returns {Object} the maximum point and all new points to stay\n\t\t\t *   in consideration for the hull.\n\t\t\t */\n\t\t\tfindMostDistantPointFromBaseLine: function (baseLine, latLngs) {\n\t\t\t\tvar maxD = 0,\n\t\t\t\t\tmaxPt = null,\n\t\t\t\t\tnewPoints = [],\n\t\t\t\t\ti, pt, d;\n\n\t\t\t\tfor (i = latLngs.length - 1; i >= 0; i--) {\n\t\t\t\t\tpt = latLngs[i];\n\t\t\t\t\td = this.getDistant(pt, baseLine);\n\n\t\t\t\t\tif (d > 0) {\n\t\t\t\t\t\tnewPoints.push(pt);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (d > maxD) {\n\t\t\t\t\t\tmaxD = d;\n\t\t\t\t\t\tmaxPt = pt;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn { maxPoint: maxPt, newPoints: newPoints };\n\t\t\t},\n\n\n\t\t\t/*\n\t\t\t * Given a baseline, compute the convex hull of latLngs as an array\n\t\t\t * of latLngs.\n\t\t\t *\n\t\t\t * @param {Array} latLngs\n\t\t\t * @returns {Array}\n\t\t\t */\n\t\t\tbuildConvexHull: function (baseLine, latLngs) {\n\t\t\t\tvar convexHullBaseLines = [],\n\t\t\t\t\tt = this.findMostDistantPointFromBaseLine(baseLine, latLngs);\n\n\t\t\t\tif (t.maxPoint) { // if there is still a point \"outside\" the base line\n\t\t\t\t\tconvexHullBaseLines =\n\t\t\t\t\t\tconvexHullBaseLines.concat(\n\t\t\t\t\t\t\tthis.buildConvexHull([baseLine[0], t.maxPoint], t.newPoints)\n\t\t\t\t\t\t);\n\t\t\t\t\tconvexHullBaseLines =\n\t\t\t\t\t\tconvexHullBaseLines.concat(\n\t\t\t\t\t\t\tthis.buildConvexHull([t.maxPoint, baseLine[1]], t.newPoints)\n\t\t\t\t\t\t);\n\t\t\t\t\treturn convexHullBaseLines;\n\t\t\t\t} else {  // if there is no more point \"outside\" the base line, the current base line is part of the convex hull\n\t\t\t\t\treturn [baseLine[0]];\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t/*\n\t\t\t * Given an array of latlngs, compute a convex hull as an array\n\t\t\t * of latlngs\n\t\t\t *\n\t\t\t * @param {Array} latLngs\n\t\t\t * @returns {Array}\n\t\t\t */\n\t\t\tgetConvexHull: function (latLngs) {\n\t\t\t\t// find first baseline\n\t\t\t\tvar maxLat = false, minLat = false,\n\t\t\t\t\tmaxLng = false, minLng = false,\n\t\t\t\t\tmaxLatPt = null, minLatPt = null,\n\t\t\t\t\tmaxLngPt = null, minLngPt = null,\n\t\t\t\t\tmaxPt = null, minPt = null,\n\t\t\t\t\ti;\n\n\t\t\t\tfor (i = latLngs.length - 1; i >= 0; i--) {\n\t\t\t\t\tvar pt = latLngs[i];\n\t\t\t\t\tif (maxLat === false || pt.lat > maxLat) {\n\t\t\t\t\t\tmaxLatPt = pt;\n\t\t\t\t\t\tmaxLat = pt.lat;\n\t\t\t\t\t}\n\t\t\t\t\tif (minLat === false || pt.lat < minLat) {\n\t\t\t\t\t\tminLatPt = pt;\n\t\t\t\t\t\tminLat = pt.lat;\n\t\t\t\t\t}\n\t\t\t\t\tif (maxLng === false || pt.lng > maxLng) {\n\t\t\t\t\t\tmaxLngPt = pt;\n\t\t\t\t\t\tmaxLng = pt.lng;\n\t\t\t\t\t}\n\t\t\t\t\tif (minLng === false || pt.lng < minLng) {\n\t\t\t\t\t\tminLngPt = pt;\n\t\t\t\t\t\tminLng = pt.lng;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (minLat !== maxLat) {\n\t\t\t\t\tminPt = minLatPt;\n\t\t\t\t\tmaxPt = maxLatPt;\n\t\t\t\t} else {\n\t\t\t\t\tminPt = minLngPt;\n\t\t\t\t\tmaxPt = maxLngPt;\n\t\t\t\t}\n\n\t\t\t\tvar ch = [].concat(this.buildConvexHull([minPt, maxPt], latLngs),\n\t\t\t\t\t\t\t\t\tthis.buildConvexHull([maxPt, minPt], latLngs));\n\t\t\t\treturn ch;\n\t\t\t}\n\t\t};\n\t}());\n\n\tL.MarkerCluster.include({\n\t\tgetConvexHull: function () {\n\t\t\tvar childMarkers = this.getAllChildMarkers(),\n\t\t\t\tpoints = [],\n\t\t\t\tp, i;\n\n\t\t\tfor (i = childMarkers.length - 1; i >= 0; i--) {\n\t\t\t\tp = childMarkers[i].getLatLng();\n\t\t\t\tpoints.push(p);\n\t\t\t}\n\n\t\t\treturn L.QuickHull.getConvexHull(points);\n\t\t}\n\t});\n\n\t//This code is 100% based on https://github.com/jawj/OverlappingMarkerSpiderfier-Leaflet\n\t//Huge thanks to jawj for implementing it first to make my job easy :-)\n\n\tL.MarkerCluster.include({\n\n\t\t_2PI: Math.PI * 2,\n\t\t_circleFootSeparation: 25, //related to circumference of circle\n\t\t_circleStartAngle: 0,\n\n\t\t_spiralFootSeparation:  28, //related to size of spiral (experiment!)\n\t\t_spiralLengthStart: 11,\n\t\t_spiralLengthFactor: 5,\n\n\t\t_circleSpiralSwitchover: 9, //show spiral instead of circle from this marker count upwards.\n\t\t\t\t\t\t\t\t\t// 0 -> always spiral; Infinity -> always circle\n\n\t\tspiderfy: function () {\n\t\t\tif (this._group._spiderfied === this || this._group._inZoomAnimation) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar childMarkers = this.getAllChildMarkers(null, true),\n\t\t\t\tgroup = this._group,\n\t\t\t\tmap = group._map,\n\t\t\t\tcenter = map.latLngToLayerPoint(this._latlng),\n\t\t\t\tpositions;\n\n\t\t\tthis._group._unspiderfy();\n\t\t\tthis._group._spiderfied = this;\n\n\t\t\t//TODO Maybe: childMarkers order by distance to center\n\n\t\t\tif (this._group.options.spiderfyShapePositions) {\n\t\t\t\tpositions = this._group.options.spiderfyShapePositions(childMarkers.length, center);\n\t\t\t} else if (childMarkers.length >= this._circleSpiralSwitchover) {\n\t\t\t\tpositions = this._generatePointsSpiral(childMarkers.length, center);\n\t\t\t} else {\n\t\t\t\tcenter.y += 10; // Otherwise circles look wrong => hack for standard blue icon, renders differently for other icons.\n\t\t\t\tpositions = this._generatePointsCircle(childMarkers.length, center);\n\t\t\t}\n\n\t\t\tthis._animationSpiderfy(childMarkers, positions);\n\t\t},\n\n\t\tunspiderfy: function (zoomDetails) {\n\t\t\t/// <param Name=\"zoomDetails\">Argument from zoomanim if being called in a zoom animation or null otherwise</param>\n\t\t\tif (this._group._inZoomAnimation) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis._animationUnspiderfy(zoomDetails);\n\n\t\t\tthis._group._spiderfied = null;\n\t\t},\n\n\t\t_generatePointsCircle: function (count, centerPt) {\n\t\t\tvar circumference = this._group.options.spiderfyDistanceMultiplier * this._circleFootSeparation * (2 + count),\n\t\t\t\tlegLength = circumference / this._2PI,  //radius from circumference\n\t\t\t\tangleStep = this._2PI / count,\n\t\t\t\tres = [],\n\t\t\t\ti, angle;\n\n\t\t\tlegLength = Math.max(legLength, 35); // Minimum distance to get outside the cluster icon.\n\n\t\t\tres.length = count;\n\n\t\t\tfor (i = 0; i < count; i++) { // Clockwise, like spiral.\n\t\t\t\tangle = this._circleStartAngle + i * angleStep;\n\t\t\t\tres[i] = new L.Point(centerPt.x + legLength * Math.cos(angle), centerPt.y + legLength * Math.sin(angle))._round();\n\t\t\t}\n\n\t\t\treturn res;\n\t\t},\n\n\t\t_generatePointsSpiral: function (count, centerPt) {\n\t\t\tvar spiderfyDistanceMultiplier = this._group.options.spiderfyDistanceMultiplier,\n\t\t\t\tlegLength = spiderfyDistanceMultiplier * this._spiralLengthStart,\n\t\t\t\tseparation = spiderfyDistanceMultiplier * this._spiralFootSeparation,\n\t\t\t\tlengthFactor = spiderfyDistanceMultiplier * this._spiralLengthFactor * this._2PI,\n\t\t\t\tangle = 0,\n\t\t\t\tres = [],\n\t\t\t\ti;\n\n\t\t\tres.length = count;\n\n\t\t\t// Higher index, closer position to cluster center.\n\t\t\tfor (i = count; i >= 0; i--) {\n\t\t\t\t// Skip the first position, so that we are already farther from center and we avoid\n\t\t\t\t// being under the default cluster icon (especially important for Circle Markers).\n\t\t\t\tif (i < count) {\n\t\t\t\t\tres[i] = new L.Point(centerPt.x + legLength * Math.cos(angle), centerPt.y + legLength * Math.sin(angle))._round();\n\t\t\t\t}\n\t\t\t\tangle += separation / legLength + i * 0.0005;\n\t\t\t\tlegLength += lengthFactor / angle;\n\t\t\t}\n\t\t\treturn res;\n\t\t},\n\n\t\t_noanimationUnspiderfy: function () {\n\t\t\tvar group = this._group,\n\t\t\t\tmap = group._map,\n\t\t\t\tfg = group._featureGroup,\n\t\t\t\tchildMarkers = this.getAllChildMarkers(null, true),\n\t\t\t\tm, i;\n\n\t\t\tgroup._ignoreMove = true;\n\n\t\t\tthis.setOpacity(1);\n\t\t\tfor (i = childMarkers.length - 1; i >= 0; i--) {\n\t\t\t\tm = childMarkers[i];\n\n\t\t\t\tfg.removeLayer(m);\n\n\t\t\t\tif (m._preSpiderfyLatlng) {\n\t\t\t\t\tm.setLatLng(m._preSpiderfyLatlng);\n\t\t\t\t\tdelete m._preSpiderfyLatlng;\n\t\t\t\t}\n\t\t\t\tif (m.setZIndexOffset) {\n\t\t\t\t\tm.setZIndexOffset(0);\n\t\t\t\t}\n\n\t\t\t\tif (m._spiderLeg) {\n\t\t\t\t\tmap.removeLayer(m._spiderLeg);\n\t\t\t\t\tdelete m._spiderLeg;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tgroup.fire('unspiderfied', {\n\t\t\t\tcluster: this,\n\t\t\t\tmarkers: childMarkers\n\t\t\t});\n\t\t\tgroup._ignoreMove = false;\n\t\t\tgroup._spiderfied = null;\n\t\t}\n\t});\n\n\t//Non Animated versions of everything\n\tL.MarkerClusterNonAnimated = L.MarkerCluster.extend({\n\t\t_animationSpiderfy: function (childMarkers, positions) {\n\t\t\tvar group = this._group,\n\t\t\t\tmap = group._map,\n\t\t\t\tfg = group._featureGroup,\n\t\t\t\tlegOptions = this._group.options.spiderLegPolylineOptions,\n\t\t\t\ti, m, leg, newPos;\n\n\t\t\tgroup._ignoreMove = true;\n\n\t\t\t// Traverse in ascending order to make sure that inner circleMarkers are on top of further legs. Normal markers are re-ordered by newPosition.\n\t\t\t// The reverse order trick no longer improves performance on modern browsers.\n\t\t\tfor (i = 0; i < childMarkers.length; i++) {\n\t\t\t\tnewPos = map.layerPointToLatLng(positions[i]);\n\t\t\t\tm = childMarkers[i];\n\n\t\t\t\t// Add the leg before the marker, so that in case the latter is a circleMarker, the leg is behind it.\n\t\t\t\tleg = new L.Polyline([this._latlng, newPos], legOptions);\n\t\t\t\tmap.addLayer(leg);\n\t\t\t\tm._spiderLeg = leg;\n\n\t\t\t\t// Now add the marker.\n\t\t\t\tm._preSpiderfyLatlng = m._latlng;\n\t\t\t\tm.setLatLng(newPos);\n\t\t\t\tif (m.setZIndexOffset) {\n\t\t\t\t\tm.setZIndexOffset(1000000); //Make these appear on top of EVERYTHING\n\t\t\t\t}\n\n\t\t\t\tfg.addLayer(m);\n\t\t\t}\n\t\t\tthis.setOpacity(0.3);\n\n\t\t\tgroup._ignoreMove = false;\n\t\t\tgroup.fire('spiderfied', {\n\t\t\t\tcluster: this,\n\t\t\t\tmarkers: childMarkers\n\t\t\t});\n\t\t},\n\n\t\t_animationUnspiderfy: function () {\n\t\t\tthis._noanimationUnspiderfy();\n\t\t}\n\t});\n\n\t//Animated versions here\n\tL.MarkerCluster.include({\n\n\t\t_animationSpiderfy: function (childMarkers, positions) {\n\t\t\tvar me = this,\n\t\t\t\tgroup = this._group,\n\t\t\t\tmap = group._map,\n\t\t\t\tfg = group._featureGroup,\n\t\t\t\tthisLayerLatLng = this._latlng,\n\t\t\t\tthisLayerPos = map.latLngToLayerPoint(thisLayerLatLng),\n\t\t\t\tsvg = L.Path.SVG,\n\t\t\t\tlegOptions = L.extend({}, this._group.options.spiderLegPolylineOptions), // Copy the options so that we can modify them for animation.\n\t\t\t\tfinalLegOpacity = legOptions.opacity,\n\t\t\t\ti, m, leg, legPath, legLength, newPos;\n\n\t\t\tif (finalLegOpacity === undefined) {\n\t\t\t\tfinalLegOpacity = L.MarkerClusterGroup.prototype.options.spiderLegPolylineOptions.opacity;\n\t\t\t}\n\n\t\t\tif (svg) {\n\t\t\t\t// If the initial opacity of the spider leg is not 0 then it appears before the animation starts.\n\t\t\t\tlegOptions.opacity = 0;\n\n\t\t\t\t// Add the class for CSS transitions.\n\t\t\t\tlegOptions.className = (legOptions.className || '') + ' leaflet-cluster-spider-leg';\n\t\t\t} else {\n\t\t\t\t// Make sure we have a defined opacity.\n\t\t\t\tlegOptions.opacity = finalLegOpacity;\n\t\t\t}\n\n\t\t\tgroup._ignoreMove = true;\n\n\t\t\t// Add markers and spider legs to map, hidden at our center point.\n\t\t\t// Traverse in ascending order to make sure that inner circleMarkers are on top of further legs. Normal markers are re-ordered by newPosition.\n\t\t\t// The reverse order trick no longer improves performance on modern browsers.\n\t\t\tfor (i = 0; i < childMarkers.length; i++) {\n\t\t\t\tm = childMarkers[i];\n\n\t\t\t\tnewPos = map.layerPointToLatLng(positions[i]);\n\n\t\t\t\t// Add the leg before the marker, so that in case the latter is a circleMarker, the leg is behind it.\n\t\t\t\tleg = new L.Polyline([thisLayerLatLng, newPos], legOptions);\n\t\t\t\tmap.addLayer(leg);\n\t\t\t\tm._spiderLeg = leg;\n\n\t\t\t\t// Explanations: https://jakearchibald.com/2013/animated-line-drawing-svg/\n\t\t\t\t// In our case the transition property is declared in the CSS file.\n\t\t\t\tif (svg) {\n\t\t\t\t\tlegPath = leg._path;\n\t\t\t\t\tlegLength = legPath.getTotalLength() + 0.1; // Need a small extra length to avoid remaining dot in Firefox.\n\t\t\t\t\tlegPath.style.strokeDasharray = legLength; // Just 1 length is enough, it will be duplicated.\n\t\t\t\t\tlegPath.style.strokeDashoffset = legLength;\n\t\t\t\t}\n\n\t\t\t\t// If it is a marker, add it now and we'll animate it out\n\t\t\t\tif (m.setZIndexOffset) {\n\t\t\t\t\tm.setZIndexOffset(1000000); // Make normal markers appear on top of EVERYTHING\n\t\t\t\t}\n\t\t\t\tif (m.clusterHide) {\n\t\t\t\t\tm.clusterHide();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Vectors just get immediately added\n\t\t\t\tfg.addLayer(m);\n\n\t\t\t\tif (m._setPos) {\n\t\t\t\t\tm._setPos(thisLayerPos);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tgroup._forceLayout();\n\t\t\tgroup._animationStart();\n\n\t\t\t// Reveal markers and spider legs.\n\t\t\tfor (i = childMarkers.length - 1; i >= 0; i--) {\n\t\t\t\tnewPos = map.layerPointToLatLng(positions[i]);\n\t\t\t\tm = childMarkers[i];\n\n\t\t\t\t//Move marker to new position\n\t\t\t\tm._preSpiderfyLatlng = m._latlng;\n\t\t\t\tm.setLatLng(newPos);\n\t\t\t\t\n\t\t\t\tif (m.clusterShow) {\n\t\t\t\t\tm.clusterShow();\n\t\t\t\t}\n\n\t\t\t\t// Animate leg (animation is actually delegated to CSS transition).\n\t\t\t\tif (svg) {\n\t\t\t\t\tleg = m._spiderLeg;\n\t\t\t\t\tlegPath = leg._path;\n\t\t\t\t\tlegPath.style.strokeDashoffset = 0;\n\t\t\t\t\t//legPath.style.strokeOpacity = finalLegOpacity;\n\t\t\t\t\tleg.setStyle({opacity: finalLegOpacity});\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.setOpacity(0.3);\n\n\t\t\tgroup._ignoreMove = false;\n\n\t\t\tsetTimeout(function () {\n\t\t\t\tgroup._animationEnd();\n\t\t\t\tgroup.fire('spiderfied', {\n\t\t\t\t\tcluster: me,\n\t\t\t\t\tmarkers: childMarkers\n\t\t\t\t});\n\t\t\t}, 200);\n\t\t},\n\n\t\t_animationUnspiderfy: function (zoomDetails) {\n\t\t\tvar me = this,\n\t\t\t\tgroup = this._group,\n\t\t\t\tmap = group._map,\n\t\t\t\tfg = group._featureGroup,\n\t\t\t\tthisLayerPos = zoomDetails ? map._latLngToNewLayerPoint(this._latlng, zoomDetails.zoom, zoomDetails.center) : map.latLngToLayerPoint(this._latlng),\n\t\t\t\tchildMarkers = this.getAllChildMarkers(null, true),\n\t\t\t\tsvg = L.Path.SVG,\n\t\t\t\tm, i, leg, legPath, legLength, nonAnimatable;\n\n\t\t\tgroup._ignoreMove = true;\n\t\t\tgroup._animationStart();\n\n\t\t\t//Make us visible and bring the child markers back in\n\t\t\tthis.setOpacity(1);\n\t\t\tfor (i = childMarkers.length - 1; i >= 0; i--) {\n\t\t\t\tm = childMarkers[i];\n\n\t\t\t\t//Marker was added to us after we were spiderfied\n\t\t\t\tif (!m._preSpiderfyLatlng) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t//Close any popup on the marker first, otherwise setting the location of the marker will make the map scroll\n\t\t\t\tm.closePopup();\n\n\t\t\t\t//Fix up the location to the real one\n\t\t\t\tm.setLatLng(m._preSpiderfyLatlng);\n\t\t\t\tdelete m._preSpiderfyLatlng;\n\n\t\t\t\t//Hack override the location to be our center\n\t\t\t\tnonAnimatable = true;\n\t\t\t\tif (m._setPos) {\n\t\t\t\t\tm._setPos(thisLayerPos);\n\t\t\t\t\tnonAnimatable = false;\n\t\t\t\t}\n\t\t\t\tif (m.clusterHide) {\n\t\t\t\t\tm.clusterHide();\n\t\t\t\t\tnonAnimatable = false;\n\t\t\t\t}\n\t\t\t\tif (nonAnimatable) {\n\t\t\t\t\tfg.removeLayer(m);\n\t\t\t\t}\n\n\t\t\t\t// Animate the spider leg back in (animation is actually delegated to CSS transition).\n\t\t\t\tif (svg) {\n\t\t\t\t\tleg = m._spiderLeg;\n\t\t\t\t\tlegPath = leg._path;\n\t\t\t\t\tlegLength = legPath.getTotalLength() + 0.1;\n\t\t\t\t\tlegPath.style.strokeDashoffset = legLength;\n\t\t\t\t\tleg.setStyle({opacity: 0});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tgroup._ignoreMove = false;\n\n\t\t\tsetTimeout(function () {\n\t\t\t\t//If we have only <= one child left then that marker will be shown on the map so don't remove it!\n\t\t\t\tvar stillThereChildCount = 0;\n\t\t\t\tfor (i = childMarkers.length - 1; i >= 0; i--) {\n\t\t\t\t\tm = childMarkers[i];\n\t\t\t\t\tif (m._spiderLeg) {\n\t\t\t\t\t\tstillThereChildCount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\t\t\t\tfor (i = childMarkers.length - 1; i >= 0; i--) {\n\t\t\t\t\tm = childMarkers[i];\n\n\t\t\t\t\tif (!m._spiderLeg) { //Has already been unspiderfied\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (m.clusterShow) {\n\t\t\t\t\t\tm.clusterShow();\n\t\t\t\t\t}\n\t\t\t\t\tif (m.setZIndexOffset) {\n\t\t\t\t\t\tm.setZIndexOffset(0);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (stillThereChildCount > 1) {\n\t\t\t\t\t\tfg.removeLayer(m);\n\t\t\t\t\t}\n\n\t\t\t\t\tmap.removeLayer(m._spiderLeg);\n\t\t\t\t\tdelete m._spiderLeg;\n\t\t\t\t}\n\t\t\t\tgroup._animationEnd();\n\t\t\t\tgroup.fire('unspiderfied', {\n\t\t\t\t\tcluster: me,\n\t\t\t\t\tmarkers: childMarkers\n\t\t\t\t});\n\t\t\t}, 200);\n\t\t}\n\t});\n\n\n\tL.MarkerClusterGroup.include({\n\t\t//The MarkerCluster currently spiderfied (if any)\n\t\t_spiderfied: null,\n\n\t\tunspiderfy: function () {\n\t\t\tthis._unspiderfy.apply(this, arguments);\n\t\t},\n\n\t\t_spiderfierOnAdd: function () {\n\t\t\tthis._map.on('click', this._unspiderfyWrapper, this);\n\n\t\t\tif (this._map.options.zoomAnimation) {\n\t\t\t\tthis._map.on('zoomstart', this._unspiderfyZoomStart, this);\n\t\t\t}\n\t\t\t//Browsers without zoomAnimation or a big zoom don't fire zoomstart\n\t\t\tthis._map.on('zoomend', this._noanimationUnspiderfy, this);\n\n\t\t\tif (!L.Browser.touch) {\n\t\t\t\tthis._map.getRenderer(this);\n\t\t\t\t//Needs to happen in the pageload, not after, or animations don't work in webkit\n\t\t\t\t//  http://stackoverflow.com/questions/8455200/svg-animate-with-dynamically-added-elements\n\t\t\t\t//Disable on touch browsers as the animation messes up on a touch zoom and isn't very noticable\n\t\t\t}\n\t\t},\n\n\t\t_spiderfierOnRemove: function () {\n\t\t\tthis._map.off('click', this._unspiderfyWrapper, this);\n\t\t\tthis._map.off('zoomstart', this._unspiderfyZoomStart, this);\n\t\t\tthis._map.off('zoomanim', this._unspiderfyZoomAnim, this);\n\t\t\tthis._map.off('zoomend', this._noanimationUnspiderfy, this);\n\n\t\t\t//Ensure that markers are back where they should be\n\t\t\t// Use no animation to avoid a sticky leaflet-cluster-anim class on mapPane\n\t\t\tthis._noanimationUnspiderfy();\n\t\t},\n\n\t\t//On zoom start we add a zoomanim handler so that we are guaranteed to be last (after markers are animated)\n\t\t//This means we can define the animation they do rather than Markers doing an animation to their actual location\n\t\t_unspiderfyZoomStart: function () {\n\t\t\tif (!this._map) { //May have been removed from the map by a zoomEnd handler\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._map.on('zoomanim', this._unspiderfyZoomAnim, this);\n\t\t},\n\n\t\t_unspiderfyZoomAnim: function (zoomDetails) {\n\t\t\t//Wait until the first zoomanim after the user has finished touch-zooming before running the animation\n\t\t\tif (L.DomUtil.hasClass(this._map._mapPane, 'leaflet-touching')) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._map.off('zoomanim', this._unspiderfyZoomAnim, this);\n\t\t\tthis._unspiderfy(zoomDetails);\n\t\t},\n\n\t\t_unspiderfyWrapper: function () {\n\t\t\t/// <summary>_unspiderfy but passes no arguments</summary>\n\t\t\tthis._unspiderfy();\n\t\t},\n\n\t\t_unspiderfy: function (zoomDetails) {\n\t\t\tif (this._spiderfied) {\n\t\t\t\tthis._spiderfied.unspiderfy(zoomDetails);\n\t\t\t}\n\t\t},\n\n\t\t_noanimationUnspiderfy: function () {\n\t\t\tif (this._spiderfied) {\n\t\t\t\tthis._spiderfied._noanimationUnspiderfy();\n\t\t\t}\n\t\t},\n\n\t\t//If the given layer is currently being spiderfied then we unspiderfy it so it isn't on the map anymore etc\n\t\t_unspiderfyLayer: function (layer) {\n\t\t\tif (layer._spiderLeg) {\n\t\t\t\tthis._featureGroup.removeLayer(layer);\n\n\t\t\t\tif (layer.clusterShow) {\n\t\t\t\t\tlayer.clusterShow();\n\t\t\t\t}\n\t\t\t\t\t//Position will be fixed up immediately in _animationUnspiderfy\n\t\t\t\tif (layer.setZIndexOffset) {\n\t\t\t\t\tlayer.setZIndexOffset(0);\n\t\t\t\t}\n\n\t\t\t\tthis._map.removeLayer(layer._spiderLeg);\n\t\t\t\tdelete layer._spiderLeg;\n\t\t\t}\n\t\t}\n\t});\n\n\t/**\n\t * Adds 1 public method to MCG and 1 to L.Marker to facilitate changing\n\t * markers' icon options and refreshing their icon and their parent clusters\n\t * accordingly (case where their iconCreateFunction uses data of childMarkers\n\t * to make up the cluster icon).\n\t */\n\n\n\tL.MarkerClusterGroup.include({\n\t\t/**\n\t\t * Updates the icon of all clusters which are parents of the given marker(s).\n\t\t * In singleMarkerMode, also updates the given marker(s) icon.\n\t\t * @param layers L.MarkerClusterGroup|L.LayerGroup|Array(L.Marker)|Map(L.Marker)|\n\t\t * L.MarkerCluster|L.Marker (optional) list of markers (or single marker) whose parent\n\t\t * clusters need to be updated. If not provided, retrieves all child markers of this.\n\t\t * @returns {L.MarkerClusterGroup}\n\t\t */\n\t\trefreshClusters: function (layers) {\n\t\t\tif (!layers) {\n\t\t\t\tlayers = this._topClusterLevel.getAllChildMarkers();\n\t\t\t} else if (layers instanceof L.MarkerClusterGroup) {\n\t\t\t\tlayers = layers._topClusterLevel.getAllChildMarkers();\n\t\t\t} else if (layers instanceof L.LayerGroup) {\n\t\t\t\tlayers = layers._layers;\n\t\t\t} else if (layers instanceof L.MarkerCluster) {\n\t\t\t\tlayers = layers.getAllChildMarkers();\n\t\t\t} else if (layers instanceof L.Marker) {\n\t\t\t\tlayers = [layers];\n\t\t\t} // else: must be an Array(L.Marker)|Map(L.Marker)\n\t\t\tthis._flagParentsIconsNeedUpdate(layers);\n\t\t\tthis._refreshClustersIcons();\n\n\t\t\t// In case of singleMarkerMode, also re-draw the markers.\n\t\t\tif (this.options.singleMarkerMode) {\n\t\t\t\tthis._refreshSingleMarkerModeMarkers(layers);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\n\t\t/**\n\t\t * Simply flags all parent clusters of the given markers as having a \"dirty\" icon.\n\t\t * @param layers Array(L.Marker)|Map(L.Marker) list of markers.\n\t\t * @private\n\t\t */\n\t\t_flagParentsIconsNeedUpdate: function (layers) {\n\t\t\tvar id, parent;\n\n\t\t\t// Assumes layers is an Array or an Object whose prototype is non-enumerable.\n\t\t\tfor (id in layers) {\n\t\t\t\t// Flag parent clusters' icon as \"dirty\", all the way up.\n\t\t\t\t// Dumb process that flags multiple times upper parents, but still\n\t\t\t\t// much more efficient than trying to be smart and make short lists,\n\t\t\t\t// at least in the case of a hierarchy following a power law:\n\t\t\t\t// http://jsperf.com/flag-nodes-in-power-hierarchy/2\n\t\t\t\tparent = layers[id].__parent;\n\t\t\t\twhile (parent) {\n\t\t\t\t\tparent._iconNeedsUpdate = true;\n\t\t\t\t\tparent = parent.__parent;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Re-draws the icon of the supplied markers.\n\t\t * To be used in singleMarkerMode only.\n\t\t * @param layers Array(L.Marker)|Map(L.Marker) list of markers.\n\t\t * @private\n\t\t */\n\t\t_refreshSingleMarkerModeMarkers: function (layers) {\n\t\t\tvar id, layer;\n\n\t\t\tfor (id in layers) {\n\t\t\t\tlayer = layers[id];\n\n\t\t\t\t// Make sure we do not override markers that do not belong to THIS group.\n\t\t\t\tif (this.hasLayer(layer)) {\n\t\t\t\t\t// Need to re-create the icon first, then re-draw the marker.\n\t\t\t\t\tlayer.setIcon(this._overrideMarkerIcon(layer));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n\tL.Marker.include({\n\t\t/**\n\t\t * Updates the given options in the marker's icon and refreshes the marker.\n\t\t * @param options map object of icon options.\n\t\t * @param directlyRefreshClusters boolean (optional) true to trigger\n\t\t * MCG.refreshClustersOf() right away with this single marker.\n\t\t * @returns {L.Marker}\n\t\t */\n\t\trefreshIconOptions: function (options, directlyRefreshClusters) {\n\t\t\tvar icon = this.options.icon;\n\n\t\t\tL.setOptions(icon, options);\n\n\t\t\tthis.setIcon(icon);\n\n\t\t\t// Shortcut to refresh the associated MCG clusters right away.\n\t\t\t// To be used when refreshing a single marker.\n\t\t\t// Otherwise, better use MCG.refreshClusters() once at the end with\n\t\t\t// the list of modified markers.\n\t\t\tif (directlyRefreshClusters && this.__parent) {\n\t\t\t\tthis.__parent._group.refreshClusters(this);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\t});\n\n\texports.MarkerClusterGroup = MarkerClusterGroup;\n\texports.MarkerCluster = MarkerCluster;\n\n\tObject.defineProperty(exports, '__esModule', { value: true });\n\n}));\n//# sourceMappingURL=leaflet.markercluster-src.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGVhZmxldC5tYXJrZXJjbHVzdGVyL2Rpc3QvbGVhZmxldC5tYXJrZXJjbHVzdGVyLXNyYy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsS0FBNEQ7QUFDN0QsQ0FBQyxDQUM4RztBQUMvRyxDQUFDLDRCQUE0Qjs7QUFFN0I7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0IsMENBQTBDOztBQUV6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsY0FBYztBQUMxQztBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsY0FBYztBQUMxQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCLGNBQWM7O0FBRXpDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsY0FBYztBQUM3QztBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0MscUNBQXFDO0FBQ3JFO0FBQ0EsK0JBQStCLGNBQWM7QUFDN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhCQUE4QixjQUFjOztBQUU1QztBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFVBQVU7QUFDMUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCLFVBQVU7QUFDekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLEtBQUs7QUFDTDs7QUFFQSxXQUFXLFlBQVk7QUFDdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDZCQUE2QjtBQUM5RDtBQUNBLGdDQUFnQyxVQUFVO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxPQUFPO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0MsVUFBVTtBQUMxQztBQUNBOztBQUVBO0FBQ0EsK0JBQStCLFVBQVU7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrREFBa0QsUUFBUTtBQUMxRDtBQUNBOztBQUVBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0MsUUFBUTtBQUN4Qzs7QUFFQSx1Q0FBdUMsUUFBUTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGdDQUFnQyxRQUFRO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDLFFBQVE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsK0NBQStDLE9BQU87QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxPQUFPO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZ0NBQWdDO0FBQ2hDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsbUNBQW1DO0FBQ25DO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLG9DQUFvQyxRQUFRO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVUsY0FBYztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLCtEQUErRDtBQUNyRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsMEJBQTBCLG9IQUFvSDtBQUM5SSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FB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QTs7QUFFQTtBQUNBLGVBQWUsNkNBQTZDOztBQUU1RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUEsZ0RBQWdELFFBQVE7QUFDeEQ7QUFDQTs7QUFFQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMEJBQTBCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLLGtDQUFrQztBQUN2QztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7OztBQUdIOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxvQkFBb0I7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QUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixXQUFXO0FBQzlCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFFBQVE7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0Esc0NBQXNDLFFBQVE7QUFDOUM7O0FBRUEsMEJBQTBCO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUEsZ0RBQWdELGFBQWE7O0FBRTdELENBQUM7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL3N0dWJibGUtYnVybmluZy1kZXRlY3Rpb24vLi9ub2RlX21vZHVsZXMvbGVhZmxldC5tYXJrZXJjbHVzdGVyL2Rpc3QvbGVhZmxldC5tYXJrZXJjbHVzdGVyLXNyYy5qcz8yNWU0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBMZWFmbGV0Lm1hcmtlcmNsdXN0ZXIgMS41LjMrbWFzdGVyLmU1MTI0YjIsXG4gKiBQcm92aWRlcyBCZWF1dGlmdWwgQW5pbWF0ZWQgTWFya2VyIENsdXN0ZXJpbmcgZnVuY3Rpb25hbGl0eSBmb3IgTGVhZmxldCwgYSBKUyBsaWJyYXJ5IGZvciBpbnRlcmFjdGl2ZSBtYXBzLlxuICogaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC5tYXJrZXJjbHVzdGVyXG4gKiAoYykgMjAxMi0yMDE3LCBEYXZlIExlYXZlciwgc21hcnRyYWtcbiAqL1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0dHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuXHQoZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYsIGZhY3RvcnkoKGdsb2JhbC5MZWFmbGV0ID0gZ2xvYmFsLkxlYWZsZXQgfHwge30sIGdsb2JhbC5MZWFmbGV0Lm1hcmtlcmNsdXN0ZXIgPSB7fSkpKTtcbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cdC8qXG5cdCAqIEwuTWFya2VyQ2x1c3Rlckdyb3VwIGV4dGVuZHMgTC5GZWF0dXJlR3JvdXAgYnkgY2x1c3RlcmluZyB0aGUgbWFya2VycyBjb250YWluZWQgd2l0aGluXG5cdCAqL1xuXG5cdHZhciBNYXJrZXJDbHVzdGVyR3JvdXAgPSBMLk1hcmtlckNsdXN0ZXJHcm91cCA9IEwuRmVhdHVyZUdyb3VwLmV4dGVuZCh7XG5cblx0XHRvcHRpb25zOiB7XG5cdFx0XHRtYXhDbHVzdGVyUmFkaXVzOiA4MCwgLy9BIGNsdXN0ZXIgd2lsbCBjb3ZlciBhdCBtb3N0IHRoaXMgbWFueSBwaXhlbHMgZnJvbSBpdHMgY2VudGVyXG5cdFx0XHRpY29uQ3JlYXRlRnVuY3Rpb246IG51bGwsXG5cdFx0XHRjbHVzdGVyUGFuZTogTC5NYXJrZXIucHJvdG90eXBlLm9wdGlvbnMucGFuZSxcblxuXHRcdFx0c3BpZGVyZnlPbkV2ZXJ5Wm9vbTogZmFsc2UsXG5cdFx0XHRzcGlkZXJmeU9uTWF4Wm9vbTogdHJ1ZSxcblx0XHRcdHNob3dDb3ZlcmFnZU9uSG92ZXI6IHRydWUsXG5cdFx0XHR6b29tVG9Cb3VuZHNPbkNsaWNrOiB0cnVlLFxuXHRcdFx0c2luZ2xlTWFya2VyTW9kZTogZmFsc2UsXG5cblx0XHRcdGRpc2FibGVDbHVzdGVyaW5nQXRab29tOiBudWxsLFxuXG5cdFx0XHQvLyBTZXR0aW5nIHRoaXMgdG8gZmFsc2UgcHJldmVudHMgdGhlIHJlbW92YWwgb2YgYW55IGNsdXN0ZXJzIG91dHNpZGUgb2YgdGhlIHZpZXdwb2ludCwgd2hpY2hcblx0XHRcdC8vIGlzIHRoZSBkZWZhdWx0IGJlaGF2aW91ciBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy5cblx0XHRcdHJlbW92ZU91dHNpZGVWaXNpYmxlQm91bmRzOiB0cnVlLFxuXG5cdFx0XHQvLyBTZXQgdG8gZmFsc2UgdG8gZGlzYWJsZSBhbGwgYW5pbWF0aW9ucyAoem9vbSBhbmQgc3BpZGVyZnkpLlxuXHRcdFx0Ly8gSWYgZmFsc2UsIG9wdGlvbiBhbmltYXRlQWRkaW5nTWFya2VycyBiZWxvdyBoYXMgbm8gZWZmZWN0LlxuXHRcdFx0Ly8gSWYgTC5Eb21VdGlsLlRSQU5TSVRJT04gaXMgZmFsc3ksIHRoaXMgb3B0aW9uIGhhcyBubyBlZmZlY3QuXG5cdFx0XHRhbmltYXRlOiB0cnVlLFxuXG5cdFx0XHQvL1doZXRoZXIgdG8gYW5pbWF0ZSBhZGRpbmcgbWFya2VycyBhZnRlciBhZGRpbmcgdGhlIE1hcmtlckNsdXN0ZXJHcm91cCB0byB0aGUgbWFwXG5cdFx0XHQvLyBJZiB5b3UgYXJlIGFkZGluZyBpbmRpdmlkdWFsIG1hcmtlcnMgc2V0IHRvIHRydWUsIGlmIGFkZGluZyBidWxrIG1hcmtlcnMgbGVhdmUgZmFsc2UgZm9yIG1hc3NpdmUgcGVyZm9ybWFuY2UgZ2FpbnMuXG5cdFx0XHRhbmltYXRlQWRkaW5nTWFya2VyczogZmFsc2UsXG5cblx0XHRcdC8vIE1ha2UgaXQgcG9zc2libGUgdG8gcHJvdmlkZSBjdXN0b20gZnVuY3Rpb24gdG8gY2FsY3VsYXRlIHNwaWRlcmZ5IHNoYXBlIHBvc2l0aW9uc1xuXHRcdFx0c3BpZGVyZnlTaGFwZVBvc2l0aW9uczogbnVsbCxcblxuXHRcdFx0Ly9JbmNyZWFzZSB0byBpbmNyZWFzZSB0aGUgZGlzdGFuY2UgYXdheSB0aGF0IHNwaWRlcmZpZWQgbWFya2VycyBhcHBlYXIgZnJvbSB0aGUgY2VudGVyXG5cdFx0XHRzcGlkZXJmeURpc3RhbmNlTXVsdGlwbGllcjogMSxcblxuXHRcdFx0Ly8gTWFrZSBpdCBwb3NzaWJsZSB0byBzcGVjaWZ5IGEgcG9seWxpbmUgb3B0aW9ucyBvbiBhIHNwaWRlciBsZWdcblx0XHRcdHNwaWRlckxlZ1BvbHlsaW5lT3B0aW9uczogeyB3ZWlnaHQ6IDEuNSwgY29sb3I6ICcjMjIyJywgb3BhY2l0eTogMC41IH0sXG5cblx0XHRcdC8vIFdoZW4gYnVsayBhZGRpbmcgbGF5ZXJzLCBhZGRzIG1hcmtlcnMgaW4gY2h1bmtzLiBNZWFucyBhZGRMYXllcnMgbWF5IG5vdCBhZGQgYWxsIHRoZSBsYXllcnMgaW4gdGhlIGNhbGwsIG90aGVycyB3aWxsIGJlIGxvYWRlZCBkdXJpbmcgc2V0VGltZW91dHNcblx0XHRcdGNodW5rZWRMb2FkaW5nOiBmYWxzZSxcblx0XHRcdGNodW5rSW50ZXJ2YWw6IDIwMCwgLy8gcHJvY2VzcyBtYXJrZXJzIGZvciBhIG1heGltdW0gb2YgfiBuIG1pbGxpc2Vjb25kcyAodGhlbiB0cmlnZ2VyIHRoZSBjaHVua1Byb2dyZXNzIGNhbGxiYWNrKVxuXHRcdFx0Y2h1bmtEZWxheTogNTAsIC8vIGF0IHRoZSBlbmQgb2YgZWFjaCBpbnRlcnZhbCwgZ2l2ZSBuIG1pbGxpc2Vjb25kcyBiYWNrIHRvIHN5c3RlbS9icm93c2VyXG5cdFx0XHRjaHVua1Byb2dyZXNzOiBudWxsLCAvLyBwcm9ncmVzcyBjYWxsYmFjazogZnVuY3Rpb24ocHJvY2Vzc2VkLCB0b3RhbCwgZWxhcHNlZCkgKGUuZy4gZm9yIGEgcHJvZ3Jlc3MgaW5kaWNhdG9yKVxuXG5cdFx0XHQvL09wdGlvbnMgdG8gcGFzcyB0byB0aGUgTC5Qb2x5Z29uIGNvbnN0cnVjdG9yXG5cdFx0XHRwb2x5Z29uT3B0aW9uczoge31cblx0XHR9LFxuXG5cdFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0XHRcdEwuVXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuXHRcdFx0aWYgKCF0aGlzLm9wdGlvbnMuaWNvbkNyZWF0ZUZ1bmN0aW9uKSB7XG5cdFx0XHRcdHRoaXMub3B0aW9ucy5pY29uQ3JlYXRlRnVuY3Rpb24gPSB0aGlzLl9kZWZhdWx0SWNvbkNyZWF0ZUZ1bmN0aW9uO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9mZWF0dXJlR3JvdXAgPSBMLmZlYXR1cmVHcm91cCgpO1xuXHRcdFx0dGhpcy5fZmVhdHVyZUdyb3VwLmFkZEV2ZW50UGFyZW50KHRoaXMpO1xuXG5cdFx0XHR0aGlzLl9ub25Qb2ludEdyb3VwID0gTC5mZWF0dXJlR3JvdXAoKTtcblx0XHRcdHRoaXMuX25vblBvaW50R3JvdXAuYWRkRXZlbnRQYXJlbnQodGhpcyk7XG5cblx0XHRcdHRoaXMuX2luWm9vbUFuaW1hdGlvbiA9IDA7XG5cdFx0XHR0aGlzLl9uZWVkc0NsdXN0ZXJpbmcgPSBbXTtcblx0XHRcdHRoaXMuX25lZWRzUmVtb3ZpbmcgPSBbXTsgLy9NYXJrZXJzIHJlbW92ZWQgd2hpbGUgd2UgYXJlbid0IG9uIHRoZSBtYXAgbmVlZCB0byBiZSBrZXB0IHRyYWNrIG9mXG5cdFx0XHQvL1RoZSBib3VuZHMgb2YgdGhlIGN1cnJlbnRseSBzaG93biBhcmVhIChmcm9tIF9nZXRFeHBhbmRlZFZpc2libGVCb3VuZHMpIFVwZGF0ZWQgb24gem9vbS9tb3ZlXG5cdFx0XHR0aGlzLl9jdXJyZW50U2hvd25Cb3VuZHMgPSBudWxsO1xuXG5cdFx0XHR0aGlzLl9xdWV1ZSA9IFtdO1xuXG5cdFx0XHR0aGlzLl9jaGlsZE1hcmtlckV2ZW50SGFuZGxlcnMgPSB7XG5cdFx0XHRcdCdkcmFnc3RhcnQnOiB0aGlzLl9jaGlsZE1hcmtlckRyYWdTdGFydCxcblx0XHRcdFx0J21vdmUnOiB0aGlzLl9jaGlsZE1hcmtlck1vdmVkLFxuXHRcdFx0XHQnZHJhZ2VuZCc6IHRoaXMuX2NoaWxkTWFya2VyRHJhZ0VuZCxcblx0XHRcdH07XG5cblx0XHRcdC8vIEhvb2sgdGhlIGFwcHJvcHJpYXRlIGFuaW1hdGlvbiBtZXRob2RzLlxuXHRcdFx0dmFyIGFuaW1hdGUgPSBMLkRvbVV0aWwuVFJBTlNJVElPTiAmJiB0aGlzLm9wdGlvbnMuYW5pbWF0ZTtcblx0XHRcdEwuZXh0ZW5kKHRoaXMsIGFuaW1hdGUgPyB0aGlzLl93aXRoQW5pbWF0aW9uIDogdGhpcy5fbm9BbmltYXRpb24pO1xuXHRcdFx0Ly8gUmVtZW1iZXIgd2hpY2ggTWFya2VyQ2x1c3RlciBjbGFzcyB0byBpbnN0YW50aWF0ZSAoYW5pbWF0ZWQgb3Igbm90KS5cblx0XHRcdHRoaXMuX21hcmtlckNsdXN0ZXIgPSBhbmltYXRlID8gTC5NYXJrZXJDbHVzdGVyIDogTC5NYXJrZXJDbHVzdGVyTm9uQW5pbWF0ZWQ7XG5cdFx0fSxcblxuXHRcdGFkZExheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcblxuXHRcdFx0aWYgKGxheWVyIGluc3RhbmNlb2YgTC5MYXllckdyb3VwKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmFkZExheWVycyhbbGF5ZXJdKTtcblx0XHRcdH1cblxuXHRcdFx0Ly9Eb24ndCBjbHVzdGVyIG5vbiBwb2ludCBkYXRhXG5cdFx0XHRpZiAoIWxheWVyLmdldExhdExuZykge1xuXHRcdFx0XHR0aGlzLl9ub25Qb2ludEdyb3VwLmFkZExheWVyKGxheWVyKTtcblx0XHRcdFx0dGhpcy5maXJlKCdsYXllcmFkZCcsIHsgbGF5ZXI6IGxheWVyIH0pO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH1cblxuXHRcdFx0aWYgKCF0aGlzLl9tYXApIHtcblx0XHRcdFx0dGhpcy5fbmVlZHNDbHVzdGVyaW5nLnB1c2gobGF5ZXIpO1xuXHRcdFx0XHR0aGlzLmZpcmUoJ2xheWVyYWRkJywgeyBsYXllcjogbGF5ZXIgfSk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5oYXNMYXllcihsYXllcikpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9XG5cblxuXHRcdFx0Ly9JZiB3ZSBoYXZlIGFscmVhZHkgY2x1c3RlcmVkIHdlJ2xsIG5lZWQgdG8gYWRkIHRoaXMgb25lIHRvIGEgY2x1c3RlclxuXG5cdFx0XHRpZiAodGhpcy5fdW5zcGlkZXJmeSkge1xuXHRcdFx0XHR0aGlzLl91bnNwaWRlcmZ5KCk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX2FkZExheWVyKGxheWVyLCB0aGlzLl9tYXhab29tKTtcblx0XHRcdHRoaXMuZmlyZSgnbGF5ZXJhZGQnLCB7IGxheWVyOiBsYXllciB9KTtcblxuXHRcdFx0Ly8gUmVmcmVzaCBib3VuZHMgYW5kIHdlaWdodGVkIHBvc2l0aW9ucy5cblx0XHRcdHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5fcmVjYWxjdWxhdGVCb3VuZHMoKTtcblxuXHRcdFx0dGhpcy5fcmVmcmVzaENsdXN0ZXJzSWNvbnMoKTtcblxuXHRcdFx0Ly9Xb3JrIG91dCB3aGF0IGlzIHZpc2libGVcblx0XHRcdHZhciB2aXNpYmxlTGF5ZXIgPSBsYXllcixcblx0XHRcdCAgICBjdXJyZW50Wm9vbSA9IHRoaXMuX3pvb207XG5cdFx0XHRpZiAobGF5ZXIuX19wYXJlbnQpIHtcblx0XHRcdFx0d2hpbGUgKHZpc2libGVMYXllci5fX3BhcmVudC5fem9vbSA+PSBjdXJyZW50Wm9vbSkge1xuXHRcdFx0XHRcdHZpc2libGVMYXllciA9IHZpc2libGVMYXllci5fX3BhcmVudDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5fY3VycmVudFNob3duQm91bmRzLmNvbnRhaW5zKHZpc2libGVMYXllci5nZXRMYXRMbmcoKSkpIHtcblx0XHRcdFx0aWYgKHRoaXMub3B0aW9ucy5hbmltYXRlQWRkaW5nTWFya2Vycykge1xuXHRcdFx0XHRcdHRoaXMuX2FuaW1hdGlvbkFkZExheWVyKGxheWVyLCB2aXNpYmxlTGF5ZXIpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuX2FuaW1hdGlvbkFkZExheWVyTm9uQW5pbWF0ZWQobGF5ZXIsIHZpc2libGVMYXllcik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH0sXG5cblx0XHRyZW1vdmVMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XG5cblx0XHRcdGlmIChsYXllciBpbnN0YW5jZW9mIEwuTGF5ZXJHcm91cCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5yZW1vdmVMYXllcnMoW2xheWVyXSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vTm9uIHBvaW50IGxheWVyc1xuXHRcdFx0aWYgKCFsYXllci5nZXRMYXRMbmcpIHtcblx0XHRcdFx0dGhpcy5fbm9uUG9pbnRHcm91cC5yZW1vdmVMYXllcihsYXllcik7XG5cdFx0XHRcdHRoaXMuZmlyZSgnbGF5ZXJyZW1vdmUnLCB7IGxheWVyOiBsYXllciB9KTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghdGhpcy5fbWFwKSB7XG5cdFx0XHRcdGlmICghdGhpcy5fYXJyYXlTcGxpY2UodGhpcy5fbmVlZHNDbHVzdGVyaW5nLCBsYXllcikgJiYgdGhpcy5oYXNMYXllcihsYXllcikpIHtcblx0XHRcdFx0XHR0aGlzLl9uZWVkc1JlbW92aW5nLnB1c2goeyBsYXllcjogbGF5ZXIsIGxhdGxuZzogbGF5ZXIuX2xhdGxuZyB9KTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLmZpcmUoJ2xheWVycmVtb3ZlJywgeyBsYXllcjogbGF5ZXIgfSk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIWxheWVyLl9fcGFyZW50KSB7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5fdW5zcGlkZXJmeSkge1xuXHRcdFx0XHR0aGlzLl91bnNwaWRlcmZ5KCk7XG5cdFx0XHRcdHRoaXMuX3Vuc3BpZGVyZnlMYXllcihsYXllcik7XG5cdFx0XHR9XG5cblx0XHRcdC8vUmVtb3ZlIHRoZSBtYXJrZXIgZnJvbSBjbHVzdGVyc1xuXHRcdFx0dGhpcy5fcmVtb3ZlTGF5ZXIobGF5ZXIsIHRydWUpO1xuXHRcdFx0dGhpcy5maXJlKCdsYXllcnJlbW92ZScsIHsgbGF5ZXI6IGxheWVyIH0pO1xuXG5cdFx0XHQvLyBSZWZyZXNoIGJvdW5kcyBhbmQgd2VpZ2h0ZWQgcG9zaXRpb25zLlxuXHRcdFx0dGhpcy5fdG9wQ2x1c3RlckxldmVsLl9yZWNhbGN1bGF0ZUJvdW5kcygpO1xuXG5cdFx0XHR0aGlzLl9yZWZyZXNoQ2x1c3RlcnNJY29ucygpO1xuXG5cdFx0XHRsYXllci5vZmYodGhpcy5fY2hpbGRNYXJrZXJFdmVudEhhbmRsZXJzLCB0aGlzKTtcblxuXHRcdFx0aWYgKHRoaXMuX2ZlYXR1cmVHcm91cC5oYXNMYXllcihsYXllcikpIHtcblx0XHRcdFx0dGhpcy5fZmVhdHVyZUdyb3VwLnJlbW92ZUxheWVyKGxheWVyKTtcblx0XHRcdFx0aWYgKGxheWVyLmNsdXN0ZXJTaG93KSB7XG5cdFx0XHRcdFx0bGF5ZXIuY2x1c3RlclNob3coKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9LFxuXG5cdFx0Ly9UYWtlcyBhbiBhcnJheSBvZiBtYXJrZXJzIGFuZCBhZGRzIHRoZW0gaW4gYnVsa1xuXHRcdGFkZExheWVyczogZnVuY3Rpb24gKGxheWVyc0FycmF5LCBza2lwTGF5ZXJBZGRFdmVudCkge1xuXHRcdFx0aWYgKCFMLlV0aWwuaXNBcnJheShsYXllcnNBcnJheSkpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuYWRkTGF5ZXIobGF5ZXJzQXJyYXkpO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgZmcgPSB0aGlzLl9mZWF0dXJlR3JvdXAsXG5cdFx0XHQgICAgbnBnID0gdGhpcy5fbm9uUG9pbnRHcm91cCxcblx0XHRcdCAgICBjaHVua2VkID0gdGhpcy5vcHRpb25zLmNodW5rZWRMb2FkaW5nLFxuXHRcdFx0ICAgIGNodW5rSW50ZXJ2YWwgPSB0aGlzLm9wdGlvbnMuY2h1bmtJbnRlcnZhbCxcblx0XHRcdCAgICBjaHVua1Byb2dyZXNzID0gdGhpcy5vcHRpb25zLmNodW5rUHJvZ3Jlc3MsXG5cdFx0XHQgICAgbCA9IGxheWVyc0FycmF5Lmxlbmd0aCxcblx0XHRcdCAgICBvZmZzZXQgPSAwLFxuXHRcdFx0ICAgIG9yaWdpbmFsQXJyYXkgPSB0cnVlLFxuXHRcdFx0ICAgIG07XG5cblx0XHRcdGlmICh0aGlzLl9tYXApIHtcblx0XHRcdFx0dmFyIHN0YXJ0ZWQgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuXHRcdFx0XHR2YXIgcHJvY2VzcyA9IEwuYmluZChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0dmFyIHN0YXJ0ID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcblxuXHRcdFx0XHRcdC8vIE1ha2Ugc3VyZSB0byB1bnNwaWRlcmZ5IGJlZm9yZSBzdGFydGluZyB0byBhZGQgc29tZSBsYXllcnNcblx0XHRcdFx0XHRpZiAodGhpcy5fbWFwICYmIHRoaXMuX3Vuc3BpZGVyZnkpIHtcblx0XHRcdFx0XHRcdHRoaXMuX3Vuc3BpZGVyZnkoKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRmb3IgKDsgb2Zmc2V0IDwgbDsgb2Zmc2V0KyspIHtcblx0XHRcdFx0XHRcdGlmIChjaHVua2VkICYmIG9mZnNldCAlIDIwMCA9PT0gMCkge1xuXHRcdFx0XHRcdFx0XHQvLyBldmVyeSBjb3VwbGUgaHVuZHJlZCBtYXJrZXJzLCBpbnN0cnVtZW50IHRoZSB0aW1lIGVsYXBzZWQgc2luY2UgcHJvY2Vzc2luZyBzdGFydGVkOlxuXHRcdFx0XHRcdFx0XHR2YXIgZWxhcHNlZCA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkgLSBzdGFydDtcblx0XHRcdFx0XHRcdFx0aWYgKGVsYXBzZWQgPiBjaHVua0ludGVydmFsKSB7XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7IC8vIGJlZW4gd29ya2luZyB0b28gaGFyZCwgdGltZSB0byB0YWtlIGEgYnJlYWsgOi0pXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0bSA9IGxheWVyc0FycmF5W29mZnNldF07XG5cblx0XHRcdFx0XHRcdC8vIEdyb3VwIG9mIGxheWVycywgYXBwZW5kIGNoaWxkcmVuIHRvIGxheWVyc0FycmF5IGFuZCBza2lwLlxuXHRcdFx0XHRcdFx0Ly8gU2lkZSBlZmZlY3RzOlxuXHRcdFx0XHRcdFx0Ly8gLSBUb3RhbCBpbmNyZWFzZXMsIHNvIGNodW5rUHJvZ3Jlc3MgcmF0aW8ganVtcHMgYmFja3dhcmQuXG5cdFx0XHRcdFx0XHQvLyAtIEdyb3VwcyBhcmUgbm90IGluY2x1ZGVkIGluIHRoaXMgZ3JvdXAsIG9ubHkgdGhlaXIgbm9uLWdyb3VwIGNoaWxkIGxheWVycyAoaGFzTGF5ZXIpLlxuXHRcdFx0XHRcdFx0Ly8gQ2hhbmdpbmcgYXJyYXkgbGVuZ3RoIHdoaWxlIGxvb3BpbmcgZG9lcyBub3QgYWZmZWN0IHBlcmZvcm1hbmNlIGluIGN1cnJlbnQgYnJvd3NlcnM6XG5cdFx0XHRcdFx0XHQvLyBodHRwOi8vanNwZXJmLmNvbS9mb3ItbG9vcC1jaGFuZ2luZy1sZW5ndGgvNlxuXHRcdFx0XHRcdFx0aWYgKG0gaW5zdGFuY2VvZiBMLkxheWVyR3JvdXApIHtcblx0XHRcdFx0XHRcdFx0aWYgKG9yaWdpbmFsQXJyYXkpIHtcblx0XHRcdFx0XHRcdFx0XHRsYXllcnNBcnJheSA9IGxheWVyc0FycmF5LnNsaWNlKCk7XG5cdFx0XHRcdFx0XHRcdFx0b3JpZ2luYWxBcnJheSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHRoaXMuX2V4dHJhY3ROb25Hcm91cExheWVycyhtLCBsYXllcnNBcnJheSk7XG5cdFx0XHRcdFx0XHRcdGwgPSBsYXllcnNBcnJheS5sZW5ndGg7XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvL05vdCBwb2ludCBkYXRhLCBjYW4ndCBiZSBjbHVzdGVyZWRcblx0XHRcdFx0XHRcdGlmICghbS5nZXRMYXRMbmcpIHtcblx0XHRcdFx0XHRcdFx0bnBnLmFkZExheWVyKG0pO1xuXHRcdFx0XHRcdFx0XHRpZiAoIXNraXBMYXllckFkZEV2ZW50KSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5maXJlKCdsYXllcmFkZCcsIHsgbGF5ZXI6IG0gfSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmICh0aGlzLmhhc0xheWVyKG0pKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR0aGlzLl9hZGRMYXllcihtLCB0aGlzLl9tYXhab29tKTtcblx0XHRcdFx0XHRcdGlmICghc2tpcExheWVyQWRkRXZlbnQpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5maXJlKCdsYXllcmFkZCcsIHsgbGF5ZXI6IG0gfSk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vSWYgd2UganVzdCBtYWRlIGEgY2x1c3RlciBvZiBzaXplIDIgdGhlbiB3ZSBuZWVkIHRvIHJlbW92ZSB0aGUgb3RoZXIgbWFya2VyIGZyb20gdGhlIG1hcCAoaWYgaXQgaXMpIG9yIHdlIG5ldmVyIHdpbGxcblx0XHRcdFx0XHRcdGlmIChtLl9fcGFyZW50KSB7XG5cdFx0XHRcdFx0XHRcdGlmIChtLl9fcGFyZW50LmdldENoaWxkQ291bnQoKSA9PT0gMikge1xuXHRcdFx0XHRcdFx0XHRcdHZhciBtYXJrZXJzID0gbS5fX3BhcmVudC5nZXRBbGxDaGlsZE1hcmtlcnMoKSxcblx0XHRcdFx0XHRcdFx0XHQgICAgb3RoZXJNYXJrZXIgPSBtYXJrZXJzWzBdID09PSBtID8gbWFya2Vyc1sxXSA6IG1hcmtlcnNbMF07XG5cdFx0XHRcdFx0XHRcdFx0ZmcucmVtb3ZlTGF5ZXIob3RoZXJNYXJrZXIpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKGNodW5rUHJvZ3Jlc3MpIHtcblx0XHRcdFx0XHRcdC8vIHJlcG9ydCBwcm9ncmVzcyBhbmQgdGltZSBlbGFwc2VkOlxuXHRcdFx0XHRcdFx0Y2h1bmtQcm9ncmVzcyhvZmZzZXQsIGwsIChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkgLSBzdGFydGVkKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBDb21wbGV0ZWQgcHJvY2Vzc2luZyBhbGwgbWFya2Vycy5cblx0XHRcdFx0XHRpZiAob2Zmc2V0ID09PSBsKSB7XG5cblx0XHRcdFx0XHRcdC8vIFJlZnJlc2ggYm91bmRzIGFuZCB3ZWlnaHRlZCBwb3NpdGlvbnMuXG5cdFx0XHRcdFx0XHR0aGlzLl90b3BDbHVzdGVyTGV2ZWwuX3JlY2FsY3VsYXRlQm91bmRzKCk7XG5cblx0XHRcdFx0XHRcdHRoaXMuX3JlZnJlc2hDbHVzdGVyc0ljb25zKCk7XG5cblx0XHRcdFx0XHRcdHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5fcmVjdXJzaXZlbHlBZGRDaGlsZHJlblRvTWFwKG51bGwsIHRoaXMuX3pvb20sIHRoaXMuX2N1cnJlbnRTaG93bkJvdW5kcyk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHNldFRpbWVvdXQocHJvY2VzcywgdGhpcy5vcHRpb25zLmNodW5rRGVsYXkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSwgdGhpcyk7XG5cblx0XHRcdFx0cHJvY2VzcygpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIG5lZWRzQ2x1c3RlcmluZyA9IHRoaXMuX25lZWRzQ2x1c3RlcmluZztcblxuXHRcdFx0XHRmb3IgKDsgb2Zmc2V0IDwgbDsgb2Zmc2V0KyspIHtcblx0XHRcdFx0XHRtID0gbGF5ZXJzQXJyYXlbb2Zmc2V0XTtcblxuXHRcdFx0XHRcdC8vIEdyb3VwIG9mIGxheWVycywgYXBwZW5kIGNoaWxkcmVuIHRvIGxheWVyc0FycmF5IGFuZCBza2lwLlxuXHRcdFx0XHRcdGlmIChtIGluc3RhbmNlb2YgTC5MYXllckdyb3VwKSB7XG5cdFx0XHRcdFx0XHRpZiAob3JpZ2luYWxBcnJheSkge1xuXHRcdFx0XHRcdFx0XHRsYXllcnNBcnJheSA9IGxheWVyc0FycmF5LnNsaWNlKCk7XG5cdFx0XHRcdFx0XHRcdG9yaWdpbmFsQXJyYXkgPSBmYWxzZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHRoaXMuX2V4dHJhY3ROb25Hcm91cExheWVycyhtLCBsYXllcnNBcnJheSk7XG5cdFx0XHRcdFx0XHRsID0gbGF5ZXJzQXJyYXkubGVuZ3RoO1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly9Ob3QgcG9pbnQgZGF0YSwgY2FuJ3QgYmUgY2x1c3RlcmVkXG5cdFx0XHRcdFx0aWYgKCFtLmdldExhdExuZykge1xuXHRcdFx0XHRcdFx0bnBnLmFkZExheWVyKG0pO1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKHRoaXMuaGFzTGF5ZXIobSkpIHtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG5lZWRzQ2x1c3RlcmluZy5wdXNoKG0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9LFxuXG5cdFx0Ly9UYWtlcyBhbiBhcnJheSBvZiBtYXJrZXJzIGFuZCByZW1vdmVzIHRoZW0gaW4gYnVsa1xuXHRcdHJlbW92ZUxheWVyczogZnVuY3Rpb24gKGxheWVyc0FycmF5KSB7XG5cdFx0XHR2YXIgaSwgbSxcblx0XHRcdCAgICBsID0gbGF5ZXJzQXJyYXkubGVuZ3RoLFxuXHRcdFx0ICAgIGZnID0gdGhpcy5fZmVhdHVyZUdyb3VwLFxuXHRcdFx0ICAgIG5wZyA9IHRoaXMuX25vblBvaW50R3JvdXAsXG5cdFx0XHQgICAgb3JpZ2luYWxBcnJheSA9IHRydWU7XG5cblx0XHRcdGlmICghdGhpcy5fbWFwKSB7XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRtID0gbGF5ZXJzQXJyYXlbaV07XG5cblx0XHRcdFx0XHQvLyBHcm91cCBvZiBsYXllcnMsIGFwcGVuZCBjaGlsZHJlbiB0byBsYXllcnNBcnJheSBhbmQgc2tpcC5cblx0XHRcdFx0XHRpZiAobSBpbnN0YW5jZW9mIEwuTGF5ZXJHcm91cCkge1xuXHRcdFx0XHRcdFx0aWYgKG9yaWdpbmFsQXJyYXkpIHtcblx0XHRcdFx0XHRcdFx0bGF5ZXJzQXJyYXkgPSBsYXllcnNBcnJheS5zbGljZSgpO1xuXHRcdFx0XHRcdFx0XHRvcmlnaW5hbEFycmF5ID0gZmFsc2U7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0aGlzLl9leHRyYWN0Tm9uR3JvdXBMYXllcnMobSwgbGF5ZXJzQXJyYXkpO1xuXHRcdFx0XHRcdFx0bCA9IGxheWVyc0FycmF5Lmxlbmd0aDtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHRoaXMuX2FycmF5U3BsaWNlKHRoaXMuX25lZWRzQ2x1c3RlcmluZywgbSk7XG5cdFx0XHRcdFx0bnBnLnJlbW92ZUxheWVyKG0pO1xuXHRcdFx0XHRcdGlmICh0aGlzLmhhc0xheWVyKG0pKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9uZWVkc1JlbW92aW5nLnB1c2goeyBsYXllcjogbSwgbGF0bG5nOiBtLl9sYXRsbmcgfSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMuZmlyZSgnbGF5ZXJyZW1vdmUnLCB7IGxheWVyOiBtIH0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5fdW5zcGlkZXJmeSkge1xuXHRcdFx0XHR0aGlzLl91bnNwaWRlcmZ5KCk7XG5cblx0XHRcdFx0Ly8gV29yayBvbiBhIGNvcHkgb2YgdGhlIGFycmF5LCBzbyB0aGF0IG5leHQgbG9vcCBpcyBub3QgYWZmZWN0ZWQuXG5cdFx0XHRcdHZhciBsYXllcnNBcnJheTIgPSBsYXllcnNBcnJheS5zbGljZSgpLFxuXHRcdFx0XHQgICAgbDIgPSBsO1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgbDI7IGkrKykge1xuXHRcdFx0XHRcdG0gPSBsYXllcnNBcnJheTJbaV07XG5cblx0XHRcdFx0XHQvLyBHcm91cCBvZiBsYXllcnMsIGFwcGVuZCBjaGlsZHJlbiB0byBsYXllcnNBcnJheSBhbmQgc2tpcC5cblx0XHRcdFx0XHRpZiAobSBpbnN0YW5jZW9mIEwuTGF5ZXJHcm91cCkge1xuXHRcdFx0XHRcdFx0dGhpcy5fZXh0cmFjdE5vbkdyb3VwTGF5ZXJzKG0sIGxheWVyc0FycmF5Mik7XG5cdFx0XHRcdFx0XHRsMiA9IGxheWVyc0FycmF5Mi5sZW5ndGg7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR0aGlzLl91bnNwaWRlcmZ5TGF5ZXIobSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRtID0gbGF5ZXJzQXJyYXlbaV07XG5cblx0XHRcdFx0Ly8gR3JvdXAgb2YgbGF5ZXJzLCBhcHBlbmQgY2hpbGRyZW4gdG8gbGF5ZXJzQXJyYXkgYW5kIHNraXAuXG5cdFx0XHRcdGlmIChtIGluc3RhbmNlb2YgTC5MYXllckdyb3VwKSB7XG5cdFx0XHRcdFx0aWYgKG9yaWdpbmFsQXJyYXkpIHtcblx0XHRcdFx0XHRcdGxheWVyc0FycmF5ID0gbGF5ZXJzQXJyYXkuc2xpY2UoKTtcblx0XHRcdFx0XHRcdG9yaWdpbmFsQXJyYXkgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5fZXh0cmFjdE5vbkdyb3VwTGF5ZXJzKG0sIGxheWVyc0FycmF5KTtcblx0XHRcdFx0XHRsID0gbGF5ZXJzQXJyYXkubGVuZ3RoO1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCFtLl9fcGFyZW50KSB7XG5cdFx0XHRcdFx0bnBnLnJlbW92ZUxheWVyKG0pO1xuXHRcdFx0XHRcdHRoaXMuZmlyZSgnbGF5ZXJyZW1vdmUnLCB7IGxheWVyOiBtIH0pO1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5fcmVtb3ZlTGF5ZXIobSwgdHJ1ZSwgdHJ1ZSk7XG5cdFx0XHRcdHRoaXMuZmlyZSgnbGF5ZXJyZW1vdmUnLCB7IGxheWVyOiBtIH0pO1xuXG5cdFx0XHRcdGlmIChmZy5oYXNMYXllcihtKSkge1xuXHRcdFx0XHRcdGZnLnJlbW92ZUxheWVyKG0pO1xuXHRcdFx0XHRcdGlmIChtLmNsdXN0ZXJTaG93KSB7XG5cdFx0XHRcdFx0XHRtLmNsdXN0ZXJTaG93KCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlZnJlc2ggYm91bmRzIGFuZCB3ZWlnaHRlZCBwb3NpdGlvbnMuXG5cdFx0XHR0aGlzLl90b3BDbHVzdGVyTGV2ZWwuX3JlY2FsY3VsYXRlQm91bmRzKCk7XG5cblx0XHRcdHRoaXMuX3JlZnJlc2hDbHVzdGVyc0ljb25zKCk7XG5cblx0XHRcdC8vRml4IHVwIHRoZSBjbHVzdGVycyBhbmQgbWFya2VycyBvbiB0aGUgbWFwXG5cdFx0XHR0aGlzLl90b3BDbHVzdGVyTGV2ZWwuX3JlY3Vyc2l2ZWx5QWRkQ2hpbGRyZW5Ub01hcChudWxsLCB0aGlzLl96b29tLCB0aGlzLl9jdXJyZW50U2hvd25Cb3VuZHMpO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9LFxuXG5cdFx0Ly9SZW1vdmVzIGFsbCBsYXllcnMgZnJvbSB0aGUgTWFya2VyQ2x1c3Rlckdyb3VwXG5cdFx0Y2xlYXJMYXllcnM6IGZ1bmN0aW9uICgpIHtcblx0XHRcdC8vTmVlZCBvdXIgb3duIHNwZWNpYWwgaW1wbGVtZW50YXRpb24gYXMgdGhlIExheWVyR3JvdXAgb25lIGRvZXNuJ3Qgd29yayBmb3IgdXNcblxuXHRcdFx0Ly9JZiB3ZSBhcmVuJ3Qgb24gdGhlIG1hcCAoeWV0KSwgYmxvdyBhd2F5IHRoZSBtYXJrZXJzIHdlIGtub3cgb2Zcblx0XHRcdGlmICghdGhpcy5fbWFwKSB7XG5cdFx0XHRcdHRoaXMuX25lZWRzQ2x1c3RlcmluZyA9IFtdO1xuXHRcdFx0XHR0aGlzLl9uZWVkc1JlbW92aW5nID0gW107XG5cdFx0XHRcdGRlbGV0ZSB0aGlzLl9ncmlkQ2x1c3RlcnM7XG5cdFx0XHRcdGRlbGV0ZSB0aGlzLl9ncmlkVW5jbHVzdGVyZWQ7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGlzLl9ub2FuaW1hdGlvblVuc3BpZGVyZnkpIHtcblx0XHRcdFx0dGhpcy5fbm9hbmltYXRpb25VbnNwaWRlcmZ5KCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vUmVtb3ZlIGFsbCB0aGUgdmlzaWJsZSBsYXllcnNcblx0XHRcdHRoaXMuX2ZlYXR1cmVHcm91cC5jbGVhckxheWVycygpO1xuXHRcdFx0dGhpcy5fbm9uUG9pbnRHcm91cC5jbGVhckxheWVycygpO1xuXG5cdFx0XHR0aGlzLmVhY2hMYXllcihmdW5jdGlvbiAobWFya2VyKSB7XG5cdFx0XHRcdG1hcmtlci5vZmYodGhpcy5fY2hpbGRNYXJrZXJFdmVudEhhbmRsZXJzLCB0aGlzKTtcblx0XHRcdFx0ZGVsZXRlIG1hcmtlci5fX3BhcmVudDtcblx0XHRcdH0sIHRoaXMpO1xuXG5cdFx0XHRpZiAodGhpcy5fbWFwKSB7XG5cdFx0XHRcdC8vUmVzZXQgX3RvcENsdXN0ZXJMZXZlbCBhbmQgdGhlIERpc3RhbmNlR3JpZHNcblx0XHRcdFx0dGhpcy5fZ2VuZXJhdGVJbml0aWFsQ2x1c3RlcnMoKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSxcblxuXHRcdC8vT3ZlcnJpZGUgRmVhdHVyZUdyb3VwLmdldEJvdW5kcyBhcyBpdCBkb2Vzbid0IHdvcmtcblx0XHRnZXRCb3VuZHM6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBib3VuZHMgPSBuZXcgTC5MYXRMbmdCb3VuZHMoKTtcblxuXHRcdFx0aWYgKHRoaXMuX3RvcENsdXN0ZXJMZXZlbCkge1xuXHRcdFx0XHRib3VuZHMuZXh0ZW5kKHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5fYm91bmRzKTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yICh2YXIgaSA9IHRoaXMuX25lZWRzQ2x1c3RlcmluZy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHRib3VuZHMuZXh0ZW5kKHRoaXMuX25lZWRzQ2x1c3RlcmluZ1tpXS5nZXRMYXRMbmcoKSk7XG5cdFx0XHR9XG5cblx0XHRcdGJvdW5kcy5leHRlbmQodGhpcy5fbm9uUG9pbnRHcm91cC5nZXRCb3VuZHMoKSk7XG5cblx0XHRcdHJldHVybiBib3VuZHM7XG5cdFx0fSxcblxuXHRcdC8vT3ZlcnJpZGVzIExheWVyR3JvdXAuZWFjaExheWVyXG5cdFx0ZWFjaExheWVyOiBmdW5jdGlvbiAobWV0aG9kLCBjb250ZXh0KSB7XG5cdFx0XHR2YXIgbWFya2VycyA9IHRoaXMuX25lZWRzQ2x1c3RlcmluZy5zbGljZSgpLFxuXHRcdFx0XHRuZWVkc1JlbW92aW5nID0gdGhpcy5fbmVlZHNSZW1vdmluZyxcblx0XHRcdFx0dGhpc05lZWRzUmVtb3ZpbmcsIGksIGo7XG5cblx0XHRcdGlmICh0aGlzLl90b3BDbHVzdGVyTGV2ZWwpIHtcblx0XHRcdFx0dGhpcy5fdG9wQ2x1c3RlckxldmVsLmdldEFsbENoaWxkTWFya2VycyhtYXJrZXJzKTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yIChpID0gbWFya2Vycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHR0aGlzTmVlZHNSZW1vdmluZyA9IHRydWU7XG5cblx0XHRcdFx0Zm9yIChqID0gbmVlZHNSZW1vdmluZy5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xuXHRcdFx0XHRcdGlmIChuZWVkc1JlbW92aW5nW2pdLmxheWVyID09PSBtYXJrZXJzW2ldKSB7XG5cdFx0XHRcdFx0XHR0aGlzTmVlZHNSZW1vdmluZyA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHRoaXNOZWVkc1JlbW92aW5nKSB7XG5cdFx0XHRcdFx0bWV0aG9kLmNhbGwoY29udGV4dCwgbWFya2Vyc1tpXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fbm9uUG9pbnRHcm91cC5lYWNoTGF5ZXIobWV0aG9kLCBjb250ZXh0KTtcblx0XHR9LFxuXG5cdFx0Ly9PdmVycmlkZXMgTGF5ZXJHcm91cC5nZXRMYXllcnNcblx0XHRnZXRMYXllcnM6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBsYXllcnMgPSBbXTtcblx0XHRcdHRoaXMuZWFjaExheWVyKGZ1bmN0aW9uIChsKSB7XG5cdFx0XHRcdGxheWVycy5wdXNoKGwpO1xuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gbGF5ZXJzO1xuXHRcdH0sXG5cblx0XHQvL092ZXJyaWRlcyBMYXllckdyb3VwLmdldExheWVyLCBXQVJOSU5HOiBSZWFsbHkgYmFkIHBlcmZvcm1hbmNlXG5cdFx0Z2V0TGF5ZXI6IGZ1bmN0aW9uIChpZCkge1xuXHRcdFx0dmFyIHJlc3VsdCA9IG51bGw7XG5cblx0XHRcdGlkID0gcGFyc2VJbnQoaWQsIDEwKTtcblxuXHRcdFx0dGhpcy5lYWNoTGF5ZXIoZnVuY3Rpb24gKGwpIHtcblx0XHRcdFx0aWYgKEwuc3RhbXAobCkgPT09IGlkKSB7XG5cdFx0XHRcdFx0cmVzdWx0ID0gbDtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fSxcblxuXHRcdC8vUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBsYXllciBpcyBpbiB0aGlzIE1hcmtlckNsdXN0ZXJHcm91cFxuXHRcdGhhc0xheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRcdGlmICghbGF5ZXIpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgaSwgYW5BcnJheSA9IHRoaXMuX25lZWRzQ2x1c3RlcmluZztcblxuXHRcdFx0Zm9yIChpID0gYW5BcnJheS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHRpZiAoYW5BcnJheVtpXSA9PT0gbGF5ZXIpIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRhbkFycmF5ID0gdGhpcy5fbmVlZHNSZW1vdmluZztcblx0XHRcdGZvciAoaSA9IGFuQXJyYXkubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0aWYgKGFuQXJyYXlbaV0ubGF5ZXIgPT09IGxheWVyKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAhIShsYXllci5fX3BhcmVudCAmJiBsYXllci5fX3BhcmVudC5fZ3JvdXAgPT09IHRoaXMpIHx8IHRoaXMuX25vblBvaW50R3JvdXAuaGFzTGF5ZXIobGF5ZXIpO1xuXHRcdH0sXG5cblx0XHQvL1pvb20gZG93biB0byBzaG93IHRoZSBnaXZlbiBsYXllciAoc3BpZGVyZnlpbmcgaWYgbmVjZXNzYXJ5KSB0aGVuIGNhbGxzIHRoZSBjYWxsYmFja1xuXHRcdHpvb21Ub1Nob3dMYXllcjogZnVuY3Rpb24gKGxheWVyLCBjYWxsYmFjaykge1xuXG5cdFx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xuXG5cdFx0XHRpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdGNhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XG5cdFx0XHR9XG5cblx0XHRcdHZhciBzaG93TWFya2VyID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHQvLyBBc3N1bWVzIHRoYXQgbWFwLmhhc0xheWVyIGNoZWNrcyBmb3IgZGlyZWN0IGFwcGVhcmFuY2Ugb24gbWFwLCBub3QgcmVjdXJzaXZlbHkgY2FsbGluZ1xuXHRcdFx0XHQvLyBoYXNMYXllciBvbiBMYXllciBHcm91cHMgdGhhdCBhcmUgb24gbWFwICh0eXBpY2FsbHkgbm90IGNhbGxpbmcgdGhpcyBNYXJrZXJDbHVzdGVyR3JvdXAuaGFzTGF5ZXIsIHdoaWNoIHdvdWxkIGFsd2F5cyByZXR1cm4gdHJ1ZSlcblx0XHRcdFx0aWYgKChtYXAuaGFzTGF5ZXIobGF5ZXIpIHx8IG1hcC5oYXNMYXllcihsYXllci5fX3BhcmVudCkpICYmICF0aGlzLl9pblpvb21BbmltYXRpb24pIHtcblx0XHRcdFx0XHR0aGlzLl9tYXAub2ZmKCdtb3ZlZW5kJywgc2hvd01hcmtlciwgdGhpcyk7XG5cdFx0XHRcdFx0dGhpcy5vZmYoJ2FuaW1hdGlvbmVuZCcsIHNob3dNYXJrZXIsIHRoaXMpO1xuXG5cdFx0XHRcdFx0aWYgKG1hcC5oYXNMYXllcihsYXllcikpIHtcblx0XHRcdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChsYXllci5fX3BhcmVudC5faWNvbikge1xuXHRcdFx0XHRcdFx0dGhpcy5vbmNlKCdzcGlkZXJmaWVkJywgY2FsbGJhY2ssIHRoaXMpO1xuXHRcdFx0XHRcdFx0bGF5ZXIuX19wYXJlbnQuc3BpZGVyZnkoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRcdGlmIChsYXllci5faWNvbiAmJiB0aGlzLl9tYXAuZ2V0Qm91bmRzKCkuY29udGFpbnMobGF5ZXIuZ2V0TGF0TG5nKCkpKSB7XG5cdFx0XHRcdC8vTGF5ZXIgaXMgdmlzaWJsZSBvbmQgb24gc2NyZWVuLCBpbW1lZGlhdGUgcmV0dXJuXG5cdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHR9IGVsc2UgaWYgKGxheWVyLl9fcGFyZW50Ll96b29tIDwgTWF0aC5yb3VuZCh0aGlzLl9tYXAuX3pvb20pKSB7XG5cdFx0XHRcdC8vTGF5ZXIgc2hvdWxkIGJlIHZpc2libGUgYXQgdGhpcyB6b29tIGxldmVsLiBJdCBtdXN0IG5vdCBiZSBvbiBzY3JlZW4gc28ganVzdCBwYW4gb3ZlciB0byBpdFxuXHRcdFx0XHR0aGlzLl9tYXAub24oJ21vdmVlbmQnLCBzaG93TWFya2VyLCB0aGlzKTtcblx0XHRcdFx0dGhpcy5fbWFwLnBhblRvKGxheWVyLmdldExhdExuZygpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuX21hcC5vbignbW92ZWVuZCcsIHNob3dNYXJrZXIsIHRoaXMpO1xuXHRcdFx0XHR0aGlzLm9uKCdhbmltYXRpb25lbmQnLCBzaG93TWFya2VyLCB0aGlzKTtcblx0XHRcdFx0bGF5ZXIuX19wYXJlbnQuem9vbVRvQm91bmRzKCk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8vT3ZlcnJpZGVzIEZlYXR1cmVHcm91cC5vbkFkZFxuXHRcdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0XHR0aGlzLl9tYXAgPSBtYXA7XG5cdFx0XHR2YXIgaSwgbCwgbGF5ZXI7XG5cblx0XHRcdGlmICghaXNGaW5pdGUodGhpcy5fbWFwLmdldE1heFpvb20oKSkpIHtcblx0XHRcdFx0dGhyb3cgXCJNYXAgaGFzIG5vIG1heFpvb20gc3BlY2lmaWVkXCI7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX2ZlYXR1cmVHcm91cC5hZGRUbyhtYXApO1xuXHRcdFx0dGhpcy5fbm9uUG9pbnRHcm91cC5hZGRUbyhtYXApO1xuXG5cdFx0XHRpZiAoIXRoaXMuX2dyaWRDbHVzdGVycykge1xuXHRcdFx0XHR0aGlzLl9nZW5lcmF0ZUluaXRpYWxDbHVzdGVycygpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9tYXhMYXQgPSBtYXAub3B0aW9ucy5jcnMucHJvamVjdGlvbi5NQVhfTEFUSVRVREU7XG5cblx0XHRcdC8vUmVzdG9yZSBhbGwgdGhlIHBvc2l0aW9ucyBhcyB0aGV5IGFyZSBpbiB0aGUgTUNHIGJlZm9yZSByZW1vdmluZyB0aGVtXG5cdFx0XHRmb3IgKGkgPSAwLCBsID0gdGhpcy5fbmVlZHNSZW1vdmluZy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0bGF5ZXIgPSB0aGlzLl9uZWVkc1JlbW92aW5nW2ldO1xuXHRcdFx0XHRsYXllci5uZXdsYXRsbmcgPSBsYXllci5sYXllci5fbGF0bG5nO1xuXHRcdFx0XHRsYXllci5sYXllci5fbGF0bG5nID0gbGF5ZXIubGF0bG5nO1xuXHRcdFx0fVxuXHRcdFx0Ly9SZW1vdmUgdGhlbSwgdGhlbiByZXN0b3JlIHRoZWlyIG5ldyBwb3NpdGlvbnNcblx0XHRcdGZvciAoaSA9IDAsIGwgPSB0aGlzLl9uZWVkc1JlbW92aW5nLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRsYXllciA9IHRoaXMuX25lZWRzUmVtb3ZpbmdbaV07XG5cdFx0XHRcdHRoaXMuX3JlbW92ZUxheWVyKGxheWVyLmxheWVyLCB0cnVlKTtcblx0XHRcdFx0bGF5ZXIubGF5ZXIuX2xhdGxuZyA9IGxheWVyLm5ld2xhdGxuZztcblx0XHRcdH1cblx0XHRcdHRoaXMuX25lZWRzUmVtb3ZpbmcgPSBbXTtcblxuXHRcdFx0Ly9SZW1lbWJlciB0aGUgY3VycmVudCB6b29tIGxldmVsIGFuZCBib3VuZHNcblx0XHRcdHRoaXMuX3pvb20gPSBNYXRoLnJvdW5kKHRoaXMuX21hcC5fem9vbSk7XG5cdFx0XHR0aGlzLl9jdXJyZW50U2hvd25Cb3VuZHMgPSB0aGlzLl9nZXRFeHBhbmRlZFZpc2libGVCb3VuZHMoKTtcblxuXHRcdFx0dGhpcy5fbWFwLm9uKCd6b29tZW5kJywgdGhpcy5fem9vbUVuZCwgdGhpcyk7XG5cdFx0XHR0aGlzLl9tYXAub24oJ21vdmVlbmQnLCB0aGlzLl9tb3ZlRW5kLCB0aGlzKTtcblxuXHRcdFx0aWYgKHRoaXMuX3NwaWRlcmZpZXJPbkFkZCkgeyAvL1RPRE8gRklYTUU6IE5vdCBzdXJlIGhvdyB0byBoYXZlIHNwaWRlcmZpZXIgYWRkIHNvbWV0aGluZyBvbiBoZXJlIG5pY2VseVxuXHRcdFx0XHR0aGlzLl9zcGlkZXJmaWVyT25BZGQoKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fYmluZEV2ZW50cygpO1xuXG5cdFx0XHQvL0FjdHVhbGx5IGFkZCBvdXIgbWFya2VycyB0byB0aGUgbWFwOlxuXHRcdFx0bCA9IHRoaXMuX25lZWRzQ2x1c3RlcmluZztcblx0XHRcdHRoaXMuX25lZWRzQ2x1c3RlcmluZyA9IFtdO1xuXHRcdFx0dGhpcy5hZGRMYXllcnMobCwgdHJ1ZSk7XG5cdFx0fSxcblxuXHRcdC8vT3ZlcnJpZGVzIEZlYXR1cmVHcm91cC5vblJlbW92ZVxuXHRcdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0XHRtYXAub2ZmKCd6b29tZW5kJywgdGhpcy5fem9vbUVuZCwgdGhpcyk7XG5cdFx0XHRtYXAub2ZmKCdtb3ZlZW5kJywgdGhpcy5fbW92ZUVuZCwgdGhpcyk7XG5cblx0XHRcdHRoaXMuX3VuYmluZEV2ZW50cygpO1xuXG5cdFx0XHQvL0luIGNhc2Ugd2UgYXJlIGluIGEgY2x1c3RlciBhbmltYXRpb25cblx0XHRcdHRoaXMuX21hcC5fbWFwUGFuZS5jbGFzc05hbWUgPSB0aGlzLl9tYXAuX21hcFBhbmUuY2xhc3NOYW1lLnJlcGxhY2UoJyBsZWFmbGV0LWNsdXN0ZXItYW5pbScsICcnKTtcblxuXHRcdFx0aWYgKHRoaXMuX3NwaWRlcmZpZXJPblJlbW92ZSkgeyAvL1RPRE8gRklYTUU6IE5vdCBzdXJlIGhvdyB0byBoYXZlIHNwaWRlcmZpZXIgYWRkIHNvbWV0aGluZyBvbiBoZXJlIG5pY2VseVxuXHRcdFx0XHR0aGlzLl9zcGlkZXJmaWVyT25SZW1vdmUoKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVsZXRlIHRoaXMuX21heExhdDtcblxuXHRcdFx0Ly9DbGVhbiB1cCBhbGwgdGhlIGxheWVycyB3ZSBhZGRlZCB0byB0aGUgbWFwXG5cdFx0XHR0aGlzLl9oaWRlQ292ZXJhZ2UoKTtcblx0XHRcdHRoaXMuX2ZlYXR1cmVHcm91cC5yZW1vdmUoKTtcblx0XHRcdHRoaXMuX25vblBvaW50R3JvdXAucmVtb3ZlKCk7XG5cblx0XHRcdHRoaXMuX2ZlYXR1cmVHcm91cC5jbGVhckxheWVycygpO1xuXG5cdFx0XHR0aGlzLl9tYXAgPSBudWxsO1xuXHRcdH0sXG5cblx0XHRnZXRWaXNpYmxlUGFyZW50OiBmdW5jdGlvbiAobWFya2VyKSB7XG5cdFx0XHR2YXIgdk1hcmtlciA9IG1hcmtlcjtcblx0XHRcdHdoaWxlICh2TWFya2VyICYmICF2TWFya2VyLl9pY29uKSB7XG5cdFx0XHRcdHZNYXJrZXIgPSB2TWFya2VyLl9fcGFyZW50O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHZNYXJrZXIgfHwgbnVsbDtcblx0XHR9LFxuXG5cdFx0Ly9SZW1vdmUgdGhlIGdpdmVuIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBhcnJheVxuXHRcdF9hcnJheVNwbGljZTogZnVuY3Rpb24gKGFuQXJyYXksIG9iaikge1xuXHRcdFx0Zm9yICh2YXIgaSA9IGFuQXJyYXkubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0aWYgKGFuQXJyYXlbaV0gPT09IG9iaikge1xuXHRcdFx0XHRcdGFuQXJyYXkuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJlbW92ZXMgYSBtYXJrZXIgZnJvbSBhbGwgX2dyaWRVbmNsdXN0ZXJlZCB6b29tIGxldmVscywgc3RhcnRpbmcgYXQgdGhlIHN1cHBsaWVkIHpvb20uXG5cdFx0ICogQHBhcmFtIG1hcmtlciB0byBiZSByZW1vdmVkIGZyb20gX2dyaWRVbmNsdXN0ZXJlZC5cblx0XHQgKiBAcGFyYW0geiBpbnRlZ2VyIGJvdHRvbSBzdGFydCB6b29tIGxldmVsIChpbmNsdWRlZClcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdF9yZW1vdmVGcm9tR3JpZFVuY2x1c3RlcmVkOiBmdW5jdGlvbiAobWFya2VyLCB6KSB7XG5cdFx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdFx0ICAgIGdyaWRVbmNsdXN0ZXJlZCA9IHRoaXMuX2dyaWRVbmNsdXN0ZXJlZCxcblx0XHRcdFx0bWluWm9vbSA9IE1hdGguZmxvb3IodGhpcy5fbWFwLmdldE1pblpvb20oKSk7XG5cblx0XHRcdGZvciAoOyB6ID49IG1pblpvb207IHotLSkge1xuXHRcdFx0XHRpZiAoIWdyaWRVbmNsdXN0ZXJlZFt6XS5yZW1vdmVPYmplY3QobWFya2VyLCBtYXAucHJvamVjdChtYXJrZXIuZ2V0TGF0TG5nKCksIHopKSkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdF9jaGlsZE1hcmtlckRyYWdTdGFydDogZnVuY3Rpb24gKGUpIHtcblx0XHRcdGUudGFyZ2V0Ll9fZHJhZ1N0YXJ0ID0gZS50YXJnZXQuX2xhdGxuZztcblx0XHR9LFxuXG5cdFx0X2NoaWxkTWFya2VyTW92ZWQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRpZiAoIXRoaXMuX2lnbm9yZU1vdmUgJiYgIWUudGFyZ2V0Ll9fZHJhZ1N0YXJ0KSB7XG5cdFx0XHRcdHZhciBpc1BvcHVwT3BlbiA9IGUudGFyZ2V0Ll9wb3B1cCAmJiBlLnRhcmdldC5fcG9wdXAuaXNPcGVuKCk7XG5cblx0XHRcdFx0dGhpcy5fbW92ZUNoaWxkKGUudGFyZ2V0LCBlLm9sZExhdExuZywgZS5sYXRsbmcpO1xuXG5cdFx0XHRcdGlmIChpc1BvcHVwT3Blbikge1xuXHRcdFx0XHRcdGUudGFyZ2V0Lm9wZW5Qb3B1cCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdF9tb3ZlQ2hpbGQ6IGZ1bmN0aW9uIChsYXllciwgZnJvbSwgdG8pIHtcblx0XHRcdGxheWVyLl9sYXRsbmcgPSBmcm9tO1xuXHRcdFx0dGhpcy5yZW1vdmVMYXllcihsYXllcik7XG5cblx0XHRcdGxheWVyLl9sYXRsbmcgPSB0bztcblx0XHRcdHRoaXMuYWRkTGF5ZXIobGF5ZXIpO1xuXHRcdH0sXG5cblx0XHRfY2hpbGRNYXJrZXJEcmFnRW5kOiBmdW5jdGlvbiAoZSkge1xuXHRcdFx0dmFyIGRyYWdTdGFydCA9IGUudGFyZ2V0Ll9fZHJhZ1N0YXJ0O1xuXHRcdFx0ZGVsZXRlIGUudGFyZ2V0Ll9fZHJhZ1N0YXJ0O1xuXHRcdFx0aWYgKGRyYWdTdGFydCkge1xuXHRcdFx0XHR0aGlzLl9tb3ZlQ2hpbGQoZS50YXJnZXQsIGRyYWdTdGFydCwgZS50YXJnZXQuX2xhdGxuZyk7XG5cdFx0XHR9XHRcdFxuXHRcdH0sXG5cblxuXHRcdC8vSW50ZXJuYWwgZnVuY3Rpb24gZm9yIHJlbW92aW5nIGEgbWFya2VyIGZyb20gZXZlcnl0aGluZy5cblx0XHQvL2RvbnRVcGRhdGVNYXA6IHNldCB0byB0cnVlIGlmIHlvdSB3aWxsIGhhbmRsZSB1cGRhdGluZyB0aGUgbWFwIG1hbnVhbGx5IChmb3IgYnVsayBmdW5jdGlvbnMpXG5cdFx0X3JlbW92ZUxheWVyOiBmdW5jdGlvbiAobWFya2VyLCByZW1vdmVGcm9tRGlzdGFuY2VHcmlkLCBkb250VXBkYXRlTWFwKSB7XG5cdFx0XHR2YXIgZ3JpZENsdXN0ZXJzID0gdGhpcy5fZ3JpZENsdXN0ZXJzLFxuXHRcdFx0XHRncmlkVW5jbHVzdGVyZWQgPSB0aGlzLl9ncmlkVW5jbHVzdGVyZWQsXG5cdFx0XHRcdGZnID0gdGhpcy5fZmVhdHVyZUdyb3VwLFxuXHRcdFx0XHRtYXAgPSB0aGlzLl9tYXAsXG5cdFx0XHRcdG1pblpvb20gPSBNYXRoLmZsb29yKHRoaXMuX21hcC5nZXRNaW5ab29tKCkpO1xuXG5cdFx0XHQvL1JlbW92ZSB0aGUgbWFya2VyIGZyb20gZGlzdGFuY2UgY2x1c3RlcnMgaXQgbWlnaHQgYmUgaW5cblx0XHRcdGlmIChyZW1vdmVGcm9tRGlzdGFuY2VHcmlkKSB7XG5cdFx0XHRcdHRoaXMuX3JlbW92ZUZyb21HcmlkVW5jbHVzdGVyZWQobWFya2VyLCB0aGlzLl9tYXhab29tKTtcblx0XHRcdH1cblxuXHRcdFx0Ly9Xb3JrIG91ciB3YXkgdXAgdGhlIGNsdXN0ZXJzIHJlbW92aW5nIHRoZW0gYXMgd2UgZ28gaWYgcmVxdWlyZWRcblx0XHRcdHZhciBjbHVzdGVyID0gbWFya2VyLl9fcGFyZW50LFxuXHRcdFx0XHRtYXJrZXJzID0gY2x1c3Rlci5fbWFya2Vycyxcblx0XHRcdFx0b3RoZXJNYXJrZXI7XG5cblx0XHRcdC8vUmVtb3ZlIHRoZSBtYXJrZXIgZnJvbSB0aGUgaW1tZWRpYXRlIHBhcmVudHMgbWFya2VyIGxpc3Rcblx0XHRcdHRoaXMuX2FycmF5U3BsaWNlKG1hcmtlcnMsIG1hcmtlcik7XG5cblx0XHRcdHdoaWxlIChjbHVzdGVyKSB7XG5cdFx0XHRcdGNsdXN0ZXIuX2NoaWxkQ291bnQtLTtcblx0XHRcdFx0Y2x1c3Rlci5fYm91bmRzTmVlZFVwZGF0ZSA9IHRydWU7XG5cblx0XHRcdFx0aWYgKGNsdXN0ZXIuX3pvb20gPCBtaW5ab29tKSB7XG5cdFx0XHRcdFx0Ly9Ub3AgbGV2ZWwsIGRvIG5vdGhpbmdcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fSBlbHNlIGlmIChyZW1vdmVGcm9tRGlzdGFuY2VHcmlkICYmIGNsdXN0ZXIuX2NoaWxkQ291bnQgPD0gMSkgeyAvL0NsdXN0ZXIgbm8gbG9uZ2VyIHJlcXVpcmVkXG5cdFx0XHRcdFx0Ly9XZSBuZWVkIHRvIHB1c2ggdGhlIG90aGVyIG1hcmtlciB1cCB0byB0aGUgcGFyZW50XG5cdFx0XHRcdFx0b3RoZXJNYXJrZXIgPSBjbHVzdGVyLl9tYXJrZXJzWzBdID09PSBtYXJrZXIgPyBjbHVzdGVyLl9tYXJrZXJzWzFdIDogY2x1c3Rlci5fbWFya2Vyc1swXTtcblxuXHRcdFx0XHRcdC8vVXBkYXRlIGRpc3RhbmNlIGdyaWRcblx0XHRcdFx0XHRncmlkQ2x1c3RlcnNbY2x1c3Rlci5fem9vbV0ucmVtb3ZlT2JqZWN0KGNsdXN0ZXIsIG1hcC5wcm9qZWN0KGNsdXN0ZXIuX2NMYXRMbmcsIGNsdXN0ZXIuX3pvb20pKTtcblx0XHRcdFx0XHRncmlkVW5jbHVzdGVyZWRbY2x1c3Rlci5fem9vbV0uYWRkT2JqZWN0KG90aGVyTWFya2VyLCBtYXAucHJvamVjdChvdGhlck1hcmtlci5nZXRMYXRMbmcoKSwgY2x1c3Rlci5fem9vbSkpO1xuXG5cdFx0XHRcdFx0Ly9Nb3ZlIG90aGVyTWFya2VyIHVwIHRvIHBhcmVudFxuXHRcdFx0XHRcdHRoaXMuX2FycmF5U3BsaWNlKGNsdXN0ZXIuX19wYXJlbnQuX2NoaWxkQ2x1c3RlcnMsIGNsdXN0ZXIpO1xuXHRcdFx0XHRcdGNsdXN0ZXIuX19wYXJlbnQuX21hcmtlcnMucHVzaChvdGhlck1hcmtlcik7XG5cdFx0XHRcdFx0b3RoZXJNYXJrZXIuX19wYXJlbnQgPSBjbHVzdGVyLl9fcGFyZW50O1xuXG5cdFx0XHRcdFx0aWYgKGNsdXN0ZXIuX2ljb24pIHtcblx0XHRcdFx0XHRcdC8vQ2x1c3RlciBpcyBjdXJyZW50bHkgb24gdGhlIG1hcCwgbmVlZCB0byBwdXQgdGhlIG1hcmtlciBvbiB0aGUgbWFwIGluc3RlYWRcblx0XHRcdFx0XHRcdGZnLnJlbW92ZUxheWVyKGNsdXN0ZXIpO1xuXHRcdFx0XHRcdFx0aWYgKCFkb250VXBkYXRlTWFwKSB7XG5cdFx0XHRcdFx0XHRcdGZnLmFkZExheWVyKG90aGVyTWFya2VyKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y2x1c3Rlci5faWNvbk5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNsdXN0ZXIgPSBjbHVzdGVyLl9fcGFyZW50O1xuXHRcdFx0fVxuXG5cdFx0XHRkZWxldGUgbWFya2VyLl9fcGFyZW50O1xuXHRcdH0sXG5cblx0XHRfaXNPcklzUGFyZW50OiBmdW5jdGlvbiAoZWwsIG9lbCkge1xuXHRcdFx0d2hpbGUgKG9lbCkge1xuXHRcdFx0XHRpZiAoZWwgPT09IG9lbCkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG9lbCA9IG9lbC5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0sXG5cblx0XHQvL092ZXJyaWRlIEwuRXZlbnRlZC5maXJlXG5cdFx0ZmlyZTogZnVuY3Rpb24gKHR5cGUsIGRhdGEsIHByb3BhZ2F0ZSkge1xuXHRcdFx0aWYgKGRhdGEgJiYgZGF0YS5sYXllciBpbnN0YW5jZW9mIEwuTWFya2VyQ2x1c3Rlcikge1xuXHRcdFx0XHQvL1ByZXZlbnQgbXVsdGlwbGUgY2x1c3Rlcm1vdXNlb3Zlci9vZmYgZXZlbnRzIGlmIHRoZSBpY29uIGlzIG1hZGUgdXAgb2Ygc3RhY2tlZCBkaXZzIChEb2Vzbid0IHdvcmsgaW4gaWUgPD0gOCwgbm8gcmVsYXRlZFRhcmdldClcblx0XHRcdFx0aWYgKGRhdGEub3JpZ2luYWxFdmVudCAmJiB0aGlzLl9pc09ySXNQYXJlbnQoZGF0YS5sYXllci5faWNvbiwgZGF0YS5vcmlnaW5hbEV2ZW50LnJlbGF0ZWRUYXJnZXQpKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHR5cGUgPSAnY2x1c3RlcicgKyB0eXBlO1xuXHRcdFx0fVxuXG5cdFx0XHRMLkZlYXR1cmVHcm91cC5wcm90b3R5cGUuZmlyZS5jYWxsKHRoaXMsIHR5cGUsIGRhdGEsIHByb3BhZ2F0ZSk7XG5cdFx0fSxcblxuXHRcdC8vT3ZlcnJpZGUgTC5FdmVudGVkLmxpc3RlbnNcblx0XHRsaXN0ZW5zOiBmdW5jdGlvbiAodHlwZSwgcHJvcGFnYXRlKSB7XG5cdFx0XHRyZXR1cm4gTC5GZWF0dXJlR3JvdXAucHJvdG90eXBlLmxpc3RlbnMuY2FsbCh0aGlzLCB0eXBlLCBwcm9wYWdhdGUpIHx8IEwuRmVhdHVyZUdyb3VwLnByb3RvdHlwZS5saXN0ZW5zLmNhbGwodGhpcywgJ2NsdXN0ZXInICsgdHlwZSwgcHJvcGFnYXRlKTtcblx0XHR9LFxuXG5cdFx0Ly9EZWZhdWx0IGZ1bmN0aW9uYWxpdHlcblx0XHRfZGVmYXVsdEljb25DcmVhdGVGdW5jdGlvbjogZnVuY3Rpb24gKGNsdXN0ZXIpIHtcblx0XHRcdHZhciBjaGlsZENvdW50ID0gY2x1c3Rlci5nZXRDaGlsZENvdW50KCk7XG5cblx0XHRcdHZhciBjID0gJyBtYXJrZXItY2x1c3Rlci0nO1xuXHRcdFx0aWYgKGNoaWxkQ291bnQgPCAxMCkge1xuXHRcdFx0XHRjICs9ICdzbWFsbCc7XG5cdFx0XHR9IGVsc2UgaWYgKGNoaWxkQ291bnQgPCAxMDApIHtcblx0XHRcdFx0YyArPSAnbWVkaXVtJztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGMgKz0gJ2xhcmdlJztcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG5ldyBMLkRpdkljb24oeyBodG1sOiAnPGRpdj48c3Bhbj4nICsgY2hpbGRDb3VudCArICc8L3NwYW4+PC9kaXY+JywgY2xhc3NOYW1lOiAnbWFya2VyLWNsdXN0ZXInICsgYywgaWNvblNpemU6IG5ldyBMLlBvaW50KDQwLCA0MCkgfSk7XG5cdFx0fSxcblxuXHRcdF9iaW5kRXZlbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdFx0ICAgIHNwaWRlcmZ5T25NYXhab29tID0gdGhpcy5vcHRpb25zLnNwaWRlcmZ5T25NYXhab29tLFxuXHRcdFx0ICAgIHNob3dDb3ZlcmFnZU9uSG92ZXIgPSB0aGlzLm9wdGlvbnMuc2hvd0NvdmVyYWdlT25Ib3Zlcixcblx0XHRcdCAgICB6b29tVG9Cb3VuZHNPbkNsaWNrID0gdGhpcy5vcHRpb25zLnpvb21Ub0JvdW5kc09uQ2xpY2ssXG5cdFx0XHQgICAgc3BpZGVyZnlPbkV2ZXJ5Wm9vbSA9IHRoaXMub3B0aW9ucy5zcGlkZXJmeU9uRXZlcnlab29tO1xuXG5cdFx0XHQvL1pvb20gb24gY2x1c3RlciBjbGljayBvciBzcGlkZXJmeSBpZiB3ZSBhcmUgYXQgdGhlIGxvd2VzdCBsZXZlbFxuXHRcdFx0aWYgKHNwaWRlcmZ5T25NYXhab29tIHx8IHpvb21Ub0JvdW5kc09uQ2xpY2sgfHwgc3BpZGVyZnlPbkV2ZXJ5Wm9vbSkge1xuXHRcdFx0XHR0aGlzLm9uKCdjbHVzdGVyY2xpY2sgY2x1c3RlcmtleXByZXNzJywgdGhpcy5fem9vbU9yU3BpZGVyZnksIHRoaXMpO1xuXHRcdFx0fVxuXG5cdFx0XHQvL1Nob3cgY29udmV4IGh1bGwgKGJvdW5kYXJ5KSBwb2x5Z29uIG9uIG1vdXNlIG92ZXJcblx0XHRcdGlmIChzaG93Q292ZXJhZ2VPbkhvdmVyKSB7XG5cdFx0XHRcdHRoaXMub24oJ2NsdXN0ZXJtb3VzZW92ZXInLCB0aGlzLl9zaG93Q292ZXJhZ2UsIHRoaXMpO1xuXHRcdFx0XHR0aGlzLm9uKCdjbHVzdGVybW91c2VvdXQnLCB0aGlzLl9oaWRlQ292ZXJhZ2UsIHRoaXMpO1xuXHRcdFx0XHRtYXAub24oJ3pvb21lbmQnLCB0aGlzLl9oaWRlQ292ZXJhZ2UsIHRoaXMpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRfem9vbU9yU3BpZGVyZnk6IGZ1bmN0aW9uIChlKSB7XG5cdFx0XHR2YXIgY2x1c3RlciA9IGUubGF5ZXIsXG5cdFx0XHQgICAgYm90dG9tQ2x1c3RlciA9IGNsdXN0ZXI7XG5cblx0XHRcdGlmIChlLnR5cGUgPT09ICdjbHVzdGVya2V5cHJlc3MnICYmIGUub3JpZ2luYWxFdmVudCAmJiBlLm9yaWdpbmFsRXZlbnQua2V5Q29kZSAhPT0gMTMpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR3aGlsZSAoYm90dG9tQ2x1c3Rlci5fY2hpbGRDbHVzdGVycy5sZW5ndGggPT09IDEpIHtcblx0XHRcdFx0Ym90dG9tQ2x1c3RlciA9IGJvdHRvbUNsdXN0ZXIuX2NoaWxkQ2x1c3RlcnNbMF07XG5cdFx0XHR9XG5cblx0XHRcdGlmIChib3R0b21DbHVzdGVyLl96b29tID09PSB0aGlzLl9tYXhab29tICYmXG5cdFx0XHRcdGJvdHRvbUNsdXN0ZXIuX2NoaWxkQ291bnQgPT09IGNsdXN0ZXIuX2NoaWxkQ291bnQgJiZcblx0XHRcdFx0dGhpcy5vcHRpb25zLnNwaWRlcmZ5T25NYXhab29tKSB7XG5cblx0XHRcdFx0Ly8gQWxsIGNoaWxkIG1hcmtlcnMgYXJlIGNvbnRhaW5lZCBpbiBhIHNpbmdsZSBjbHVzdGVyIGZyb20gdGhpcy5fbWF4Wm9vbSB0byB0aGlzIGNsdXN0ZXIuXG5cdFx0XHRcdGNsdXN0ZXIuc3BpZGVyZnkoKTtcblx0XHRcdH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLnpvb21Ub0JvdW5kc09uQ2xpY2spIHtcblx0XHRcdFx0Y2x1c3Rlci56b29tVG9Cb3VuZHMoKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMub3B0aW9ucy5zcGlkZXJmeU9uRXZlcnlab29tKSB7XG5cdFx0XHRcdGNsdXN0ZXIuc3BpZGVyZnkoKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRm9jdXMgdGhlIG1hcCBhZ2FpbiBmb3Iga2V5Ym9hcmQgdXNlcnMuXG5cdFx0XHRpZiAoZS5vcmlnaW5hbEV2ZW50ICYmIGUub3JpZ2luYWxFdmVudC5rZXlDb2RlID09PSAxMykge1xuXHRcdFx0XHR0aGlzLl9tYXAuX2NvbnRhaW5lci5mb2N1cygpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRfc2hvd0NvdmVyYWdlOiBmdW5jdGlvbiAoZSkge1xuXHRcdFx0dmFyIG1hcCA9IHRoaXMuX21hcDtcblx0XHRcdGlmICh0aGlzLl9pblpvb21BbmltYXRpb24pIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuX3Nob3duUG9seWdvbikge1xuXHRcdFx0XHRtYXAucmVtb3ZlTGF5ZXIodGhpcy5fc2hvd25Qb2x5Z29uKTtcblx0XHRcdH1cblx0XHRcdGlmIChlLmxheWVyLmdldENoaWxkQ291bnQoKSA+IDIgJiYgZS5sYXllciAhPT0gdGhpcy5fc3BpZGVyZmllZCkge1xuXHRcdFx0XHR0aGlzLl9zaG93blBvbHlnb24gPSBuZXcgTC5Qb2x5Z29uKGUubGF5ZXIuZ2V0Q29udmV4SHVsbCgpLCB0aGlzLm9wdGlvbnMucG9seWdvbk9wdGlvbnMpO1xuXHRcdFx0XHRtYXAuYWRkTGF5ZXIodGhpcy5fc2hvd25Qb2x5Z29uKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0X2hpZGVDb3ZlcmFnZTogZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKHRoaXMuX3Nob3duUG9seWdvbikge1xuXHRcdFx0XHR0aGlzLl9tYXAucmVtb3ZlTGF5ZXIodGhpcy5fc2hvd25Qb2x5Z29uKTtcblx0XHRcdFx0dGhpcy5fc2hvd25Qb2x5Z29uID0gbnVsbDtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0X3VuYmluZEV2ZW50czogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIHNwaWRlcmZ5T25NYXhab29tID0gdGhpcy5vcHRpb25zLnNwaWRlcmZ5T25NYXhab29tLFxuXHRcdFx0XHRzaG93Q292ZXJhZ2VPbkhvdmVyID0gdGhpcy5vcHRpb25zLnNob3dDb3ZlcmFnZU9uSG92ZXIsXG5cdFx0XHRcdHpvb21Ub0JvdW5kc09uQ2xpY2sgPSB0aGlzLm9wdGlvbnMuem9vbVRvQm91bmRzT25DbGljayxcblx0XHRcdFx0c3BpZGVyZnlPbkV2ZXJ5Wm9vbSA9IHRoaXMub3B0aW9ucy5zcGlkZXJmeU9uRXZlcnlab29tLFxuXHRcdFx0XHRtYXAgPSB0aGlzLl9tYXA7XG5cblx0XHRcdGlmIChzcGlkZXJmeU9uTWF4Wm9vbSB8fCB6b29tVG9Cb3VuZHNPbkNsaWNrIHx8IHNwaWRlcmZ5T25FdmVyeVpvb20pIHtcblx0XHRcdFx0dGhpcy5vZmYoJ2NsdXN0ZXJjbGljayBjbHVzdGVya2V5cHJlc3MnLCB0aGlzLl96b29tT3JTcGlkZXJmeSwgdGhpcyk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoc2hvd0NvdmVyYWdlT25Ib3Zlcikge1xuXHRcdFx0XHR0aGlzLm9mZignY2x1c3Rlcm1vdXNlb3ZlcicsIHRoaXMuX3Nob3dDb3ZlcmFnZSwgdGhpcyk7XG5cdFx0XHRcdHRoaXMub2ZmKCdjbHVzdGVybW91c2VvdXQnLCB0aGlzLl9oaWRlQ292ZXJhZ2UsIHRoaXMpO1xuXHRcdFx0XHRtYXAub2ZmKCd6b29tZW5kJywgdGhpcy5faGlkZUNvdmVyYWdlLCB0aGlzKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0X3pvb21FbmQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmICghdGhpcy5fbWFwKSB7IC8vTWF5IGhhdmUgYmVlbiByZW1vdmVkIGZyb20gdGhlIG1hcCBieSBhIHpvb21FbmQgaGFuZGxlclxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9tZXJnZVNwbGl0Q2x1c3RlcnMoKTtcblxuXHRcdFx0dGhpcy5fem9vbSA9IE1hdGgucm91bmQodGhpcy5fbWFwLl96b29tKTtcblx0XHRcdHRoaXMuX2N1cnJlbnRTaG93bkJvdW5kcyA9IHRoaXMuX2dldEV4cGFuZGVkVmlzaWJsZUJvdW5kcygpO1xuXHRcdH0sXG5cblx0XHRfbW92ZUVuZDogZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKHRoaXMuX2luWm9vbUFuaW1hdGlvbikge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHZhciBuZXdCb3VuZHMgPSB0aGlzLl9nZXRFeHBhbmRlZFZpc2libGVCb3VuZHMoKTtcblxuXHRcdFx0dGhpcy5fdG9wQ2x1c3RlckxldmVsLl9yZWN1cnNpdmVseVJlbW92ZUNoaWxkcmVuRnJvbU1hcCh0aGlzLl9jdXJyZW50U2hvd25Cb3VuZHMsIE1hdGguZmxvb3IodGhpcy5fbWFwLmdldE1pblpvb20oKSksIHRoaXMuX3pvb20sIG5ld0JvdW5kcyk7XG5cdFx0XHR0aGlzLl90b3BDbHVzdGVyTGV2ZWwuX3JlY3Vyc2l2ZWx5QWRkQ2hpbGRyZW5Ub01hcChudWxsLCBNYXRoLnJvdW5kKHRoaXMuX21hcC5fem9vbSksIG5ld0JvdW5kcyk7XG5cblx0XHRcdHRoaXMuX2N1cnJlbnRTaG93bkJvdW5kcyA9IG5ld0JvdW5kcztcblx0XHRcdHJldHVybjtcblx0XHR9LFxuXG5cdFx0X2dlbmVyYXRlSW5pdGlhbENsdXN0ZXJzOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgbWF4Wm9vbSA9IE1hdGguY2VpbCh0aGlzLl9tYXAuZ2V0TWF4Wm9vbSgpKSxcblx0XHRcdFx0bWluWm9vbSA9IE1hdGguZmxvb3IodGhpcy5fbWFwLmdldE1pblpvb20oKSksXG5cdFx0XHRcdHJhZGl1cyA9IHRoaXMub3B0aW9ucy5tYXhDbHVzdGVyUmFkaXVzLFxuXHRcdFx0XHRyYWRpdXNGbiA9IHJhZGl1cztcblxuXHRcdFx0Ly9JZiB3ZSBqdXN0IHNldCBtYXhDbHVzdGVyUmFkaXVzIHRvIGEgc2luZ2xlIG51bWJlciwgd2UgbmVlZCB0byBjcmVhdGVcblx0XHRcdC8vYSBzaW1wbGUgZnVuY3Rpb24gdG8gcmV0dXJuIHRoYXQgbnVtYmVyLiBPdGhlcndpc2UsIHdlIGp1c3QgaGF2ZSB0b1xuXHRcdFx0Ly91c2UgdGhlIGZ1bmN0aW9uIHdlJ3ZlIHBhc3NlZCBpbi5cblx0XHRcdGlmICh0eXBlb2YgcmFkaXVzICE9PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0cmFkaXVzRm4gPSBmdW5jdGlvbiAoKSB7IHJldHVybiByYWRpdXM7IH07XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGlzLm9wdGlvbnMuZGlzYWJsZUNsdXN0ZXJpbmdBdFpvb20gIT09IG51bGwpIHtcblx0XHRcdFx0bWF4Wm9vbSA9IHRoaXMub3B0aW9ucy5kaXNhYmxlQ2x1c3RlcmluZ0F0Wm9vbSAtIDE7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9tYXhab29tID0gbWF4Wm9vbTtcblx0XHRcdHRoaXMuX2dyaWRDbHVzdGVycyA9IHt9O1xuXHRcdFx0dGhpcy5fZ3JpZFVuY2x1c3RlcmVkID0ge307XG5cblx0XHRcdC8vU2V0IHVwIERpc3RhbmNlR3JpZHMgZm9yIGVhY2ggem9vbVxuXHRcdFx0Zm9yICh2YXIgem9vbSA9IG1heFpvb207IHpvb20gPj0gbWluWm9vbTsgem9vbS0tKSB7XG5cdFx0XHRcdHRoaXMuX2dyaWRDbHVzdGVyc1t6b29tXSA9IG5ldyBMLkRpc3RhbmNlR3JpZChyYWRpdXNGbih6b29tKSk7XG5cdFx0XHRcdHRoaXMuX2dyaWRVbmNsdXN0ZXJlZFt6b29tXSA9IG5ldyBMLkRpc3RhbmNlR3JpZChyYWRpdXNGbih6b29tKSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEluc3RhbnRpYXRlIHRoZSBhcHByb3ByaWF0ZSBMLk1hcmtlckNsdXN0ZXIgY2xhc3MgKGFuaW1hdGVkIG9yIG5vdCkuXG5cdFx0XHR0aGlzLl90b3BDbHVzdGVyTGV2ZWwgPSBuZXcgdGhpcy5fbWFya2VyQ2x1c3Rlcih0aGlzLCBtaW5ab29tIC0gMSk7XG5cdFx0fSxcblxuXHRcdC8vWm9vbTogWm9vbSB0byBzdGFydCBhZGRpbmcgYXQgKFBhc3MgdGhpcy5fbWF4Wm9vbSB0byBzdGFydCBhdCB0aGUgYm90dG9tKVxuXHRcdF9hZGRMYXllcjogZnVuY3Rpb24gKGxheWVyLCB6b29tKSB7XG5cdFx0XHR2YXIgZ3JpZENsdXN0ZXJzID0gdGhpcy5fZ3JpZENsdXN0ZXJzLFxuXHRcdFx0ICAgIGdyaWRVbmNsdXN0ZXJlZCA9IHRoaXMuX2dyaWRVbmNsdXN0ZXJlZCxcblx0XHRcdFx0bWluWm9vbSA9IE1hdGguZmxvb3IodGhpcy5fbWFwLmdldE1pblpvb20oKSksXG5cdFx0XHQgICAgbWFya2VyUG9pbnQsIHo7XG5cblx0XHRcdGlmICh0aGlzLm9wdGlvbnMuc2luZ2xlTWFya2VyTW9kZSkge1xuXHRcdFx0XHR0aGlzLl9vdmVycmlkZU1hcmtlckljb24obGF5ZXIpO1xuXHRcdFx0fVxuXG5cdFx0XHRsYXllci5vbih0aGlzLl9jaGlsZE1hcmtlckV2ZW50SGFuZGxlcnMsIHRoaXMpO1xuXG5cdFx0XHQvL0ZpbmQgdGhlIGxvd2VzdCB6b29tIGxldmVsIHRvIHNsb3QgdGhpcyBvbmUgaW5cblx0XHRcdGZvciAoOyB6b29tID49IG1pblpvb207IHpvb20tLSkge1xuXHRcdFx0XHRtYXJrZXJQb2ludCA9IHRoaXMuX21hcC5wcm9qZWN0KGxheWVyLmdldExhdExuZygpLCB6b29tKTsgLy8gY2FsY3VsYXRlIHBpeGVsIHBvc2l0aW9uXG5cblx0XHRcdFx0Ly9UcnkgZmluZCBhIGNsdXN0ZXIgY2xvc2UgYnlcblx0XHRcdFx0dmFyIGNsb3Nlc3QgPSBncmlkQ2x1c3RlcnNbem9vbV0uZ2V0TmVhck9iamVjdChtYXJrZXJQb2ludCk7XG5cdFx0XHRcdGlmIChjbG9zZXN0KSB7XG5cdFx0XHRcdFx0Y2xvc2VzdC5fYWRkQ2hpbGQobGF5ZXIpO1xuXHRcdFx0XHRcdGxheWVyLl9fcGFyZW50ID0gY2xvc2VzdDtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvL1RyeSBmaW5kIGEgbWFya2VyIGNsb3NlIGJ5IHRvIGZvcm0gYSBuZXcgY2x1c3RlciB3aXRoXG5cdFx0XHRcdGNsb3Nlc3QgPSBncmlkVW5jbHVzdGVyZWRbem9vbV0uZ2V0TmVhck9iamVjdChtYXJrZXJQb2ludCk7XG5cdFx0XHRcdGlmIChjbG9zZXN0KSB7XG5cdFx0XHRcdFx0dmFyIHBhcmVudCA9IGNsb3Nlc3QuX19wYXJlbnQ7XG5cdFx0XHRcdFx0aWYgKHBhcmVudCkge1xuXHRcdFx0XHRcdFx0dGhpcy5fcmVtb3ZlTGF5ZXIoY2xvc2VzdCwgZmFsc2UpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vQ3JlYXRlIG5ldyBjbHVzdGVyIHdpdGggdGhlc2UgMiBpbiBpdFxuXG5cdFx0XHRcdFx0dmFyIG5ld0NsdXN0ZXIgPSBuZXcgdGhpcy5fbWFya2VyQ2x1c3Rlcih0aGlzLCB6b29tLCBjbG9zZXN0LCBsYXllcik7XG5cdFx0XHRcdFx0Z3JpZENsdXN0ZXJzW3pvb21dLmFkZE9iamVjdChuZXdDbHVzdGVyLCB0aGlzLl9tYXAucHJvamVjdChuZXdDbHVzdGVyLl9jTGF0TG5nLCB6b29tKSk7XG5cdFx0XHRcdFx0Y2xvc2VzdC5fX3BhcmVudCA9IG5ld0NsdXN0ZXI7XG5cdFx0XHRcdFx0bGF5ZXIuX19wYXJlbnQgPSBuZXdDbHVzdGVyO1xuXG5cdFx0XHRcdFx0Ly9GaXJzdCBjcmVhdGUgYW55IG5ldyBpbnRlcm1lZGlhdGUgcGFyZW50IGNsdXN0ZXJzIHRoYXQgZG9uJ3QgZXhpc3Rcblx0XHRcdFx0XHR2YXIgbGFzdFBhcmVudCA9IG5ld0NsdXN0ZXI7XG5cdFx0XHRcdFx0Zm9yICh6ID0gem9vbSAtIDE7IHogPiBwYXJlbnQuX3pvb207IHotLSkge1xuXHRcdFx0XHRcdFx0bGFzdFBhcmVudCA9IG5ldyB0aGlzLl9tYXJrZXJDbHVzdGVyKHRoaXMsIHosIGxhc3RQYXJlbnQpO1xuXHRcdFx0XHRcdFx0Z3JpZENsdXN0ZXJzW3pdLmFkZE9iamVjdChsYXN0UGFyZW50LCB0aGlzLl9tYXAucHJvamVjdChjbG9zZXN0LmdldExhdExuZygpLCB6KSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHBhcmVudC5fYWRkQ2hpbGQobGFzdFBhcmVudCk7XG5cblx0XHRcdFx0XHQvL1JlbW92ZSBjbG9zZXN0IGZyb20gdGhpcyB6b29tIGxldmVsIGFuZCBhbnkgYWJvdmUgdGhhdCBpdCBpcyBpbiwgcmVwbGFjZSB3aXRoIG5ld0NsdXN0ZXJcblx0XHRcdFx0XHR0aGlzLl9yZW1vdmVGcm9tR3JpZFVuY2x1c3RlcmVkKGNsb3Nlc3QsIHpvb20pO1xuXG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly9EaWRuJ3QgbWFuYWdlIHRvIGNsdXN0ZXIgaW4gYXQgdGhpcyB6b29tLCByZWNvcmQgdXMgYXMgYSBtYXJrZXIgaGVyZSBhbmQgY29udGludWUgdXB3YXJkc1xuXHRcdFx0XHRncmlkVW5jbHVzdGVyZWRbem9vbV0uYWRkT2JqZWN0KGxheWVyLCBtYXJrZXJQb2ludCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vRGlkbid0IGdldCBpbiBhbnl0aGluZywgYWRkIHVzIHRvIHRoZSB0b3Bcblx0XHRcdHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5fYWRkQ2hpbGQobGF5ZXIpO1xuXHRcdFx0bGF5ZXIuX19wYXJlbnQgPSB0aGlzLl90b3BDbHVzdGVyTGV2ZWw7XG5cdFx0XHRyZXR1cm47XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJlZnJlc2hlcyB0aGUgaWNvbiBvZiBhbGwgXCJkaXJ0eVwiIHZpc2libGUgY2x1c3RlcnMuXG5cdFx0ICogTm9uLXZpc2libGUgXCJkaXJ0eVwiIGNsdXN0ZXJzIHdpbGwgYmUgdXBkYXRlZCB3aGVuIHRoZXkgYXJlIGFkZGVkIHRvIHRoZSBtYXAuXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHRfcmVmcmVzaENsdXN0ZXJzSWNvbnM6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoaXMuX2ZlYXR1cmVHcm91cC5lYWNoTGF5ZXIoZnVuY3Rpb24gKGMpIHtcblx0XHRcdFx0aWYgKGMgaW5zdGFuY2VvZiBMLk1hcmtlckNsdXN0ZXIgJiYgYy5faWNvbk5lZWRzVXBkYXRlKSB7XG5cdFx0XHRcdFx0Yy5fdXBkYXRlSWNvbigpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0Ly9FbnF1ZXVlIGNvZGUgdG8gZmlyZSBhZnRlciB0aGUgbWFya2VyIGV4cGFuZC9jb250cmFjdCBoYXMgaGFwcGVuZWRcblx0XHRfZW5xdWV1ZTogZnVuY3Rpb24gKGZuKSB7XG5cdFx0XHR0aGlzLl9xdWV1ZS5wdXNoKGZuKTtcblx0XHRcdGlmICghdGhpcy5fcXVldWVUaW1lb3V0KSB7XG5cdFx0XHRcdHRoaXMuX3F1ZXVlVGltZW91dCA9IHNldFRpbWVvdXQoTC5iaW5kKHRoaXMuX3Byb2Nlc3NRdWV1ZSwgdGhpcyksIDMwMCk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRfcHJvY2Vzc1F1ZXVlOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3F1ZXVlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHRoaXMuX3F1ZXVlW2ldLmNhbGwodGhpcyk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9xdWV1ZS5sZW5ndGggPSAwO1xuXHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3F1ZXVlVGltZW91dCk7XG5cdFx0XHR0aGlzLl9xdWV1ZVRpbWVvdXQgPSBudWxsO1xuXHRcdH0sXG5cblx0XHQvL01lcmdlIGFuZCBzcGxpdCBhbnkgZXhpc3RpbmcgY2x1c3RlcnMgdGhhdCBhcmUgdG9vIGJpZyBvciBzbWFsbFxuXHRcdF9tZXJnZVNwbGl0Q2x1c3RlcnM6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBtYXBab29tID0gTWF0aC5yb3VuZCh0aGlzLl9tYXAuX3pvb20pO1xuXG5cdFx0XHQvL0luIGNhc2Ugd2UgYXJlIHN0YXJ0aW5nIHRvIHNwbGl0IGJlZm9yZSB0aGUgYW5pbWF0aW9uIGZpbmlzaGVkXG5cdFx0XHR0aGlzLl9wcm9jZXNzUXVldWUoKTtcblxuXHRcdFx0aWYgKHRoaXMuX3pvb20gPCBtYXBab29tICYmIHRoaXMuX2N1cnJlbnRTaG93bkJvdW5kcy5pbnRlcnNlY3RzKHRoaXMuX2dldEV4cGFuZGVkVmlzaWJsZUJvdW5kcygpKSkgeyAvL1pvb20gaW4sIHNwbGl0XG5cdFx0XHRcdHRoaXMuX2FuaW1hdGlvblN0YXJ0KCk7XG5cdFx0XHRcdC8vUmVtb3ZlIGNsdXN0ZXJzIG5vdyBvZmYgc2NyZWVuXG5cdFx0XHRcdHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5fcmVjdXJzaXZlbHlSZW1vdmVDaGlsZHJlbkZyb21NYXAodGhpcy5fY3VycmVudFNob3duQm91bmRzLCBNYXRoLmZsb29yKHRoaXMuX21hcC5nZXRNaW5ab29tKCkpLCB0aGlzLl96b29tLCB0aGlzLl9nZXRFeHBhbmRlZFZpc2libGVCb3VuZHMoKSk7XG5cblx0XHRcdFx0dGhpcy5fYW5pbWF0aW9uWm9vbUluKHRoaXMuX3pvb20sIG1hcFpvb20pO1xuXG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMuX3pvb20gPiBtYXBab29tKSB7IC8vWm9vbSBvdXQsIG1lcmdlXG5cdFx0XHRcdHRoaXMuX2FuaW1hdGlvblN0YXJ0KCk7XG5cblx0XHRcdFx0dGhpcy5fYW5pbWF0aW9uWm9vbU91dCh0aGlzLl96b29tLCBtYXBab29tKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuX21vdmVFbmQoKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Ly9HZXRzIHRoZSBtYXBzIHZpc2libGUgYm91bmRzIGV4cGFuZGVkIGluIGVhY2ggZGlyZWN0aW9uIGJ5IHRoZSBzaXplIG9mIHRoZSBzY3JlZW4gKHNvIHRoZSB1c2VyIGNhbm5vdCBzZWUgYW4gYXJlYSB3ZSBkbyBub3QgY292ZXIgaW4gb25lIHBhbilcblx0XHRfZ2V0RXhwYW5kZWRWaXNpYmxlQm91bmRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAoIXRoaXMub3B0aW9ucy5yZW1vdmVPdXRzaWRlVmlzaWJsZUJvdW5kcykge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fbWFwQm91bmRzSW5maW5pdGU7XG5cdFx0XHR9IGVsc2UgaWYgKEwuQnJvd3Nlci5tb2JpbGUpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2NoZWNrQm91bmRzTWF4TGF0KHRoaXMuX21hcC5nZXRCb3VuZHMoKSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzLl9jaGVja0JvdW5kc01heExhdCh0aGlzLl9tYXAuZ2V0Qm91bmRzKCkucGFkKDEpKTsgLy8gUGFkZGluZyBleHBhbmRzIHRoZSBib3VuZHMgYnkgaXRzIG93biBkaW1lbnNpb25zIGJ1dCBzY2FsZWQgd2l0aCB0aGUgZ2l2ZW4gZmFjdG9yLlxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBFeHBhbmRzIHRoZSBsYXRpdHVkZSB0byBJbmZpbml0eSAob3IgLUluZmluaXR5KSBpZiB0aGUgaW5wdXQgYm91bmRzIHJlYWNoIHRoZSBtYXAgcHJvamVjdGlvbiBtYXhpbXVtIGRlZmluZWQgbGF0aXR1ZGVcblx0XHQgKiAoaW4gdGhlIGNhc2Ugb2YgV2ViL1NwaGVyaWNhbCBNZXJjYXRvciwgaXQgaXMgODUuMDUxMTI4Nzc5OCAvIHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9XZWJfTWVyY2F0b3IjRm9ybXVsYXMpLlxuXHRcdCAqIE90aGVyd2lzZSwgdGhlIHJlbW92ZU91dHNpZGVWaXNpYmxlQm91bmRzIG9wdGlvbiB3aWxsIHJlbW92ZSBtYXJrZXJzIGJleW9uZCB0aGF0IGxpbWl0LCB3aGVyZWFzIHRoZSBzYW1lIG1hcmtlcnMgd2l0aG91dFxuXHRcdCAqIHRoaXMgb3B0aW9uIChvciBvdXRzaWRlIE1DRykgd2lsbCBoYXZlIHRoZWlyIHBvc2l0aW9uIGZsb29yZWQgKGNlaWxlZCkgYnkgdGhlIHByb2plY3Rpb24gYW5kIHJlbmRlcmVkIGF0IHRoYXQgbGltaXQsXG5cdFx0ICogbWFraW5nIHRoZSB1c2VyIHRoaW5rIHRoYXQgTUNHIFwiZWF0c1wiIHRoZW0gYW5kIG5ldmVyIGRpc3BsYXlzIHRoZW0gYWdhaW4uXG5cdFx0ICogQHBhcmFtIGJvdW5kcyBMLkxhdExuZ0JvdW5kc1xuXHRcdCAqIEByZXR1cm5zIHtMLkxhdExuZ0JvdW5kc31cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdF9jaGVja0JvdW5kc01heExhdDogZnVuY3Rpb24gKGJvdW5kcykge1xuXHRcdFx0dmFyIG1heExhdCA9IHRoaXMuX21heExhdDtcblxuXHRcdFx0aWYgKG1heExhdCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGlmIChib3VuZHMuZ2V0Tm9ydGgoKSA+PSBtYXhMYXQpIHtcblx0XHRcdFx0XHRib3VuZHMuX25vcnRoRWFzdC5sYXQgPSBJbmZpbml0eTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoYm91bmRzLmdldFNvdXRoKCkgPD0gLW1heExhdCkge1xuXHRcdFx0XHRcdGJvdW5kcy5fc291dGhXZXN0LmxhdCA9IC1JbmZpbml0eTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gYm91bmRzO1xuXHRcdH0sXG5cblx0XHQvL1NoYXJlZCBhbmltYXRpb24gY29kZVxuXHRcdF9hbmltYXRpb25BZGRMYXllck5vbkFuaW1hdGVkOiBmdW5jdGlvbiAobGF5ZXIsIG5ld0NsdXN0ZXIpIHtcblx0XHRcdGlmIChuZXdDbHVzdGVyID09PSBsYXllcikge1xuXHRcdFx0XHR0aGlzLl9mZWF0dXJlR3JvdXAuYWRkTGF5ZXIobGF5ZXIpO1xuXHRcdFx0fSBlbHNlIGlmIChuZXdDbHVzdGVyLl9jaGlsZENvdW50ID09PSAyKSB7XG5cdFx0XHRcdG5ld0NsdXN0ZXIuX2FkZFRvTWFwKCk7XG5cblx0XHRcdFx0dmFyIG1hcmtlcnMgPSBuZXdDbHVzdGVyLmdldEFsbENoaWxkTWFya2VycygpO1xuXHRcdFx0XHR0aGlzLl9mZWF0dXJlR3JvdXAucmVtb3ZlTGF5ZXIobWFya2Vyc1swXSk7XG5cdFx0XHRcdHRoaXMuX2ZlYXR1cmVHcm91cC5yZW1vdmVMYXllcihtYXJrZXJzWzFdKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG5ld0NsdXN0ZXIuX3VwZGF0ZUljb24oKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogRXh0cmFjdHMgaW5kaXZpZHVhbCAoaS5lLiBub24tZ3JvdXApIGxheWVycyBmcm9tIGEgTGF5ZXIgR3JvdXAuXG5cdFx0ICogQHBhcmFtIGdyb3VwIHRvIGV4dHJhY3QgbGF5ZXJzIGZyb20uXG5cdFx0ICogQHBhcmFtIG91dHB1dCB7QXJyYXl9IGluIHdoaWNoIHRvIHN0b3JlIHRoZSBleHRyYWN0ZWQgbGF5ZXJzLlxuXHRcdCAqIEByZXR1cm5zIHsqfEFycmF5fVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0X2V4dHJhY3ROb25Hcm91cExheWVyczogZnVuY3Rpb24gKGdyb3VwLCBvdXRwdXQpIHtcblx0XHRcdHZhciBsYXllcnMgPSBncm91cC5nZXRMYXllcnMoKSxcblx0XHRcdCAgICBpID0gMCxcblx0XHRcdCAgICBsYXllcjtcblxuXHRcdFx0b3V0cHV0ID0gb3V0cHV0IHx8IFtdO1xuXG5cdFx0XHRmb3IgKDsgaSA8IGxheWVycy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRsYXllciA9IGxheWVyc1tpXTtcblxuXHRcdFx0XHRpZiAobGF5ZXIgaW5zdGFuY2VvZiBMLkxheWVyR3JvdXApIHtcblx0XHRcdFx0XHR0aGlzLl9leHRyYWN0Tm9uR3JvdXBMYXllcnMobGF5ZXIsIG91dHB1dCk7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRvdXRwdXQucHVzaChsYXllcik7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBvdXRwdXQ7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEltcGxlbWVudHMgdGhlIHNpbmdsZU1hcmtlck1vZGUgb3B0aW9uLlxuXHRcdCAqIEBwYXJhbSBsYXllciBNYXJrZXIgdG8gcmUtc3R5bGUgdXNpbmcgdGhlIENsdXN0ZXJzIGljb25DcmVhdGVGdW5jdGlvbi5cblx0XHQgKiBAcmV0dXJucyB7TC5JY29ufSBUaGUgbmV3bHkgY3JlYXRlZCBpY29uLlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0X292ZXJyaWRlTWFya2VySWNvbjogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0XHR2YXIgaWNvbiA9IGxheWVyLm9wdGlvbnMuaWNvbiA9IHRoaXMub3B0aW9ucy5pY29uQ3JlYXRlRnVuY3Rpb24oe1xuXHRcdFx0XHRnZXRDaGlsZENvdW50OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGdldEFsbENoaWxkTWFya2VyczogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHJldHVybiBbbGF5ZXJdO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0cmV0dXJuIGljb247XG5cdFx0fVxuXHR9KTtcblxuXHQvLyBDb25zdGFudCBib3VuZHMgdXNlZCBpbiBjYXNlIG9wdGlvbiBcInJlbW92ZU91dHNpZGVWaXNpYmxlQm91bmRzXCIgaXMgc2V0IHRvIGZhbHNlLlxuXHRMLk1hcmtlckNsdXN0ZXJHcm91cC5pbmNsdWRlKHtcblx0XHRfbWFwQm91bmRzSW5maW5pdGU6IG5ldyBMLkxhdExuZ0JvdW5kcyhuZXcgTC5MYXRMbmcoLUluZmluaXR5LCAtSW5maW5pdHkpLCBuZXcgTC5MYXRMbmcoSW5maW5pdHksIEluZmluaXR5KSlcblx0fSk7XG5cblx0TC5NYXJrZXJDbHVzdGVyR3JvdXAuaW5jbHVkZSh7XG5cdFx0X25vQW5pbWF0aW9uOiB7XG5cdFx0XHQvL05vbiBBbmltYXRlZCB2ZXJzaW9ucyBvZiBldmVyeXRoaW5nXG5cdFx0XHRfYW5pbWF0aW9uU3RhcnQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0Ly9EbyBub3RoaW5nLi4uXG5cdFx0XHR9LFxuXHRcdFx0X2FuaW1hdGlvblpvb21JbjogZnVuY3Rpb24gKHByZXZpb3VzWm9vbUxldmVsLCBuZXdab29tTGV2ZWwpIHtcblx0XHRcdFx0dGhpcy5fdG9wQ2x1c3RlckxldmVsLl9yZWN1cnNpdmVseVJlbW92ZUNoaWxkcmVuRnJvbU1hcCh0aGlzLl9jdXJyZW50U2hvd25Cb3VuZHMsIE1hdGguZmxvb3IodGhpcy5fbWFwLmdldE1pblpvb20oKSksIHByZXZpb3VzWm9vbUxldmVsKTtcblx0XHRcdFx0dGhpcy5fdG9wQ2x1c3RlckxldmVsLl9yZWN1cnNpdmVseUFkZENoaWxkcmVuVG9NYXAobnVsbCwgbmV3Wm9vbUxldmVsLCB0aGlzLl9nZXRFeHBhbmRlZFZpc2libGVCb3VuZHMoKSk7XG5cblx0XHRcdFx0Ly9XZSBkaWRuJ3QgYWN0dWFsbHkgYW5pbWF0ZSwgYnV0IHdlIHVzZSB0aGlzIGV2ZW50IHRvIG1lYW4gXCJjbHVzdGVyaW5nIGFuaW1hdGlvbnMgaGF2ZSBmaW5pc2hlZFwiXG5cdFx0XHRcdHRoaXMuZmlyZSgnYW5pbWF0aW9uZW5kJyk7XG5cdFx0XHR9LFxuXHRcdFx0X2FuaW1hdGlvblpvb21PdXQ6IGZ1bmN0aW9uIChwcmV2aW91c1pvb21MZXZlbCwgbmV3Wm9vbUxldmVsKSB7XG5cdFx0XHRcdHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5fcmVjdXJzaXZlbHlSZW1vdmVDaGlsZHJlbkZyb21NYXAodGhpcy5fY3VycmVudFNob3duQm91bmRzLCBNYXRoLmZsb29yKHRoaXMuX21hcC5nZXRNaW5ab29tKCkpLCBwcmV2aW91c1pvb21MZXZlbCk7XG5cdFx0XHRcdHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5fcmVjdXJzaXZlbHlBZGRDaGlsZHJlblRvTWFwKG51bGwsIG5ld1pvb21MZXZlbCwgdGhpcy5fZ2V0RXhwYW5kZWRWaXNpYmxlQm91bmRzKCkpO1xuXG5cdFx0XHRcdC8vV2UgZGlkbid0IGFjdHVhbGx5IGFuaW1hdGUsIGJ1dCB3ZSB1c2UgdGhpcyBldmVudCB0byBtZWFuIFwiY2x1c3RlcmluZyBhbmltYXRpb25zIGhhdmUgZmluaXNoZWRcIlxuXHRcdFx0XHR0aGlzLmZpcmUoJ2FuaW1hdGlvbmVuZCcpO1xuXHRcdFx0fSxcblx0XHRcdF9hbmltYXRpb25BZGRMYXllcjogZnVuY3Rpb24gKGxheWVyLCBuZXdDbHVzdGVyKSB7XG5cdFx0XHRcdHRoaXMuX2FuaW1hdGlvbkFkZExheWVyTm9uQW5pbWF0ZWQobGF5ZXIsIG5ld0NsdXN0ZXIpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRfd2l0aEFuaW1hdGlvbjoge1xuXHRcdFx0Ly9BbmltYXRlZCB2ZXJzaW9ucyBoZXJlXG5cdFx0XHRfYW5pbWF0aW9uU3RhcnQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dGhpcy5fbWFwLl9tYXBQYW5lLmNsYXNzTmFtZSArPSAnIGxlYWZsZXQtY2x1c3Rlci1hbmltJztcblx0XHRcdFx0dGhpcy5faW5ab29tQW5pbWF0aW9uKys7XG5cdFx0XHR9LFxuXG5cdFx0XHRfYW5pbWF0aW9uWm9vbUluOiBmdW5jdGlvbiAocHJldmlvdXNab29tTGV2ZWwsIG5ld1pvb21MZXZlbCkge1xuXHRcdFx0XHR2YXIgYm91bmRzID0gdGhpcy5fZ2V0RXhwYW5kZWRWaXNpYmxlQm91bmRzKCksXG5cdFx0XHRcdCAgICBmZyA9IHRoaXMuX2ZlYXR1cmVHcm91cCxcblx0XHRcdFx0XHRtaW5ab29tID0gTWF0aC5mbG9vcih0aGlzLl9tYXAuZ2V0TWluWm9vbSgpKSxcblx0XHRcdFx0ICAgIGk7XG5cblx0XHRcdFx0dGhpcy5faWdub3JlTW92ZSA9IHRydWU7XG5cblx0XHRcdFx0Ly9BZGQgYWxsIGNoaWxkcmVuIG9mIGN1cnJlbnQgY2x1c3RlcnMgdG8gbWFwIGFuZCByZW1vdmUgdGhvc2UgY2x1c3RlcnMgZnJvbSBtYXBcblx0XHRcdFx0dGhpcy5fdG9wQ2x1c3RlckxldmVsLl9yZWN1cnNpdmVseShib3VuZHMsIHByZXZpb3VzWm9vbUxldmVsLCBtaW5ab29tLCBmdW5jdGlvbiAoYykge1xuXHRcdFx0XHRcdHZhciBzdGFydFBvcyA9IGMuX2xhdGxuZyxcblx0XHRcdFx0XHQgICAgbWFya2VycyAgPSBjLl9tYXJrZXJzLFxuXHRcdFx0XHRcdCAgICBtO1xuXG5cdFx0XHRcdFx0aWYgKCFib3VuZHMuY29udGFpbnMoc3RhcnRQb3MpKSB7XG5cdFx0XHRcdFx0XHRzdGFydFBvcyA9IG51bGw7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKGMuX2lzU2luZ2xlUGFyZW50KCkgJiYgcHJldmlvdXNab29tTGV2ZWwgKyAxID09PSBuZXdab29tTGV2ZWwpIHsgLy9JbW1lZGlhdGVseSBhZGQgdGhlIG5ldyBjaGlsZCBhbmQgcmVtb3ZlIHVzXG5cdFx0XHRcdFx0XHRmZy5yZW1vdmVMYXllcihjKTtcblx0XHRcdFx0XHRcdGMuX3JlY3Vyc2l2ZWx5QWRkQ2hpbGRyZW5Ub01hcChudWxsLCBuZXdab29tTGV2ZWwsIGJvdW5kcyk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8vRmFkZSBvdXQgb2xkIGNsdXN0ZXJcblx0XHRcdFx0XHRcdGMuY2x1c3RlckhpZGUoKTtcblx0XHRcdFx0XHRcdGMuX3JlY3Vyc2l2ZWx5QWRkQ2hpbGRyZW5Ub01hcChzdGFydFBvcywgbmV3Wm9vbUxldmVsLCBib3VuZHMpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vUmVtb3ZlIGFsbCBtYXJrZXJzIHRoYXQgYXJlbid0IHZpc2libGUgYW55IG1vcmVcblx0XHRcdFx0XHQvL1RPRE86IERvIHdlIGFjdHVhbGx5IG5lZWQgdG8gZG8gdGhpcyBvbiB0aGUgaGlnaGVyIGxldmVscyB0b28/XG5cdFx0XHRcdFx0Zm9yIChpID0gbWFya2Vycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHRcdFx0bSA9IG1hcmtlcnNbaV07XG5cdFx0XHRcdFx0XHRpZiAoIWJvdW5kcy5jb250YWlucyhtLl9sYXRsbmcpKSB7XG5cdFx0XHRcdFx0XHRcdGZnLnJlbW92ZUxheWVyKG0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHR0aGlzLl9mb3JjZUxheW91dCgpO1xuXG5cdFx0XHRcdC8vVXBkYXRlIG9wYWNpdGllc1xuXHRcdFx0XHR0aGlzLl90b3BDbHVzdGVyTGV2ZWwuX3JlY3Vyc2l2ZWx5QmVjb21lVmlzaWJsZShib3VuZHMsIG5ld1pvb21MZXZlbCk7XG5cdFx0XHRcdC8vVE9ETyBNYXliZT8gVXBkYXRlIG1hcmtlcnMgaW4gX3JlY3Vyc2l2ZWx5QmVjb21lVmlzaWJsZVxuXHRcdFx0XHRmZy5lYWNoTGF5ZXIoZnVuY3Rpb24gKG4pIHtcblx0XHRcdFx0XHRpZiAoIShuIGluc3RhbmNlb2YgTC5NYXJrZXJDbHVzdGVyKSAmJiBuLl9pY29uKSB7XG5cdFx0XHRcdFx0XHRuLmNsdXN0ZXJTaG93KCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHQvL3VwZGF0ZSB0aGUgcG9zaXRpb25zIG9mIHRoZSBqdXN0IGFkZGVkIGNsdXN0ZXJzL21hcmtlcnNcblx0XHRcdFx0dGhpcy5fdG9wQ2x1c3RlckxldmVsLl9yZWN1cnNpdmVseShib3VuZHMsIHByZXZpb3VzWm9vbUxldmVsLCBuZXdab29tTGV2ZWwsIGZ1bmN0aW9uIChjKSB7XG5cdFx0XHRcdFx0Yy5fcmVjdXJzaXZlbHlSZXN0b3JlQ2hpbGRQb3NpdGlvbnMobmV3Wm9vbUxldmVsKTtcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0dGhpcy5faWdub3JlTW92ZSA9IGZhbHNlO1xuXG5cdFx0XHRcdC8vUmVtb3ZlIHRoZSBvbGQgY2x1c3RlcnMgYW5kIGNsb3NlIHRoZSB6b29tIGFuaW1hdGlvblxuXHRcdFx0XHR0aGlzLl9lbnF1ZXVlKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHQvL3VwZGF0ZSB0aGUgcG9zaXRpb25zIG9mIHRoZSBqdXN0IGFkZGVkIGNsdXN0ZXJzL21hcmtlcnNcblx0XHRcdFx0XHR0aGlzLl90b3BDbHVzdGVyTGV2ZWwuX3JlY3Vyc2l2ZWx5KGJvdW5kcywgcHJldmlvdXNab29tTGV2ZWwsIG1pblpvb20sIGZ1bmN0aW9uIChjKSB7XG5cdFx0XHRcdFx0XHRmZy5yZW1vdmVMYXllcihjKTtcblx0XHRcdFx0XHRcdGMuY2x1c3RlclNob3coKTtcblx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdHRoaXMuX2FuaW1hdGlvbkVuZCgpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0sXG5cblx0XHRcdF9hbmltYXRpb25ab29tT3V0OiBmdW5jdGlvbiAocHJldmlvdXNab29tTGV2ZWwsIG5ld1pvb21MZXZlbCkge1xuXHRcdFx0XHR0aGlzLl9hbmltYXRpb25ab29tT3V0U2luZ2xlKHRoaXMuX3RvcENsdXN0ZXJMZXZlbCwgcHJldmlvdXNab29tTGV2ZWwgLSAxLCBuZXdab29tTGV2ZWwpO1xuXG5cdFx0XHRcdC8vTmVlZCB0byBhZGQgbWFya2VycyBmb3IgdGhvc2UgdGhhdCB3ZXJlbid0IG9uIHRoZSBtYXAgYmVmb3JlIGJ1dCBhcmUgbm93XG5cdFx0XHRcdHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5fcmVjdXJzaXZlbHlBZGRDaGlsZHJlblRvTWFwKG51bGwsIG5ld1pvb21MZXZlbCwgdGhpcy5fZ2V0RXhwYW5kZWRWaXNpYmxlQm91bmRzKCkpO1xuXHRcdFx0XHQvL1JlbW92ZSBtYXJrZXJzIHRoYXQgd2VyZSBvbiB0aGUgbWFwIGJlZm9yZSBidXQgd29uJ3QgYmUgbm93XG5cdFx0XHRcdHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5fcmVjdXJzaXZlbHlSZW1vdmVDaGlsZHJlbkZyb21NYXAodGhpcy5fY3VycmVudFNob3duQm91bmRzLCBNYXRoLmZsb29yKHRoaXMuX21hcC5nZXRNaW5ab29tKCkpLCBwcmV2aW91c1pvb21MZXZlbCwgdGhpcy5fZ2V0RXhwYW5kZWRWaXNpYmxlQm91bmRzKCkpO1xuXHRcdFx0fSxcblxuXHRcdFx0X2FuaW1hdGlvbkFkZExheWVyOiBmdW5jdGlvbiAobGF5ZXIsIG5ld0NsdXN0ZXIpIHtcblx0XHRcdFx0dmFyIG1lID0gdGhpcyxcblx0XHRcdFx0ICAgIGZnID0gdGhpcy5fZmVhdHVyZUdyb3VwO1xuXG5cdFx0XHRcdGZnLmFkZExheWVyKGxheWVyKTtcblx0XHRcdFx0aWYgKG5ld0NsdXN0ZXIgIT09IGxheWVyKSB7XG5cdFx0XHRcdFx0aWYgKG5ld0NsdXN0ZXIuX2NoaWxkQ291bnQgPiAyKSB7IC8vV2FzIGFscmVhZHkgYSBjbHVzdGVyXG5cblx0XHRcdFx0XHRcdG5ld0NsdXN0ZXIuX3VwZGF0ZUljb24oKTtcblx0XHRcdFx0XHRcdHRoaXMuX2ZvcmNlTGF5b3V0KCk7XG5cdFx0XHRcdFx0XHR0aGlzLl9hbmltYXRpb25TdGFydCgpO1xuXG5cdFx0XHRcdFx0XHRsYXllci5fc2V0UG9zKHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQobmV3Q2x1c3Rlci5nZXRMYXRMbmcoKSkpO1xuXHRcdFx0XHRcdFx0bGF5ZXIuY2x1c3RlckhpZGUoKTtcblxuXHRcdFx0XHRcdFx0dGhpcy5fZW5xdWV1ZShmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHRcdGZnLnJlbW92ZUxheWVyKGxheWVyKTtcblx0XHRcdFx0XHRcdFx0bGF5ZXIuY2x1c3RlclNob3coKTtcblxuXHRcdFx0XHRcdFx0XHRtZS5fYW5pbWF0aW9uRW5kKCk7XG5cdFx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7IC8vSnVzdCBiZWNhbWUgYSBjbHVzdGVyXG5cdFx0XHRcdFx0XHR0aGlzLl9mb3JjZUxheW91dCgpO1xuXG5cdFx0XHRcdFx0XHRtZS5fYW5pbWF0aW9uU3RhcnQoKTtcblx0XHRcdFx0XHRcdG1lLl9hbmltYXRpb25ab29tT3V0U2luZ2xlKG5ld0NsdXN0ZXIsIHRoaXMuX21hcC5nZXRNYXhab29tKCksIHRoaXMuX3pvb20pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvLyBQcml2YXRlIG1ldGhvZHMgZm9yIGFuaW1hdGVkIHZlcnNpb25zLlxuXHRcdF9hbmltYXRpb25ab29tT3V0U2luZ2xlOiBmdW5jdGlvbiAoY2x1c3RlciwgcHJldmlvdXNab29tTGV2ZWwsIG5ld1pvb21MZXZlbCkge1xuXHRcdFx0dmFyIGJvdW5kcyA9IHRoaXMuX2dldEV4cGFuZGVkVmlzaWJsZUJvdW5kcygpLFxuXHRcdFx0XHRtaW5ab29tID0gTWF0aC5mbG9vcih0aGlzLl9tYXAuZ2V0TWluWm9vbSgpKTtcblxuXHRcdFx0Ly9BbmltYXRlIGFsbCBvZiB0aGUgbWFya2VycyBpbiB0aGUgY2x1c3RlcnMgdG8gbW92ZSB0byB0aGVpciBjbHVzdGVyIGNlbnRlciBwb2ludFxuXHRcdFx0Y2x1c3Rlci5fcmVjdXJzaXZlbHlBbmltYXRlQ2hpbGRyZW5JbkFuZEFkZFNlbGZUb01hcChib3VuZHMsIG1pblpvb20sIHByZXZpb3VzWm9vbUxldmVsICsgMSwgbmV3Wm9vbUxldmVsKTtcblxuXHRcdFx0dmFyIG1lID0gdGhpcztcblxuXHRcdFx0Ly9VcGRhdGUgdGhlIG9wYWNpdHkgKElmIHdlIGltbWVkaWF0ZWx5IHNldCBpdCB0aGV5IHdvbid0IGFuaW1hdGUpXG5cdFx0XHR0aGlzLl9mb3JjZUxheW91dCgpO1xuXHRcdFx0Y2x1c3Rlci5fcmVjdXJzaXZlbHlCZWNvbWVWaXNpYmxlKGJvdW5kcywgbmV3Wm9vbUxldmVsKTtcblxuXHRcdFx0Ly9UT0RPOiBNYXliZSB1c2UgdGhlIHRyYW5zaXRpb24gdGltaW5nIHN0dWZmIHRvIG1ha2UgdGhpcyBtb3JlIHJlbGlhYmxlXG5cdFx0XHQvL1doZW4gdGhlIGFuaW1hdGlvbnMgYXJlIGRvbmUsIHRpZHkgdXBcblx0XHRcdHRoaXMuX2VucXVldWUoZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdC8vVGhpcyBjbHVzdGVyIHN0b3BwZWQgYmVpbmcgYSBjbHVzdGVyIGJlZm9yZSB0aGUgdGltZW91dCBmaXJlZFxuXHRcdFx0XHRpZiAoY2x1c3Rlci5fY2hpbGRDb3VudCA9PT0gMSkge1xuXHRcdFx0XHRcdHZhciBtID0gY2x1c3Rlci5fbWFya2Vyc1swXTtcblx0XHRcdFx0XHQvL0lmIHdlIHdlcmUgaW4gYSBjbHVzdGVyIGFuaW1hdGlvbiBhdCB0aGUgdGltZSB0aGVuIHRoZSBvcGFjaXR5IGFuZCBwb3NpdGlvbiBvZiBvdXIgY2hpbGQgY291bGQgYmUgd3Jvbmcgbm93LCBzbyBmaXggaXRcblx0XHRcdFx0XHR0aGlzLl9pZ25vcmVNb3ZlID0gdHJ1ZTtcblx0XHRcdFx0XHRtLnNldExhdExuZyhtLmdldExhdExuZygpKTtcblx0XHRcdFx0XHR0aGlzLl9pZ25vcmVNb3ZlID0gZmFsc2U7XG5cdFx0XHRcdFx0aWYgKG0uY2x1c3RlclNob3cpIHtcblx0XHRcdFx0XHRcdG0uY2x1c3RlclNob3coKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y2x1c3Rlci5fcmVjdXJzaXZlbHkoYm91bmRzLCBuZXdab29tTGV2ZWwsIG1pblpvb20sIGZ1bmN0aW9uIChjKSB7XG5cdFx0XHRcdFx0XHRjLl9yZWN1cnNpdmVseVJlbW92ZUNoaWxkcmVuRnJvbU1hcChib3VuZHMsIG1pblpvb20sIHByZXZpb3VzWm9vbUxldmVsICsgMSk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0bWUuX2FuaW1hdGlvbkVuZCgpO1xuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdF9hbmltYXRpb25FbmQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmICh0aGlzLl9tYXApIHtcblx0XHRcdFx0dGhpcy5fbWFwLl9tYXBQYW5lLmNsYXNzTmFtZSA9IHRoaXMuX21hcC5fbWFwUGFuZS5jbGFzc05hbWUucmVwbGFjZSgnIGxlYWZsZXQtY2x1c3Rlci1hbmltJywgJycpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5faW5ab29tQW5pbWF0aW9uLS07XG5cdFx0XHR0aGlzLmZpcmUoJ2FuaW1hdGlvbmVuZCcpO1xuXHRcdH0sXG5cblx0XHQvL0ZvcmNlIGEgYnJvd3NlciBsYXlvdXQgb2Ygc3R1ZmYgaW4gdGhlIG1hcFxuXHRcdC8vIFNob3VsZCBhcHBseSB0aGUgY3VycmVudCBvcGFjaXR5IGFuZCBsb2NhdGlvbiB0byBhbGwgZWxlbWVudHMgc28gd2UgY2FuIHVwZGF0ZSB0aGVtIGFnYWluIGZvciBhbiBhbmltYXRpb25cblx0XHRfZm9yY2VMYXlvdXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdC8vSW4gbXkgdGVzdGluZyB0aGlzIHdvcmtzLCBpbmZhY3Qgb2Zmc2V0V2lkdGggb2YgYW55IGVsZW1lbnQgc2VlbXMgdG8gd29yay5cblx0XHRcdC8vQ291bGQgbG9vcCBhbGwgdGhpcy5fbGF5ZXJzIGFuZCBkbyB0aGlzIGZvciBlYWNoIF9pY29uIGlmIGl0IHN0b3BzIHdvcmtpbmdcblxuXHRcdFx0TC5VdGlsLmZhbHNlRm4oZG9jdW1lbnQuYm9keS5vZmZzZXRXaWR0aCk7XG5cdFx0fVxuXHR9KTtcblxuXHRMLm1hcmtlckNsdXN0ZXJHcm91cCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdFx0cmV0dXJuIG5ldyBMLk1hcmtlckNsdXN0ZXJHcm91cChvcHRpb25zKTtcblx0fTtcblxuXHR2YXIgTWFya2VyQ2x1c3RlciA9IEwuTWFya2VyQ2x1c3RlciA9IEwuTWFya2VyLmV4dGVuZCh7XG5cdFx0b3B0aW9uczogTC5JY29uLnByb3RvdHlwZS5vcHRpb25zLFxuXG5cdFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGdyb3VwLCB6b29tLCBhLCBiKSB7XG5cblx0XHRcdEwuTWFya2VyLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgYSA/IChhLl9jTGF0TG5nIHx8IGEuZ2V0TGF0TG5nKCkpIDogbmV3IEwuTGF0TG5nKDAsIDApLFxuXHQgICAgICAgICAgICB7IGljb246IHRoaXMsIHBhbmU6IGdyb3VwLm9wdGlvbnMuY2x1c3RlclBhbmUgfSk7XG5cblx0XHRcdHRoaXMuX2dyb3VwID0gZ3JvdXA7XG5cdFx0XHR0aGlzLl96b29tID0gem9vbTtcblxuXHRcdFx0dGhpcy5fbWFya2VycyA9IFtdO1xuXHRcdFx0dGhpcy5fY2hpbGRDbHVzdGVycyA9IFtdO1xuXHRcdFx0dGhpcy5fY2hpbGRDb3VudCA9IDA7XG5cdFx0XHR0aGlzLl9pY29uTmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdFx0dGhpcy5fYm91bmRzTmVlZFVwZGF0ZSA9IHRydWU7XG5cblx0XHRcdHRoaXMuX2JvdW5kcyA9IG5ldyBMLkxhdExuZ0JvdW5kcygpO1xuXG5cdFx0XHRpZiAoYSkge1xuXHRcdFx0XHR0aGlzLl9hZGRDaGlsZChhKTtcblx0XHRcdH1cblx0XHRcdGlmIChiKSB7XG5cdFx0XHRcdHRoaXMuX2FkZENoaWxkKGIpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvL1JlY3Vyc2l2ZWx5IHJldHJpZXZlIGFsbCBjaGlsZCBtYXJrZXJzIG9mIHRoaXMgY2x1c3RlclxuXHRcdGdldEFsbENoaWxkTWFya2VyczogZnVuY3Rpb24gKHN0b3JhZ2VBcnJheSwgaWdub3JlRHJhZ2dlZE1hcmtlcikge1xuXHRcdFx0c3RvcmFnZUFycmF5ID0gc3RvcmFnZUFycmF5IHx8IFtdO1xuXG5cdFx0XHRmb3IgKHZhciBpID0gdGhpcy5fY2hpbGRDbHVzdGVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHR0aGlzLl9jaGlsZENsdXN0ZXJzW2ldLmdldEFsbENoaWxkTWFya2VycyhzdG9yYWdlQXJyYXksIGlnbm9yZURyYWdnZWRNYXJrZXIpO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKHZhciBqID0gdGhpcy5fbWFya2Vycy5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xuXHRcdFx0XHRpZiAoaWdub3JlRHJhZ2dlZE1hcmtlciAmJiB0aGlzLl9tYXJrZXJzW2pdLl9fZHJhZ1N0YXJ0KSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0c3RvcmFnZUFycmF5LnB1c2godGhpcy5fbWFya2Vyc1tqXSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBzdG9yYWdlQXJyYXk7XG5cdFx0fSxcblxuXHRcdC8vUmV0dXJucyB0aGUgY291bnQgb2YgaG93IG1hbnkgY2hpbGQgbWFya2VycyB3ZSBoYXZlXG5cdFx0Z2V0Q2hpbGRDb3VudDogZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX2NoaWxkQ291bnQ7XG5cdFx0fSxcblxuXHRcdC8vWm9vbSB0byB0aGUgbWluaW11bSBvZiBzaG93aW5nIGFsbCBvZiB0aGUgY2hpbGQgbWFya2Vycywgb3IgdGhlIGV4dGVudHMgb2YgdGhpcyBjbHVzdGVyXG5cdFx0em9vbVRvQm91bmRzOiBmdW5jdGlvbiAoZml0Qm91bmRzT3B0aW9ucykge1xuXHRcdFx0dmFyIGNoaWxkQ2x1c3RlcnMgPSB0aGlzLl9jaGlsZENsdXN0ZXJzLnNsaWNlKCksXG5cdFx0XHRcdG1hcCA9IHRoaXMuX2dyb3VwLl9tYXAsXG5cdFx0XHRcdGJvdW5kc1pvb20gPSBtYXAuZ2V0Qm91bmRzWm9vbSh0aGlzLl9ib3VuZHMpLFxuXHRcdFx0XHR6b29tID0gdGhpcy5fem9vbSArIDEsXG5cdFx0XHRcdG1hcFpvb20gPSBtYXAuZ2V0Wm9vbSgpLFxuXHRcdFx0XHRpO1xuXG5cdFx0XHQvL2NhbGN1bGF0ZSBob3cgZmFyIHdlIG5lZWQgdG8gem9vbSBkb3duIHRvIHNlZSBhbGwgb2YgdGhlIG1hcmtlcnNcblx0XHRcdHdoaWxlIChjaGlsZENsdXN0ZXJzLmxlbmd0aCA+IDAgJiYgYm91bmRzWm9vbSA+IHpvb20pIHtcblx0XHRcdFx0em9vbSsrO1xuXHRcdFx0XHR2YXIgbmV3Q2x1c3RlcnMgPSBbXTtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGNoaWxkQ2x1c3RlcnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRuZXdDbHVzdGVycyA9IG5ld0NsdXN0ZXJzLmNvbmNhdChjaGlsZENsdXN0ZXJzW2ldLl9jaGlsZENsdXN0ZXJzKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjaGlsZENsdXN0ZXJzID0gbmV3Q2x1c3RlcnM7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChib3VuZHNab29tID4gem9vbSkge1xuXHRcdFx0XHR0aGlzLl9ncm91cC5fbWFwLnNldFZpZXcodGhpcy5fbGF0bG5nLCB6b29tKTtcblx0XHRcdH0gZWxzZSBpZiAoYm91bmRzWm9vbSA8PSBtYXBab29tKSB7IC8vSWYgZml0Qm91bmRzIHdvdWxkbid0IHpvb20gdXMgZG93biwgem9vbSB1cyBkb3duIGluc3RlYWRcblx0XHRcdFx0dGhpcy5fZ3JvdXAuX21hcC5zZXRWaWV3KHRoaXMuX2xhdGxuZywgbWFwWm9vbSArIDEpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5fZ3JvdXAuX21hcC5maXRCb3VuZHModGhpcy5fYm91bmRzLCBmaXRCb3VuZHNPcHRpb25zKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Z2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgYm91bmRzID0gbmV3IEwuTGF0TG5nQm91bmRzKCk7XG5cdFx0XHRib3VuZHMuZXh0ZW5kKHRoaXMuX2JvdW5kcyk7XG5cdFx0XHRyZXR1cm4gYm91bmRzO1xuXHRcdH0sXG5cblx0XHRfdXBkYXRlSWNvbjogZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhpcy5faWNvbk5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHRcdGlmICh0aGlzLl9pY29uKSB7XG5cdFx0XHRcdHRoaXMuc2V0SWNvbih0aGlzKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Ly9DbHVkZ2UgZm9yIEljb24sIHdlIHByZXRlbmQgdG8gYmUgYW4gaWNvbiBmb3IgcGVyZm9ybWFuY2Vcblx0XHRjcmVhdGVJY29uOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAodGhpcy5faWNvbk5lZWRzVXBkYXRlKSB7XG5cdFx0XHRcdHRoaXMuX2ljb25PYmogPSB0aGlzLl9ncm91cC5vcHRpb25zLmljb25DcmVhdGVGdW5jdGlvbih0aGlzKTtcblx0XHRcdFx0dGhpcy5faWNvbk5lZWRzVXBkYXRlID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5faWNvbk9iai5jcmVhdGVJY29uKCk7XG5cdFx0fSxcblx0XHRjcmVhdGVTaGFkb3c6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiB0aGlzLl9pY29uT2JqLmNyZWF0ZVNoYWRvdygpO1xuXHRcdH0sXG5cblxuXHRcdF9hZGRDaGlsZDogZnVuY3Rpb24gKG5ldzEsIGlzTm90aWZpY2F0aW9uRnJvbUNoaWxkKSB7XG5cblx0XHRcdHRoaXMuX2ljb25OZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdHRoaXMuX2JvdW5kc05lZWRVcGRhdGUgPSB0cnVlO1xuXHRcdFx0dGhpcy5fc2V0Q2x1c3RlckNlbnRlcihuZXcxKTtcblxuXHRcdFx0aWYgKG5ldzEgaW5zdGFuY2VvZiBMLk1hcmtlckNsdXN0ZXIpIHtcblx0XHRcdFx0aWYgKCFpc05vdGlmaWNhdGlvbkZyb21DaGlsZCkge1xuXHRcdFx0XHRcdHRoaXMuX2NoaWxkQ2x1c3RlcnMucHVzaChuZXcxKTtcblx0XHRcdFx0XHRuZXcxLl9fcGFyZW50ID0gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl9jaGlsZENvdW50ICs9IG5ldzEuX2NoaWxkQ291bnQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoIWlzTm90aWZpY2F0aW9uRnJvbUNoaWxkKSB7XG5cdFx0XHRcdFx0dGhpcy5fbWFya2Vycy5wdXNoKG5ldzEpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX2NoaWxkQ291bnQrKztcblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMuX19wYXJlbnQpIHtcblx0XHRcdFx0dGhpcy5fX3BhcmVudC5fYWRkQ2hpbGQobmV3MSwgdHJ1ZSk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIE1ha2VzIHN1cmUgdGhlIGNsdXN0ZXIgY2VudGVyIGlzIHNldC4gSWYgbm90LCB1c2VzIHRoZSBjaGlsZCBjZW50ZXIgaWYgaXQgaXMgYSBjbHVzdGVyLCBvciB0aGUgbWFya2VyIHBvc2l0aW9uLlxuXHRcdCAqIEBwYXJhbSBjaGlsZCBMLk1hcmtlckNsdXN0ZXJ8TC5NYXJrZXIgdGhhdCB3aWxsIGJlIHVzZWQgYXMgY2x1c3RlciBjZW50ZXIgaWYgbm90IGRlZmluZWQgeWV0LlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0X3NldENsdXN0ZXJDZW50ZXI6IGZ1bmN0aW9uIChjaGlsZCkge1xuXHRcdFx0aWYgKCF0aGlzLl9jTGF0TG5nKSB7XG5cdFx0XHRcdC8vIHdoZW4gY2x1c3RlcmluZywgdGFrZSBwb3NpdGlvbiBvZiB0aGUgZmlyc3QgcG9pbnQgYXMgdGhlIGNsdXN0ZXIgY2VudGVyXG5cdFx0XHRcdHRoaXMuX2NMYXRMbmcgPSBjaGlsZC5fY0xhdExuZyB8fCBjaGlsZC5fbGF0bG5nO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBBc3NpZ25zIGltcG9zc2libGUgYm91bmRpbmcgdmFsdWVzIHNvIHRoYXQgdGhlIG5leHQgZXh0ZW5kIGVudGlyZWx5IGRldGVybWluZXMgdGhlIG5ldyBib3VuZHMuXG5cdFx0ICogVGhpcyBtZXRob2QgYXZvaWRzIGhhdmluZyB0byB0cmFzaCB0aGUgcHJldmlvdXMgTC5MYXRMbmdCb3VuZHMgb2JqZWN0IGFuZCB0byBjcmVhdGUgYSBuZXcgb25lLCB3aGljaCBpcyBtdWNoIHNsb3dlciBmb3IgdGhpcyBjbGFzcy5cblx0XHQgKiBBcyBsb25nIGFzIHRoZSBib3VuZHMgYXJlIG5vdCBleHRlbmRlZCwgbW9zdCBvdGhlciBtZXRob2RzIHdvdWxkIHByb2JhYmx5IGZhaWwsIGFzIHRoZXkgd291bGQgd2l0aCBib3VuZHMgaW5pdGlhbGl6ZWQgYnV0IG5vdCBleHRlbmRlZC5cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdF9yZXNldEJvdW5kczogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIGJvdW5kcyA9IHRoaXMuX2JvdW5kcztcblxuXHRcdFx0aWYgKGJvdW5kcy5fc291dGhXZXN0KSB7XG5cdFx0XHRcdGJvdW5kcy5fc291dGhXZXN0LmxhdCA9IEluZmluaXR5O1xuXHRcdFx0XHRib3VuZHMuX3NvdXRoV2VzdC5sbmcgPSBJbmZpbml0eTtcblx0XHRcdH1cblx0XHRcdGlmIChib3VuZHMuX25vcnRoRWFzdCkge1xuXHRcdFx0XHRib3VuZHMuX25vcnRoRWFzdC5sYXQgPSAtSW5maW5pdHk7XG5cdFx0XHRcdGJvdW5kcy5fbm9ydGhFYXN0LmxuZyA9IC1JbmZpbml0eTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0X3JlY2FsY3VsYXRlQm91bmRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgbWFya2VycyA9IHRoaXMuX21hcmtlcnMsXG5cdFx0XHQgICAgY2hpbGRDbHVzdGVycyA9IHRoaXMuX2NoaWxkQ2x1c3RlcnMsXG5cdFx0XHQgICAgbGF0U3VtID0gMCxcblx0XHRcdCAgICBsbmdTdW0gPSAwLFxuXHRcdFx0ICAgIHRvdGFsQ291bnQgPSB0aGlzLl9jaGlsZENvdW50LFxuXHRcdFx0ICAgIGksIGNoaWxkLCBjaGlsZExhdExuZywgY2hpbGRDb3VudDtcblxuXHRcdFx0Ly8gQ2FzZSB3aGVyZSBhbGwgbWFya2VycyBhcmUgcmVtb3ZlZCBmcm9tIHRoZSBtYXAgYW5kIHdlIGFyZSBsZWZ0IHdpdGgganVzdCBhbiBlbXB0eSBfdG9wQ2x1c3RlckxldmVsLlxuXHRcdFx0aWYgKHRvdGFsQ291bnQgPT09IDApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXNldCByYXRoZXIgdGhhbiBjcmVhdGluZyBhIG5ldyBvYmplY3QsIGZvciBwZXJmb3JtYW5jZS5cblx0XHRcdHRoaXMuX3Jlc2V0Qm91bmRzKCk7XG5cblx0XHRcdC8vIENoaWxkIG1hcmtlcnMuXG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbWFya2Vycy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRjaGlsZExhdExuZyA9IG1hcmtlcnNbaV0uX2xhdGxuZztcblxuXHRcdFx0XHR0aGlzLl9ib3VuZHMuZXh0ZW5kKGNoaWxkTGF0TG5nKTtcblxuXHRcdFx0XHRsYXRTdW0gKz0gY2hpbGRMYXRMbmcubGF0O1xuXHRcdFx0XHRsbmdTdW0gKz0gY2hpbGRMYXRMbmcubG5nO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDaGlsZCBjbHVzdGVycy5cblx0XHRcdGZvciAoaSA9IDA7IGkgPCBjaGlsZENsdXN0ZXJzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGNoaWxkID0gY2hpbGRDbHVzdGVyc1tpXTtcblxuXHRcdFx0XHQvLyBSZS1jb21wdXRlIGNoaWxkIGJvdW5kcyBhbmQgd2VpZ2h0ZWQgcG9zaXRpb24gZmlyc3QgaWYgbmVjZXNzYXJ5LlxuXHRcdFx0XHRpZiAoY2hpbGQuX2JvdW5kc05lZWRVcGRhdGUpIHtcblx0XHRcdFx0XHRjaGlsZC5fcmVjYWxjdWxhdGVCb3VuZHMoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuX2JvdW5kcy5leHRlbmQoY2hpbGQuX2JvdW5kcyk7XG5cblx0XHRcdFx0Y2hpbGRMYXRMbmcgPSBjaGlsZC5fd0xhdExuZztcblx0XHRcdFx0Y2hpbGRDb3VudCA9IGNoaWxkLl9jaGlsZENvdW50O1xuXG5cdFx0XHRcdGxhdFN1bSArPSBjaGlsZExhdExuZy5sYXQgKiBjaGlsZENvdW50O1xuXHRcdFx0XHRsbmdTdW0gKz0gY2hpbGRMYXRMbmcubG5nICogY2hpbGRDb3VudDtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fbGF0bG5nID0gdGhpcy5fd0xhdExuZyA9IG5ldyBMLkxhdExuZyhsYXRTdW0gLyB0b3RhbENvdW50LCBsbmdTdW0gLyB0b3RhbENvdW50KTtcblxuXHRcdFx0Ly8gUmVzZXQgZGlydHkgZmxhZy5cblx0XHRcdHRoaXMuX2JvdW5kc05lZWRVcGRhdGUgPSBmYWxzZTtcblx0XHR9LFxuXG5cdFx0Ly9TZXQgb3VyIG1hcmtlcnMgcG9zaXRpb24gYXMgZ2l2ZW4gYW5kIGFkZCBpdCB0byB0aGUgbWFwXG5cdFx0X2FkZFRvTWFwOiBmdW5jdGlvbiAoc3RhcnRQb3MpIHtcblx0XHRcdGlmIChzdGFydFBvcykge1xuXHRcdFx0XHR0aGlzLl9iYWNrdXBMYXRsbmcgPSB0aGlzLl9sYXRsbmc7XG5cdFx0XHRcdHRoaXMuc2V0TGF0TG5nKHN0YXJ0UG9zKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX2dyb3VwLl9mZWF0dXJlR3JvdXAuYWRkTGF5ZXIodGhpcyk7XG5cdFx0fSxcblxuXHRcdF9yZWN1cnNpdmVseUFuaW1hdGVDaGlsZHJlbkluOiBmdW5jdGlvbiAoYm91bmRzLCBjZW50ZXIsIG1heFpvb20pIHtcblx0XHRcdHRoaXMuX3JlY3Vyc2l2ZWx5KGJvdW5kcywgdGhpcy5fZ3JvdXAuX21hcC5nZXRNaW5ab29tKCksIG1heFpvb20gLSAxLFxuXHRcdFx0XHRmdW5jdGlvbiAoYykge1xuXHRcdFx0XHRcdHZhciBtYXJrZXJzID0gYy5fbWFya2Vycyxcblx0XHRcdFx0XHRcdGksIG07XG5cdFx0XHRcdFx0Zm9yIChpID0gbWFya2Vycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHRcdFx0bSA9IG1hcmtlcnNbaV07XG5cblx0XHRcdFx0XHRcdC8vT25seSBkbyBpdCBpZiB0aGUgaWNvbiBpcyBzdGlsbCBvbiB0aGUgbWFwXG5cdFx0XHRcdFx0XHRpZiAobS5faWNvbikge1xuXHRcdFx0XHRcdFx0XHRtLl9zZXRQb3MoY2VudGVyKTtcblx0XHRcdFx0XHRcdFx0bS5jbHVzdGVySGlkZSgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdFx0ZnVuY3Rpb24gKGMpIHtcblx0XHRcdFx0XHR2YXIgY2hpbGRDbHVzdGVycyA9IGMuX2NoaWxkQ2x1c3RlcnMsXG5cdFx0XHRcdFx0XHRqLCBjbTtcblx0XHRcdFx0XHRmb3IgKGogPSBjaGlsZENsdXN0ZXJzLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XG5cdFx0XHRcdFx0XHRjbSA9IGNoaWxkQ2x1c3RlcnNbal07XG5cdFx0XHRcdFx0XHRpZiAoY20uX2ljb24pIHtcblx0XHRcdFx0XHRcdFx0Y20uX3NldFBvcyhjZW50ZXIpO1xuXHRcdFx0XHRcdFx0XHRjbS5jbHVzdGVySGlkZSgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0KTtcblx0XHR9LFxuXG5cdFx0X3JlY3Vyc2l2ZWx5QW5pbWF0ZUNoaWxkcmVuSW5BbmRBZGRTZWxmVG9NYXA6IGZ1bmN0aW9uIChib3VuZHMsIG1hcE1pblpvb20sIHByZXZpb3VzWm9vbUxldmVsLCBuZXdab29tTGV2ZWwpIHtcblx0XHRcdHRoaXMuX3JlY3Vyc2l2ZWx5KGJvdW5kcywgbmV3Wm9vbUxldmVsLCBtYXBNaW5ab29tLFxuXHRcdFx0XHRmdW5jdGlvbiAoYykge1xuXHRcdFx0XHRcdGMuX3JlY3Vyc2l2ZWx5QW5pbWF0ZUNoaWxkcmVuSW4oYm91bmRzLCBjLl9ncm91cC5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludChjLmdldExhdExuZygpKS5yb3VuZCgpLCBwcmV2aW91c1pvb21MZXZlbCk7XG5cblx0XHRcdFx0XHQvL1RPRE86IGRlcHRoVG9BbmltYXRlSW4gYWZmZWN0cyBfaXNTaW5nbGVQYXJlbnQsIGlmIHRoZXJlIGlzIGEgbXVsdGl6b29tIHdlIG1heS9tYXkgbm90IGJlLlxuXHRcdFx0XHRcdC8vQXMgYSBoYWNrIHdlIG9ubHkgZG8gYSBhbmltYXRpb24gZnJlZSB6b29tIG9uIGEgc2luZ2xlIGxldmVsIHpvb20sIGlmIHNvbWVvbmUgZG9lcyBtdWx0aXBsZSBsZXZlbHMgdGhlbiB3ZSBhbHdheXMgYW5pbWF0ZVxuXHRcdFx0XHRcdGlmIChjLl9pc1NpbmdsZVBhcmVudCgpICYmIHByZXZpb3VzWm9vbUxldmVsIC0gMSA9PT0gbmV3Wm9vbUxldmVsKSB7XG5cdFx0XHRcdFx0XHRjLmNsdXN0ZXJTaG93KCk7XG5cdFx0XHRcdFx0XHRjLl9yZWN1cnNpdmVseVJlbW92ZUNoaWxkcmVuRnJvbU1hcChib3VuZHMsIG1hcE1pblpvb20sIHByZXZpb3VzWm9vbUxldmVsKTsgLy9JbW1lZGlhdGVseSByZW1vdmUgb3VyIGNoaWxkcmVuIGFzIHdlIGFyZSByZXBsYWNpbmcgdGhlbS4gVE9ETyBwcmV2aW91c0JvdW5kcyBub3QgYm91bmRzXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGMuY2x1c3RlckhpZGUoKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjLl9hZGRUb01hcCgpO1xuXHRcdFx0XHR9XG5cdFx0XHQpO1xuXHRcdH0sXG5cblx0XHRfcmVjdXJzaXZlbHlCZWNvbWVWaXNpYmxlOiBmdW5jdGlvbiAoYm91bmRzLCB6b29tTGV2ZWwpIHtcblx0XHRcdHRoaXMuX3JlY3Vyc2l2ZWx5KGJvdW5kcywgdGhpcy5fZ3JvdXAuX21hcC5nZXRNaW5ab29tKCksIHpvb21MZXZlbCwgbnVsbCwgZnVuY3Rpb24gKGMpIHtcblx0XHRcdFx0Yy5jbHVzdGVyU2hvdygpO1xuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdF9yZWN1cnNpdmVseUFkZENoaWxkcmVuVG9NYXA6IGZ1bmN0aW9uIChzdGFydFBvcywgem9vbUxldmVsLCBib3VuZHMpIHtcblx0XHRcdHRoaXMuX3JlY3Vyc2l2ZWx5KGJvdW5kcywgdGhpcy5fZ3JvdXAuX21hcC5nZXRNaW5ab29tKCkgLSAxLCB6b29tTGV2ZWwsXG5cdFx0XHRcdGZ1bmN0aW9uIChjKSB7XG5cdFx0XHRcdFx0aWYgKHpvb21MZXZlbCA9PT0gYy5fem9vbSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vQWRkIG91ciBjaGlsZCBtYXJrZXJzIGF0IHN0YXJ0UG9zIChzbyB0aGV5IGNhbiBiZSBhbmltYXRlZCBvdXQpXG5cdFx0XHRcdFx0Zm9yICh2YXIgaSA9IGMuX21hcmtlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0XHRcdHZhciBubSA9IGMuX21hcmtlcnNbaV07XG5cblx0XHRcdFx0XHRcdGlmICghYm91bmRzLmNvbnRhaW5zKG5tLl9sYXRsbmcpKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAoc3RhcnRQb3MpIHtcblx0XHRcdFx0XHRcdFx0bm0uX2JhY2t1cExhdGxuZyA9IG5tLmdldExhdExuZygpO1xuXG5cdFx0XHRcdFx0XHRcdG5tLnNldExhdExuZyhzdGFydFBvcyk7XG5cdFx0XHRcdFx0XHRcdGlmIChubS5jbHVzdGVySGlkZSkge1xuXHRcdFx0XHRcdFx0XHRcdG5tLmNsdXN0ZXJIaWRlKCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Yy5fZ3JvdXAuX2ZlYXR1cmVHcm91cC5hZGRMYXllcihubSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRmdW5jdGlvbiAoYykge1xuXHRcdFx0XHRcdGMuX2FkZFRvTWFwKHN0YXJ0UG9zKTtcblx0XHRcdFx0fVxuXHRcdFx0KTtcblx0XHR9LFxuXG5cdFx0X3JlY3Vyc2l2ZWx5UmVzdG9yZUNoaWxkUG9zaXRpb25zOiBmdW5jdGlvbiAoem9vbUxldmVsKSB7XG5cdFx0XHQvL0ZpeCBwb3NpdGlvbnMgb2YgY2hpbGQgbWFya2Vyc1xuXHRcdFx0Zm9yICh2YXIgaSA9IHRoaXMuX21hcmtlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0dmFyIG5tID0gdGhpcy5fbWFya2Vyc1tpXTtcblx0XHRcdFx0aWYgKG5tLl9iYWNrdXBMYXRsbmcpIHtcblx0XHRcdFx0XHRubS5zZXRMYXRMbmcobm0uX2JhY2t1cExhdGxuZyk7XG5cdFx0XHRcdFx0ZGVsZXRlIG5tLl9iYWNrdXBMYXRsbmc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKHpvb21MZXZlbCAtIDEgPT09IHRoaXMuX3pvb20pIHtcblx0XHRcdFx0Ly9SZXBvc2l0aW9uIGNoaWxkIGNsdXN0ZXJzXG5cdFx0XHRcdGZvciAodmFyIGogPSB0aGlzLl9jaGlsZENsdXN0ZXJzLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XG5cdFx0XHRcdFx0dGhpcy5fY2hpbGRDbHVzdGVyc1tqXS5fcmVzdG9yZVBvc2l0aW9uKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZvciAodmFyIGsgPSB0aGlzLl9jaGlsZENsdXN0ZXJzLmxlbmd0aCAtIDE7IGsgPj0gMDsgay0tKSB7XG5cdFx0XHRcdFx0dGhpcy5fY2hpbGRDbHVzdGVyc1trXS5fcmVjdXJzaXZlbHlSZXN0b3JlQ2hpbGRQb3NpdGlvbnMoem9vbUxldmVsKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRfcmVzdG9yZVBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAodGhpcy5fYmFja3VwTGF0bG5nKSB7XG5cdFx0XHRcdHRoaXMuc2V0TGF0TG5nKHRoaXMuX2JhY2t1cExhdGxuZyk7XG5cdFx0XHRcdGRlbGV0ZSB0aGlzLl9iYWNrdXBMYXRsbmc7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8vZXhjZXB0Qm91bmRzOiBJZiBzZXQsIGRvbid0IHJlbW92ZSBhbnkgbWFya2Vycy9jbHVzdGVycyBpbiBpdFxuXHRcdF9yZWN1cnNpdmVseVJlbW92ZUNoaWxkcmVuRnJvbU1hcDogZnVuY3Rpb24gKHByZXZpb3VzQm91bmRzLCBtYXBNaW5ab29tLCB6b29tTGV2ZWwsIGV4Y2VwdEJvdW5kcykge1xuXHRcdFx0dmFyIG0sIGk7XG5cdFx0XHR0aGlzLl9yZWN1cnNpdmVseShwcmV2aW91c0JvdW5kcywgbWFwTWluWm9vbSAtIDEsIHpvb21MZXZlbCAtIDEsXG5cdFx0XHRcdGZ1bmN0aW9uIChjKSB7XG5cdFx0XHRcdFx0Ly9SZW1vdmUgbWFya2VycyBhdCBldmVyeSBsZXZlbFxuXHRcdFx0XHRcdGZvciAoaSA9IGMuX21hcmtlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0XHRcdG0gPSBjLl9tYXJrZXJzW2ldO1xuXHRcdFx0XHRcdFx0aWYgKCFleGNlcHRCb3VuZHMgfHwgIWV4Y2VwdEJvdW5kcy5jb250YWlucyhtLl9sYXRsbmcpKSB7XG5cdFx0XHRcdFx0XHRcdGMuX2dyb3VwLl9mZWF0dXJlR3JvdXAucmVtb3ZlTGF5ZXIobSk7XG5cdFx0XHRcdFx0XHRcdGlmIChtLmNsdXN0ZXJTaG93KSB7XG5cdFx0XHRcdFx0XHRcdFx0bS5jbHVzdGVyU2hvdygpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRmdW5jdGlvbiAoYykge1xuXHRcdFx0XHRcdC8vUmVtb3ZlIGNoaWxkIGNsdXN0ZXJzIGF0IGp1c3QgdGhlIGJvdHRvbSBsZXZlbFxuXHRcdFx0XHRcdGZvciAoaSA9IGMuX2NoaWxkQ2x1c3RlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0XHRcdG0gPSBjLl9jaGlsZENsdXN0ZXJzW2ldO1xuXHRcdFx0XHRcdFx0aWYgKCFleGNlcHRCb3VuZHMgfHwgIWV4Y2VwdEJvdW5kcy5jb250YWlucyhtLl9sYXRsbmcpKSB7XG5cdFx0XHRcdFx0XHRcdGMuX2dyb3VwLl9mZWF0dXJlR3JvdXAucmVtb3ZlTGF5ZXIobSk7XG5cdFx0XHRcdFx0XHRcdGlmIChtLmNsdXN0ZXJTaG93KSB7XG5cdFx0XHRcdFx0XHRcdFx0bS5jbHVzdGVyU2hvdygpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHQpO1xuXHRcdH0sXG5cblx0XHQvL1J1biB0aGUgZ2l2ZW4gZnVuY3Rpb25zIHJlY3Vyc2l2ZWx5IHRvIHRoaXMgYW5kIGNoaWxkIGNsdXN0ZXJzXG5cdFx0Ly8gYm91bmRzVG9BcHBseVRvOiBhIEwuTGF0TG5nQm91bmRzIHJlcHJlc2VudGluZyB0aGUgYm91bmRzIG9mIHdoYXQgY2x1c3RlcnMgdG8gcmVjdXJzZSBpbiB0b1xuXHRcdC8vIHpvb21MZXZlbFRvU3RhcnQ6IHpvb20gbGV2ZWwgdG8gc3RhcnQgcnVubmluZyBmdW5jdGlvbnMgKGluY2x1c2l2ZSlcblx0XHQvLyB6b29tTGV2ZWxUb1N0b3A6IHpvb20gbGV2ZWwgdG8gc3RvcCBydW5uaW5nIGZ1bmN0aW9ucyAoaW5jbHVzaXZlKVxuXHRcdC8vIHJ1bkF0RXZlcnlMZXZlbDogZnVuY3Rpb24gdGhhdCB0YWtlcyBhbiBMLk1hcmtlckNsdXN0ZXIgYXMgYW4gYXJndW1lbnQgdGhhdCBzaG91bGQgYmUgYXBwbGllZCBvbiBldmVyeSBsZXZlbFxuXHRcdC8vIHJ1bkF0Qm90dG9tTGV2ZWw6IGZ1bmN0aW9uIHRoYXQgdGFrZXMgYW4gTC5NYXJrZXJDbHVzdGVyIGFzIGFuIGFyZ3VtZW50IHRoYXQgc2hvdWxkIGJlIGFwcGxpZWQgYXQgb25seSB0aGUgYm90dG9tIGxldmVsXG5cdFx0X3JlY3Vyc2l2ZWx5OiBmdW5jdGlvbiAoYm91bmRzVG9BcHBseVRvLCB6b29tTGV2ZWxUb1N0YXJ0LCB6b29tTGV2ZWxUb1N0b3AsIHJ1bkF0RXZlcnlMZXZlbCwgcnVuQXRCb3R0b21MZXZlbCkge1xuXHRcdFx0dmFyIGNoaWxkQ2x1c3RlcnMgPSB0aGlzLl9jaGlsZENsdXN0ZXJzLFxuXHRcdFx0ICAgIHpvb20gPSB0aGlzLl96b29tLFxuXHRcdFx0ICAgIGksIGM7XG5cblx0XHRcdGlmICh6b29tTGV2ZWxUb1N0YXJ0IDw9IHpvb20pIHtcblx0XHRcdFx0aWYgKHJ1bkF0RXZlcnlMZXZlbCkge1xuXHRcdFx0XHRcdHJ1bkF0RXZlcnlMZXZlbCh0aGlzKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocnVuQXRCb3R0b21MZXZlbCAmJiB6b29tID09PSB6b29tTGV2ZWxUb1N0b3ApIHtcblx0XHRcdFx0XHRydW5BdEJvdHRvbUxldmVsKHRoaXMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICh6b29tIDwgem9vbUxldmVsVG9TdGFydCB8fCB6b29tIDwgem9vbUxldmVsVG9TdG9wKSB7XG5cdFx0XHRcdGZvciAoaSA9IGNoaWxkQ2x1c3RlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0XHRjID0gY2hpbGRDbHVzdGVyc1tpXTtcblx0XHRcdFx0XHRpZiAoYy5fYm91bmRzTmVlZFVwZGF0ZSkge1xuXHRcdFx0XHRcdFx0Yy5fcmVjYWxjdWxhdGVCb3VuZHMoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKGJvdW5kc1RvQXBwbHlUby5pbnRlcnNlY3RzKGMuX2JvdW5kcykpIHtcblx0XHRcdFx0XHRcdGMuX3JlY3Vyc2l2ZWx5KGJvdW5kc1RvQXBwbHlUbywgem9vbUxldmVsVG9TdGFydCwgem9vbUxldmVsVG9TdG9wLCBydW5BdEV2ZXJ5TGV2ZWwsIHJ1bkF0Qm90dG9tTGV2ZWwpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvL1JldHVybnMgdHJ1ZSBpZiB3ZSBhcmUgdGhlIHBhcmVudCBvZiBvbmx5IG9uZSBjbHVzdGVyIGFuZCB0aGF0IGNsdXN0ZXIgaXMgdGhlIHNhbWUgYXMgdXNcblx0XHRfaXNTaW5nbGVQYXJlbnQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdC8vRG9uJ3QgbmVlZCB0byBjaGVjayB0aGlzLl9tYXJrZXJzIGFzIHRoZSByZXN0IHdvbid0IHdvcmsgaWYgdGhlcmUgYXJlIGFueVxuXHRcdFx0cmV0dXJuIHRoaXMuX2NoaWxkQ2x1c3RlcnMubGVuZ3RoID4gMCAmJiB0aGlzLl9jaGlsZENsdXN0ZXJzWzBdLl9jaGlsZENvdW50ID09PSB0aGlzLl9jaGlsZENvdW50O1xuXHRcdH1cblx0fSk7XG5cblx0Lypcblx0KiBFeHRlbmRzIEwuTWFya2VyIHRvIGluY2x1ZGUgdHdvIGV4dHJhIG1ldGhvZHM6IGNsdXN0ZXJIaWRlIGFuZCBjbHVzdGVyU2hvdy5cblx0KiBcblx0KiBUaGV5IHdvcmsgYXMgc2V0T3BhY2l0eSgwKSBhbmQgc2V0T3BhY2l0eSgxKSByZXNwZWN0aXZlbHksIGJ1dFxuXHQqIGRvbid0IG92ZXJ3cml0ZSB0aGUgb3B0aW9ucy5vcGFjaXR5XG5cdCogXG5cdCovXG5cblx0TC5NYXJrZXIuaW5jbHVkZSh7XG5cdFx0Y2x1c3RlckhpZGU6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBiYWNrdXAgPSB0aGlzLm9wdGlvbnMub3BhY2l0eTtcblx0XHRcdHRoaXMuc2V0T3BhY2l0eSgwKTtcblx0XHRcdHRoaXMub3B0aW9ucy5vcGFjaXR5ID0gYmFja3VwO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSxcblx0XHRcblx0XHRjbHVzdGVyU2hvdzogZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuc2V0T3BhY2l0eSh0aGlzLm9wdGlvbnMub3BhY2l0eSk7XG5cdFx0fVxuXHR9KTtcblxuXHRMLkRpc3RhbmNlR3JpZCA9IGZ1bmN0aW9uIChjZWxsU2l6ZSkge1xuXHRcdHRoaXMuX2NlbGxTaXplID0gY2VsbFNpemU7XG5cdFx0dGhpcy5fc3FDZWxsU2l6ZSA9IGNlbGxTaXplICogY2VsbFNpemU7XG5cdFx0dGhpcy5fZ3JpZCA9IHt9O1xuXHRcdHRoaXMuX29iamVjdFBvaW50ID0geyB9O1xuXHR9O1xuXG5cdEwuRGlzdGFuY2VHcmlkLnByb3RvdHlwZSA9IHtcblxuXHRcdGFkZE9iamVjdDogZnVuY3Rpb24gKG9iaiwgcG9pbnQpIHtcblx0XHRcdHZhciB4ID0gdGhpcy5fZ2V0Q29vcmQocG9pbnQueCksXG5cdFx0XHQgICAgeSA9IHRoaXMuX2dldENvb3JkKHBvaW50LnkpLFxuXHRcdFx0ICAgIGdyaWQgPSB0aGlzLl9ncmlkLFxuXHRcdFx0ICAgIHJvdyA9IGdyaWRbeV0gPSBncmlkW3ldIHx8IHt9LFxuXHRcdFx0ICAgIGNlbGwgPSByb3dbeF0gPSByb3dbeF0gfHwgW10sXG5cdFx0XHQgICAgc3RhbXAgPSBMLlV0aWwuc3RhbXAob2JqKTtcblxuXHRcdFx0dGhpcy5fb2JqZWN0UG9pbnRbc3RhbXBdID0gcG9pbnQ7XG5cblx0XHRcdGNlbGwucHVzaChvYmopO1xuXHRcdH0sXG5cblx0XHR1cGRhdGVPYmplY3Q6IGZ1bmN0aW9uIChvYmosIHBvaW50KSB7XG5cdFx0XHR0aGlzLnJlbW92ZU9iamVjdChvYmopO1xuXHRcdFx0dGhpcy5hZGRPYmplY3Qob2JqLCBwb2ludCk7XG5cdFx0fSxcblxuXHRcdC8vUmV0dXJucyB0cnVlIGlmIHRoZSBvYmplY3Qgd2FzIGZvdW5kXG5cdFx0cmVtb3ZlT2JqZWN0OiBmdW5jdGlvbiAob2JqLCBwb2ludCkge1xuXHRcdFx0dmFyIHggPSB0aGlzLl9nZXRDb29yZChwb2ludC54KSxcblx0XHRcdCAgICB5ID0gdGhpcy5fZ2V0Q29vcmQocG9pbnQueSksXG5cdFx0XHQgICAgZ3JpZCA9IHRoaXMuX2dyaWQsXG5cdFx0XHQgICAgcm93ID0gZ3JpZFt5XSA9IGdyaWRbeV0gfHwge30sXG5cdFx0XHQgICAgY2VsbCA9IHJvd1t4XSA9IHJvd1t4XSB8fCBbXSxcblx0XHRcdCAgICBpLCBsZW47XG5cblx0XHRcdGRlbGV0ZSB0aGlzLl9vYmplY3RQb2ludFtMLlV0aWwuc3RhbXAob2JqKV07XG5cblx0XHRcdGZvciAoaSA9IDAsIGxlbiA9IGNlbGwubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0aWYgKGNlbGxbaV0gPT09IG9iaikge1xuXG5cdFx0XHRcdFx0Y2VsbC5zcGxpY2UoaSwgMSk7XG5cblx0XHRcdFx0XHRpZiAobGVuID09PSAxKSB7XG5cdFx0XHRcdFx0XHRkZWxldGUgcm93W3hdO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHR9LFxuXG5cdFx0ZWFjaE9iamVjdDogZnVuY3Rpb24gKGZuLCBjb250ZXh0KSB7XG5cdFx0XHR2YXIgaSwgaiwgaywgbGVuLCByb3csIGNlbGwsIHJlbW92ZWQsXG5cdFx0XHQgICAgZ3JpZCA9IHRoaXMuX2dyaWQ7XG5cblx0XHRcdGZvciAoaSBpbiBncmlkKSB7XG5cdFx0XHRcdHJvdyA9IGdyaWRbaV07XG5cblx0XHRcdFx0Zm9yIChqIGluIHJvdykge1xuXHRcdFx0XHRcdGNlbGwgPSByb3dbal07XG5cblx0XHRcdFx0XHRmb3IgKGsgPSAwLCBsZW4gPSBjZWxsLmxlbmd0aDsgayA8IGxlbjsgaysrKSB7XG5cdFx0XHRcdFx0XHRyZW1vdmVkID0gZm4uY2FsbChjb250ZXh0LCBjZWxsW2tdKTtcblx0XHRcdFx0XHRcdGlmIChyZW1vdmVkKSB7XG5cdFx0XHRcdFx0XHRcdGstLTtcblx0XHRcdFx0XHRcdFx0bGVuLS07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGdldE5lYXJPYmplY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xuXHRcdFx0dmFyIHggPSB0aGlzLl9nZXRDb29yZChwb2ludC54KSxcblx0XHRcdCAgICB5ID0gdGhpcy5fZ2V0Q29vcmQocG9pbnQueSksXG5cdFx0XHQgICAgaSwgaiwgaywgcm93LCBjZWxsLCBsZW4sIG9iaiwgZGlzdCxcblx0XHRcdCAgICBvYmplY3RQb2ludCA9IHRoaXMuX29iamVjdFBvaW50LFxuXHRcdFx0ICAgIGNsb3Nlc3REaXN0U3EgPSB0aGlzLl9zcUNlbGxTaXplLFxuXHRcdFx0ICAgIGNsb3Nlc3QgPSBudWxsO1xuXG5cdFx0XHRmb3IgKGkgPSB5IC0gMTsgaSA8PSB5ICsgMTsgaSsrKSB7XG5cdFx0XHRcdHJvdyA9IHRoaXMuX2dyaWRbaV07XG5cdFx0XHRcdGlmIChyb3cpIHtcblxuXHRcdFx0XHRcdGZvciAoaiA9IHggLSAxOyBqIDw9IHggKyAxOyBqKyspIHtcblx0XHRcdFx0XHRcdGNlbGwgPSByb3dbal07XG5cdFx0XHRcdFx0XHRpZiAoY2VsbCkge1xuXG5cdFx0XHRcdFx0XHRcdGZvciAoayA9IDAsIGxlbiA9IGNlbGwubGVuZ3RoOyBrIDwgbGVuOyBrKyspIHtcblx0XHRcdFx0XHRcdFx0XHRvYmogPSBjZWxsW2tdO1xuXHRcdFx0XHRcdFx0XHRcdGRpc3QgPSB0aGlzLl9zcURpc3Qob2JqZWN0UG9pbnRbTC5VdGlsLnN0YW1wKG9iaildLCBwb2ludCk7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGRpc3QgPCBjbG9zZXN0RGlzdFNxIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHRkaXN0IDw9IGNsb3Nlc3REaXN0U3EgJiYgY2xvc2VzdCA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y2xvc2VzdERpc3RTcSA9IGRpc3Q7XG5cdFx0XHRcdFx0XHRcdFx0XHRjbG9zZXN0ID0gb2JqO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGNsb3Nlc3Q7XG5cdFx0fSxcblxuXHRcdF9nZXRDb29yZDogZnVuY3Rpb24gKHgpIHtcblx0XHRcdHZhciBjb29yZCA9IE1hdGguZmxvb3IoeCAvIHRoaXMuX2NlbGxTaXplKTtcblx0XHRcdHJldHVybiBpc0Zpbml0ZShjb29yZCkgPyBjb29yZCA6IHg7XG5cdFx0fSxcblxuXHRcdF9zcURpc3Q6IGZ1bmN0aW9uIChwLCBwMikge1xuXHRcdFx0dmFyIGR4ID0gcDIueCAtIHAueCxcblx0XHRcdCAgICBkeSA9IHAyLnkgLSBwLnk7XG5cdFx0XHRyZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIENvcHlyaWdodCAoYykgMjAxMiB0aGUgYXV0aG9ycyBsaXN0ZWQgYXQgdGhlIGZvbGxvd2luZyBVUkwsIGFuZC9vclxuXHR0aGUgYXV0aG9ycyBvZiByZWZlcmVuY2VkIGFydGljbGVzIG9yIGluY29ycG9yYXRlZCBleHRlcm5hbCBjb2RlOlxuXHRodHRwOi8vZW4ubGl0ZXJhdGVwcm9ncmFtcy5vcmcvUXVpY2todWxsXyhKYXZhc2NyaXB0KT9hY3Rpb249aGlzdG9yeSZvZmZzZXQ9MjAxMjA0MTAxNzUyNTZcblxuXHRQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmdcblx0YSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG5cdFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuXHR3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG5cdGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xuXHRwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG9cblx0dGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5cdFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG5cdGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5cdFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG5cdEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuXHRNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuXG5cdElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZXG5cdENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsXG5cdFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFXG5cdFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5cdFJldHJpZXZlZCBmcm9tOiBodHRwOi8vZW4ubGl0ZXJhdGVwcm9ncmFtcy5vcmcvUXVpY2todWxsXyhKYXZhc2NyaXB0KT9vbGRpZD0xODQzNFxuXHQqL1xuXG5cdChmdW5jdGlvbiAoKSB7XG5cdFx0TC5RdWlja0h1bGwgPSB7XG5cblx0XHRcdC8qXG5cdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gY3B0IGEgcG9pbnQgdG8gYmUgbWVhc3VyZWQgZnJvbSB0aGUgYmFzZWxpbmVcblx0XHRcdCAqIEBwYXJhbSB7QXJyYXl9IGJsIHRoZSBiYXNlbGluZSwgYXMgcmVwcmVzZW50ZWQgYnkgYSB0d28tZWxlbWVudFxuXHRcdFx0ICogICBhcnJheSBvZiBsYXRsbmcgb2JqZWN0cy5cblx0XHRcdCAqIEByZXR1cm5zIHtOdW1iZXJ9IGFuIGFwcHJveGltYXRlIGRpc3RhbmNlIG1lYXN1cmVcblx0XHRcdCAqL1xuXHRcdFx0Z2V0RGlzdGFudDogZnVuY3Rpb24gKGNwdCwgYmwpIHtcblx0XHRcdFx0dmFyIHZZID0gYmxbMV0ubGF0IC0gYmxbMF0ubGF0LFxuXHRcdFx0XHRcdHZYID0gYmxbMF0ubG5nIC0gYmxbMV0ubG5nO1xuXHRcdFx0XHRyZXR1cm4gKHZYICogKGNwdC5sYXQgLSBibFswXS5sYXQpICsgdlkgKiAoY3B0LmxuZyAtIGJsWzBdLmxuZykpO1xuXHRcdFx0fSxcblxuXHRcdFx0Lypcblx0XHRcdCAqIEBwYXJhbSB7QXJyYXl9IGJhc2VMaW5lIGEgdHdvLWVsZW1lbnQgYXJyYXkgb2YgbGF0bG5nIG9iamVjdHNcblx0XHRcdCAqICAgcmVwcmVzZW50aW5nIHRoZSBiYXNlbGluZSB0byBwcm9qZWN0IGZyb21cblx0XHRcdCAqIEBwYXJhbSB7QXJyYXl9IGxhdExuZ3MgYW4gYXJyYXkgb2YgbGF0bG5nIG9iamVjdHNcblx0XHRcdCAqIEByZXR1cm5zIHtPYmplY3R9IHRoZSBtYXhpbXVtIHBvaW50IGFuZCBhbGwgbmV3IHBvaW50cyB0byBzdGF5XG5cdFx0XHQgKiAgIGluIGNvbnNpZGVyYXRpb24gZm9yIHRoZSBodWxsLlxuXHRcdFx0ICovXG5cdFx0XHRmaW5kTW9zdERpc3RhbnRQb2ludEZyb21CYXNlTGluZTogZnVuY3Rpb24gKGJhc2VMaW5lLCBsYXRMbmdzKSB7XG5cdFx0XHRcdHZhciBtYXhEID0gMCxcblx0XHRcdFx0XHRtYXhQdCA9IG51bGwsXG5cdFx0XHRcdFx0bmV3UG9pbnRzID0gW10sXG5cdFx0XHRcdFx0aSwgcHQsIGQ7XG5cblx0XHRcdFx0Zm9yIChpID0gbGF0TG5ncy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHRcdHB0ID0gbGF0TG5nc1tpXTtcblx0XHRcdFx0XHRkID0gdGhpcy5nZXREaXN0YW50KHB0LCBiYXNlTGluZSk7XG5cblx0XHRcdFx0XHRpZiAoZCA+IDApIHtcblx0XHRcdFx0XHRcdG5ld1BvaW50cy5wdXNoKHB0KTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKGQgPiBtYXhEKSB7XG5cdFx0XHRcdFx0XHRtYXhEID0gZDtcblx0XHRcdFx0XHRcdG1heFB0ID0gcHQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHsgbWF4UG9pbnQ6IG1heFB0LCBuZXdQb2ludHM6IG5ld1BvaW50cyB9O1xuXHRcdFx0fSxcblxuXG5cdFx0XHQvKlxuXHRcdFx0ICogR2l2ZW4gYSBiYXNlbGluZSwgY29tcHV0ZSB0aGUgY29udmV4IGh1bGwgb2YgbGF0TG5ncyBhcyBhbiBhcnJheVxuXHRcdFx0ICogb2YgbGF0TG5ncy5cblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW0ge0FycmF5fSBsYXRMbmdzXG5cdFx0XHQgKiBAcmV0dXJucyB7QXJyYXl9XG5cdFx0XHQgKi9cblx0XHRcdGJ1aWxkQ29udmV4SHVsbDogZnVuY3Rpb24gKGJhc2VMaW5lLCBsYXRMbmdzKSB7XG5cdFx0XHRcdHZhciBjb252ZXhIdWxsQmFzZUxpbmVzID0gW10sXG5cdFx0XHRcdFx0dCA9IHRoaXMuZmluZE1vc3REaXN0YW50UG9pbnRGcm9tQmFzZUxpbmUoYmFzZUxpbmUsIGxhdExuZ3MpO1xuXG5cdFx0XHRcdGlmICh0Lm1heFBvaW50KSB7IC8vIGlmIHRoZXJlIGlzIHN0aWxsIGEgcG9pbnQgXCJvdXRzaWRlXCIgdGhlIGJhc2UgbGluZVxuXHRcdFx0XHRcdGNvbnZleEh1bGxCYXNlTGluZXMgPVxuXHRcdFx0XHRcdFx0Y29udmV4SHVsbEJhc2VMaW5lcy5jb25jYXQoXG5cdFx0XHRcdFx0XHRcdHRoaXMuYnVpbGRDb252ZXhIdWxsKFtiYXNlTGluZVswXSwgdC5tYXhQb2ludF0sIHQubmV3UG9pbnRzKVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRjb252ZXhIdWxsQmFzZUxpbmVzID1cblx0XHRcdFx0XHRcdGNvbnZleEh1bGxCYXNlTGluZXMuY29uY2F0KFxuXHRcdFx0XHRcdFx0XHR0aGlzLmJ1aWxkQ29udmV4SHVsbChbdC5tYXhQb2ludCwgYmFzZUxpbmVbMV1dLCB0Lm5ld1BvaW50cylcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0cmV0dXJuIGNvbnZleEh1bGxCYXNlTGluZXM7XG5cdFx0XHRcdH0gZWxzZSB7ICAvLyBpZiB0aGVyZSBpcyBubyBtb3JlIHBvaW50IFwib3V0c2lkZVwiIHRoZSBiYXNlIGxpbmUsIHRoZSBjdXJyZW50IGJhc2UgbGluZSBpcyBwYXJ0IG9mIHRoZSBjb252ZXggaHVsbFxuXHRcdFx0XHRcdHJldHVybiBbYmFzZUxpbmVbMF1dO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHQvKlxuXHRcdFx0ICogR2l2ZW4gYW4gYXJyYXkgb2YgbGF0bG5ncywgY29tcHV0ZSBhIGNvbnZleCBodWxsIGFzIGFuIGFycmF5XG5cdFx0XHQgKiBvZiBsYXRsbmdzXG5cdFx0XHQgKlxuXHRcdFx0ICogQHBhcmFtIHtBcnJheX0gbGF0TG5nc1xuXHRcdFx0ICogQHJldHVybnMge0FycmF5fVxuXHRcdFx0ICovXG5cdFx0XHRnZXRDb252ZXhIdWxsOiBmdW5jdGlvbiAobGF0TG5ncykge1xuXHRcdFx0XHQvLyBmaW5kIGZpcnN0IGJhc2VsaW5lXG5cdFx0XHRcdHZhciBtYXhMYXQgPSBmYWxzZSwgbWluTGF0ID0gZmFsc2UsXG5cdFx0XHRcdFx0bWF4TG5nID0gZmFsc2UsIG1pbkxuZyA9IGZhbHNlLFxuXHRcdFx0XHRcdG1heExhdFB0ID0gbnVsbCwgbWluTGF0UHQgPSBudWxsLFxuXHRcdFx0XHRcdG1heExuZ1B0ID0gbnVsbCwgbWluTG5nUHQgPSBudWxsLFxuXHRcdFx0XHRcdG1heFB0ID0gbnVsbCwgbWluUHQgPSBudWxsLFxuXHRcdFx0XHRcdGk7XG5cblx0XHRcdFx0Zm9yIChpID0gbGF0TG5ncy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHRcdHZhciBwdCA9IGxhdExuZ3NbaV07XG5cdFx0XHRcdFx0aWYgKG1heExhdCA9PT0gZmFsc2UgfHwgcHQubGF0ID4gbWF4TGF0KSB7XG5cdFx0XHRcdFx0XHRtYXhMYXRQdCA9IHB0O1xuXHRcdFx0XHRcdFx0bWF4TGF0ID0gcHQubGF0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAobWluTGF0ID09PSBmYWxzZSB8fCBwdC5sYXQgPCBtaW5MYXQpIHtcblx0XHRcdFx0XHRcdG1pbkxhdFB0ID0gcHQ7XG5cdFx0XHRcdFx0XHRtaW5MYXQgPSBwdC5sYXQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChtYXhMbmcgPT09IGZhbHNlIHx8IHB0LmxuZyA+IG1heExuZykge1xuXHRcdFx0XHRcdFx0bWF4TG5nUHQgPSBwdDtcblx0XHRcdFx0XHRcdG1heExuZyA9IHB0LmxuZztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKG1pbkxuZyA9PT0gZmFsc2UgfHwgcHQubG5nIDwgbWluTG5nKSB7XG5cdFx0XHRcdFx0XHRtaW5MbmdQdCA9IHB0O1xuXHRcdFx0XHRcdFx0bWluTG5nID0gcHQubG5nO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0aWYgKG1pbkxhdCAhPT0gbWF4TGF0KSB7XG5cdFx0XHRcdFx0bWluUHQgPSBtaW5MYXRQdDtcblx0XHRcdFx0XHRtYXhQdCA9IG1heExhdFB0O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG1pblB0ID0gbWluTG5nUHQ7XG5cdFx0XHRcdFx0bWF4UHQgPSBtYXhMbmdQdDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBjaCA9IFtdLmNvbmNhdCh0aGlzLmJ1aWxkQ29udmV4SHVsbChbbWluUHQsIG1heFB0XSwgbGF0TG5ncyksXG5cdFx0XHRcdFx0XHRcdFx0XHR0aGlzLmJ1aWxkQ29udmV4SHVsbChbbWF4UHQsIG1pblB0XSwgbGF0TG5ncykpO1xuXHRcdFx0XHRyZXR1cm4gY2g7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSgpKTtcblxuXHRMLk1hcmtlckNsdXN0ZXIuaW5jbHVkZSh7XG5cdFx0Z2V0Q29udmV4SHVsbDogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIGNoaWxkTWFya2VycyA9IHRoaXMuZ2V0QWxsQ2hpbGRNYXJrZXJzKCksXG5cdFx0XHRcdHBvaW50cyA9IFtdLFxuXHRcdFx0XHRwLCBpO1xuXG5cdFx0XHRmb3IgKGkgPSBjaGlsZE1hcmtlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0cCA9IGNoaWxkTWFya2Vyc1tpXS5nZXRMYXRMbmcoKTtcblx0XHRcdFx0cG9pbnRzLnB1c2gocCk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBMLlF1aWNrSHVsbC5nZXRDb252ZXhIdWxsKHBvaW50cyk7XG5cdFx0fVxuXHR9KTtcblxuXHQvL1RoaXMgY29kZSBpcyAxMDAlIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9qYXdqL092ZXJsYXBwaW5nTWFya2VyU3BpZGVyZmllci1MZWFmbGV0XG5cdC8vSHVnZSB0aGFua3MgdG8gamF3aiBmb3IgaW1wbGVtZW50aW5nIGl0IGZpcnN0IHRvIG1ha2UgbXkgam9iIGVhc3kgOi0pXG5cblx0TC5NYXJrZXJDbHVzdGVyLmluY2x1ZGUoe1xuXG5cdFx0XzJQSTogTWF0aC5QSSAqIDIsXG5cdFx0X2NpcmNsZUZvb3RTZXBhcmF0aW9uOiAyNSwgLy9yZWxhdGVkIHRvIGNpcmN1bWZlcmVuY2Ugb2YgY2lyY2xlXG5cdFx0X2NpcmNsZVN0YXJ0QW5nbGU6IDAsXG5cblx0XHRfc3BpcmFsRm9vdFNlcGFyYXRpb246ICAyOCwgLy9yZWxhdGVkIHRvIHNpemUgb2Ygc3BpcmFsIChleHBlcmltZW50ISlcblx0XHRfc3BpcmFsTGVuZ3RoU3RhcnQ6IDExLFxuXHRcdF9zcGlyYWxMZW5ndGhGYWN0b3I6IDUsXG5cblx0XHRfY2lyY2xlU3BpcmFsU3dpdGNob3ZlcjogOSwgLy9zaG93IHNwaXJhbCBpbnN0ZWFkIG9mIGNpcmNsZSBmcm9tIHRoaXMgbWFya2VyIGNvdW50IHVwd2FyZHMuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyAwIC0+IGFsd2F5cyBzcGlyYWw7IEluZmluaXR5IC0+IGFsd2F5cyBjaXJjbGVcblxuXHRcdHNwaWRlcmZ5OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAodGhpcy5fZ3JvdXAuX3NwaWRlcmZpZWQgPT09IHRoaXMgfHwgdGhpcy5fZ3JvdXAuX2luWm9vbUFuaW1hdGlvbikge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHZhciBjaGlsZE1hcmtlcnMgPSB0aGlzLmdldEFsbENoaWxkTWFya2VycyhudWxsLCB0cnVlKSxcblx0XHRcdFx0Z3JvdXAgPSB0aGlzLl9ncm91cCxcblx0XHRcdFx0bWFwID0gZ3JvdXAuX21hcCxcblx0XHRcdFx0Y2VudGVyID0gbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcpLFxuXHRcdFx0XHRwb3NpdGlvbnM7XG5cblx0XHRcdHRoaXMuX2dyb3VwLl91bnNwaWRlcmZ5KCk7XG5cdFx0XHR0aGlzLl9ncm91cC5fc3BpZGVyZmllZCA9IHRoaXM7XG5cblx0XHRcdC8vVE9ETyBNYXliZTogY2hpbGRNYXJrZXJzIG9yZGVyIGJ5IGRpc3RhbmNlIHRvIGNlbnRlclxuXG5cdFx0XHRpZiAodGhpcy5fZ3JvdXAub3B0aW9ucy5zcGlkZXJmeVNoYXBlUG9zaXRpb25zKSB7XG5cdFx0XHRcdHBvc2l0aW9ucyA9IHRoaXMuX2dyb3VwLm9wdGlvbnMuc3BpZGVyZnlTaGFwZVBvc2l0aW9ucyhjaGlsZE1hcmtlcnMubGVuZ3RoLCBjZW50ZXIpO1xuXHRcdFx0fSBlbHNlIGlmIChjaGlsZE1hcmtlcnMubGVuZ3RoID49IHRoaXMuX2NpcmNsZVNwaXJhbFN3aXRjaG92ZXIpIHtcblx0XHRcdFx0cG9zaXRpb25zID0gdGhpcy5fZ2VuZXJhdGVQb2ludHNTcGlyYWwoY2hpbGRNYXJrZXJzLmxlbmd0aCwgY2VudGVyKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNlbnRlci55ICs9IDEwOyAvLyBPdGhlcndpc2UgY2lyY2xlcyBsb29rIHdyb25nID0+IGhhY2sgZm9yIHN0YW5kYXJkIGJsdWUgaWNvbiwgcmVuZGVycyBkaWZmZXJlbnRseSBmb3Igb3RoZXIgaWNvbnMuXG5cdFx0XHRcdHBvc2l0aW9ucyA9IHRoaXMuX2dlbmVyYXRlUG9pbnRzQ2lyY2xlKGNoaWxkTWFya2Vycy5sZW5ndGgsIGNlbnRlcik7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX2FuaW1hdGlvblNwaWRlcmZ5KGNoaWxkTWFya2VycywgcG9zaXRpb25zKTtcblx0XHR9LFxuXG5cdFx0dW5zcGlkZXJmeTogZnVuY3Rpb24gKHpvb21EZXRhaWxzKSB7XG5cdFx0XHQvLy8gPHBhcmFtIE5hbWU9XCJ6b29tRGV0YWlsc1wiPkFyZ3VtZW50IGZyb20gem9vbWFuaW0gaWYgYmVpbmcgY2FsbGVkIGluIGEgem9vbSBhbmltYXRpb24gb3IgbnVsbCBvdGhlcndpc2U8L3BhcmFtPlxuXHRcdFx0aWYgKHRoaXMuX2dyb3VwLl9pblpvb21BbmltYXRpb24pIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fYW5pbWF0aW9uVW5zcGlkZXJmeSh6b29tRGV0YWlscyk7XG5cblx0XHRcdHRoaXMuX2dyb3VwLl9zcGlkZXJmaWVkID0gbnVsbDtcblx0XHR9LFxuXG5cdFx0X2dlbmVyYXRlUG9pbnRzQ2lyY2xlOiBmdW5jdGlvbiAoY291bnQsIGNlbnRlclB0KSB7XG5cdFx0XHR2YXIgY2lyY3VtZmVyZW5jZSA9IHRoaXMuX2dyb3VwLm9wdGlvbnMuc3BpZGVyZnlEaXN0YW5jZU11bHRpcGxpZXIgKiB0aGlzLl9jaXJjbGVGb290U2VwYXJhdGlvbiAqICgyICsgY291bnQpLFxuXHRcdFx0XHRsZWdMZW5ndGggPSBjaXJjdW1mZXJlbmNlIC8gdGhpcy5fMlBJLCAgLy9yYWRpdXMgZnJvbSBjaXJjdW1mZXJlbmNlXG5cdFx0XHRcdGFuZ2xlU3RlcCA9IHRoaXMuXzJQSSAvIGNvdW50LFxuXHRcdFx0XHRyZXMgPSBbXSxcblx0XHRcdFx0aSwgYW5nbGU7XG5cblx0XHRcdGxlZ0xlbmd0aCA9IE1hdGgubWF4KGxlZ0xlbmd0aCwgMzUpOyAvLyBNaW5pbXVtIGRpc3RhbmNlIHRvIGdldCBvdXRzaWRlIHRoZSBjbHVzdGVyIGljb24uXG5cblx0XHRcdHJlcy5sZW5ndGggPSBjb3VudDtcblxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGNvdW50OyBpKyspIHsgLy8gQ2xvY2t3aXNlLCBsaWtlIHNwaXJhbC5cblx0XHRcdFx0YW5nbGUgPSB0aGlzLl9jaXJjbGVTdGFydEFuZ2xlICsgaSAqIGFuZ2xlU3RlcDtcblx0XHRcdFx0cmVzW2ldID0gbmV3IEwuUG9pbnQoY2VudGVyUHQueCArIGxlZ0xlbmd0aCAqIE1hdGguY29zKGFuZ2xlKSwgY2VudGVyUHQueSArIGxlZ0xlbmd0aCAqIE1hdGguc2luKGFuZ2xlKSkuX3JvdW5kKCk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiByZXM7XG5cdFx0fSxcblxuXHRcdF9nZW5lcmF0ZVBvaW50c1NwaXJhbDogZnVuY3Rpb24gKGNvdW50LCBjZW50ZXJQdCkge1xuXHRcdFx0dmFyIHNwaWRlcmZ5RGlzdGFuY2VNdWx0aXBsaWVyID0gdGhpcy5fZ3JvdXAub3B0aW9ucy5zcGlkZXJmeURpc3RhbmNlTXVsdGlwbGllcixcblx0XHRcdFx0bGVnTGVuZ3RoID0gc3BpZGVyZnlEaXN0YW5jZU11bHRpcGxpZXIgKiB0aGlzLl9zcGlyYWxMZW5ndGhTdGFydCxcblx0XHRcdFx0c2VwYXJhdGlvbiA9IHNwaWRlcmZ5RGlzdGFuY2VNdWx0aXBsaWVyICogdGhpcy5fc3BpcmFsRm9vdFNlcGFyYXRpb24sXG5cdFx0XHRcdGxlbmd0aEZhY3RvciA9IHNwaWRlcmZ5RGlzdGFuY2VNdWx0aXBsaWVyICogdGhpcy5fc3BpcmFsTGVuZ3RoRmFjdG9yICogdGhpcy5fMlBJLFxuXHRcdFx0XHRhbmdsZSA9IDAsXG5cdFx0XHRcdHJlcyA9IFtdLFxuXHRcdFx0XHRpO1xuXG5cdFx0XHRyZXMubGVuZ3RoID0gY291bnQ7XG5cblx0XHRcdC8vIEhpZ2hlciBpbmRleCwgY2xvc2VyIHBvc2l0aW9uIHRvIGNsdXN0ZXIgY2VudGVyLlxuXHRcdFx0Zm9yIChpID0gY291bnQ7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRcdC8vIFNraXAgdGhlIGZpcnN0IHBvc2l0aW9uLCBzbyB0aGF0IHdlIGFyZSBhbHJlYWR5IGZhcnRoZXIgZnJvbSBjZW50ZXIgYW5kIHdlIGF2b2lkXG5cdFx0XHRcdC8vIGJlaW5nIHVuZGVyIHRoZSBkZWZhdWx0IGNsdXN0ZXIgaWNvbiAoZXNwZWNpYWxseSBpbXBvcnRhbnQgZm9yIENpcmNsZSBNYXJrZXJzKS5cblx0XHRcdFx0aWYgKGkgPCBjb3VudCkge1xuXHRcdFx0XHRcdHJlc1tpXSA9IG5ldyBMLlBvaW50KGNlbnRlclB0LnggKyBsZWdMZW5ndGggKiBNYXRoLmNvcyhhbmdsZSksIGNlbnRlclB0LnkgKyBsZWdMZW5ndGggKiBNYXRoLnNpbihhbmdsZSkpLl9yb3VuZCgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGFuZ2xlICs9IHNlcGFyYXRpb24gLyBsZWdMZW5ndGggKyBpICogMC4wMDA1O1xuXHRcdFx0XHRsZWdMZW5ndGggKz0gbGVuZ3RoRmFjdG9yIC8gYW5nbGU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzO1xuXHRcdH0sXG5cblx0XHRfbm9hbmltYXRpb25VbnNwaWRlcmZ5OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgZ3JvdXAgPSB0aGlzLl9ncm91cCxcblx0XHRcdFx0bWFwID0gZ3JvdXAuX21hcCxcblx0XHRcdFx0ZmcgPSBncm91cC5fZmVhdHVyZUdyb3VwLFxuXHRcdFx0XHRjaGlsZE1hcmtlcnMgPSB0aGlzLmdldEFsbENoaWxkTWFya2VycyhudWxsLCB0cnVlKSxcblx0XHRcdFx0bSwgaTtcblxuXHRcdFx0Z3JvdXAuX2lnbm9yZU1vdmUgPSB0cnVlO1xuXG5cdFx0XHR0aGlzLnNldE9wYWNpdHkoMSk7XG5cdFx0XHRmb3IgKGkgPSBjaGlsZE1hcmtlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0bSA9IGNoaWxkTWFya2Vyc1tpXTtcblxuXHRcdFx0XHRmZy5yZW1vdmVMYXllcihtKTtcblxuXHRcdFx0XHRpZiAobS5fcHJlU3BpZGVyZnlMYXRsbmcpIHtcblx0XHRcdFx0XHRtLnNldExhdExuZyhtLl9wcmVTcGlkZXJmeUxhdGxuZyk7XG5cdFx0XHRcdFx0ZGVsZXRlIG0uX3ByZVNwaWRlcmZ5TGF0bG5nO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChtLnNldFpJbmRleE9mZnNldCkge1xuXHRcdFx0XHRcdG0uc2V0WkluZGV4T2Zmc2V0KDApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKG0uX3NwaWRlckxlZykge1xuXHRcdFx0XHRcdG1hcC5yZW1vdmVMYXllcihtLl9zcGlkZXJMZWcpO1xuXHRcdFx0XHRcdGRlbGV0ZSBtLl9zcGlkZXJMZWc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Z3JvdXAuZmlyZSgndW5zcGlkZXJmaWVkJywge1xuXHRcdFx0XHRjbHVzdGVyOiB0aGlzLFxuXHRcdFx0XHRtYXJrZXJzOiBjaGlsZE1hcmtlcnNcblx0XHRcdH0pO1xuXHRcdFx0Z3JvdXAuX2lnbm9yZU1vdmUgPSBmYWxzZTtcblx0XHRcdGdyb3VwLl9zcGlkZXJmaWVkID0gbnVsbDtcblx0XHR9XG5cdH0pO1xuXG5cdC8vTm9uIEFuaW1hdGVkIHZlcnNpb25zIG9mIGV2ZXJ5dGhpbmdcblx0TC5NYXJrZXJDbHVzdGVyTm9uQW5pbWF0ZWQgPSBMLk1hcmtlckNsdXN0ZXIuZXh0ZW5kKHtcblx0XHRfYW5pbWF0aW9uU3BpZGVyZnk6IGZ1bmN0aW9uIChjaGlsZE1hcmtlcnMsIHBvc2l0aW9ucykge1xuXHRcdFx0dmFyIGdyb3VwID0gdGhpcy5fZ3JvdXAsXG5cdFx0XHRcdG1hcCA9IGdyb3VwLl9tYXAsXG5cdFx0XHRcdGZnID0gZ3JvdXAuX2ZlYXR1cmVHcm91cCxcblx0XHRcdFx0bGVnT3B0aW9ucyA9IHRoaXMuX2dyb3VwLm9wdGlvbnMuc3BpZGVyTGVnUG9seWxpbmVPcHRpb25zLFxuXHRcdFx0XHRpLCBtLCBsZWcsIG5ld1BvcztcblxuXHRcdFx0Z3JvdXAuX2lnbm9yZU1vdmUgPSB0cnVlO1xuXG5cdFx0XHQvLyBUcmF2ZXJzZSBpbiBhc2NlbmRpbmcgb3JkZXIgdG8gbWFrZSBzdXJlIHRoYXQgaW5uZXIgY2lyY2xlTWFya2VycyBhcmUgb24gdG9wIG9mIGZ1cnRoZXIgbGVncy4gTm9ybWFsIG1hcmtlcnMgYXJlIHJlLW9yZGVyZWQgYnkgbmV3UG9zaXRpb24uXG5cdFx0XHQvLyBUaGUgcmV2ZXJzZSBvcmRlciB0cmljayBubyBsb25nZXIgaW1wcm92ZXMgcGVyZm9ybWFuY2Ugb24gbW9kZXJuIGJyb3dzZXJzLlxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGNoaWxkTWFya2Vycy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRuZXdQb3MgPSBtYXAubGF5ZXJQb2ludFRvTGF0TG5nKHBvc2l0aW9uc1tpXSk7XG5cdFx0XHRcdG0gPSBjaGlsZE1hcmtlcnNbaV07XG5cblx0XHRcdFx0Ly8gQWRkIHRoZSBsZWcgYmVmb3JlIHRoZSBtYXJrZXIsIHNvIHRoYXQgaW4gY2FzZSB0aGUgbGF0dGVyIGlzIGEgY2lyY2xlTWFya2VyLCB0aGUgbGVnIGlzIGJlaGluZCBpdC5cblx0XHRcdFx0bGVnID0gbmV3IEwuUG9seWxpbmUoW3RoaXMuX2xhdGxuZywgbmV3UG9zXSwgbGVnT3B0aW9ucyk7XG5cdFx0XHRcdG1hcC5hZGRMYXllcihsZWcpO1xuXHRcdFx0XHRtLl9zcGlkZXJMZWcgPSBsZWc7XG5cblx0XHRcdFx0Ly8gTm93IGFkZCB0aGUgbWFya2VyLlxuXHRcdFx0XHRtLl9wcmVTcGlkZXJmeUxhdGxuZyA9IG0uX2xhdGxuZztcblx0XHRcdFx0bS5zZXRMYXRMbmcobmV3UG9zKTtcblx0XHRcdFx0aWYgKG0uc2V0WkluZGV4T2Zmc2V0KSB7XG5cdFx0XHRcdFx0bS5zZXRaSW5kZXhPZmZzZXQoMTAwMDAwMCk7IC8vTWFrZSB0aGVzZSBhcHBlYXIgb24gdG9wIG9mIEVWRVJZVEhJTkdcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZnLmFkZExheWVyKG0pO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5zZXRPcGFjaXR5KDAuMyk7XG5cblx0XHRcdGdyb3VwLl9pZ25vcmVNb3ZlID0gZmFsc2U7XG5cdFx0XHRncm91cC5maXJlKCdzcGlkZXJmaWVkJywge1xuXHRcdFx0XHRjbHVzdGVyOiB0aGlzLFxuXHRcdFx0XHRtYXJrZXJzOiBjaGlsZE1hcmtlcnNcblx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHRfYW5pbWF0aW9uVW5zcGlkZXJmeTogZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhpcy5fbm9hbmltYXRpb25VbnNwaWRlcmZ5KCk7XG5cdFx0fVxuXHR9KTtcblxuXHQvL0FuaW1hdGVkIHZlcnNpb25zIGhlcmVcblx0TC5NYXJrZXJDbHVzdGVyLmluY2x1ZGUoe1xuXG5cdFx0X2FuaW1hdGlvblNwaWRlcmZ5OiBmdW5jdGlvbiAoY2hpbGRNYXJrZXJzLCBwb3NpdGlvbnMpIHtcblx0XHRcdHZhciBtZSA9IHRoaXMsXG5cdFx0XHRcdGdyb3VwID0gdGhpcy5fZ3JvdXAsXG5cdFx0XHRcdG1hcCA9IGdyb3VwLl9tYXAsXG5cdFx0XHRcdGZnID0gZ3JvdXAuX2ZlYXR1cmVHcm91cCxcblx0XHRcdFx0dGhpc0xheWVyTGF0TG5nID0gdGhpcy5fbGF0bG5nLFxuXHRcdFx0XHR0aGlzTGF5ZXJQb3MgPSBtYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXNMYXllckxhdExuZyksXG5cdFx0XHRcdHN2ZyA9IEwuUGF0aC5TVkcsXG5cdFx0XHRcdGxlZ09wdGlvbnMgPSBMLmV4dGVuZCh7fSwgdGhpcy5fZ3JvdXAub3B0aW9ucy5zcGlkZXJMZWdQb2x5bGluZU9wdGlvbnMpLCAvLyBDb3B5IHRoZSBvcHRpb25zIHNvIHRoYXQgd2UgY2FuIG1vZGlmeSB0aGVtIGZvciBhbmltYXRpb24uXG5cdFx0XHRcdGZpbmFsTGVnT3BhY2l0eSA9IGxlZ09wdGlvbnMub3BhY2l0eSxcblx0XHRcdFx0aSwgbSwgbGVnLCBsZWdQYXRoLCBsZWdMZW5ndGgsIG5ld1BvcztcblxuXHRcdFx0aWYgKGZpbmFsTGVnT3BhY2l0eSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGZpbmFsTGVnT3BhY2l0eSA9IEwuTWFya2VyQ2x1c3Rlckdyb3VwLnByb3RvdHlwZS5vcHRpb25zLnNwaWRlckxlZ1BvbHlsaW5lT3B0aW9ucy5vcGFjaXR5O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoc3ZnKSB7XG5cdFx0XHRcdC8vIElmIHRoZSBpbml0aWFsIG9wYWNpdHkgb2YgdGhlIHNwaWRlciBsZWcgaXMgbm90IDAgdGhlbiBpdCBhcHBlYXJzIGJlZm9yZSB0aGUgYW5pbWF0aW9uIHN0YXJ0cy5cblx0XHRcdFx0bGVnT3B0aW9ucy5vcGFjaXR5ID0gMDtcblxuXHRcdFx0XHQvLyBBZGQgdGhlIGNsYXNzIGZvciBDU1MgdHJhbnNpdGlvbnMuXG5cdFx0XHRcdGxlZ09wdGlvbnMuY2xhc3NOYW1lID0gKGxlZ09wdGlvbnMuY2xhc3NOYW1lIHx8ICcnKSArICcgbGVhZmxldC1jbHVzdGVyLXNwaWRlci1sZWcnO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gTWFrZSBzdXJlIHdlIGhhdmUgYSBkZWZpbmVkIG9wYWNpdHkuXG5cdFx0XHRcdGxlZ09wdGlvbnMub3BhY2l0eSA9IGZpbmFsTGVnT3BhY2l0eTtcblx0XHRcdH1cblxuXHRcdFx0Z3JvdXAuX2lnbm9yZU1vdmUgPSB0cnVlO1xuXG5cdFx0XHQvLyBBZGQgbWFya2VycyBhbmQgc3BpZGVyIGxlZ3MgdG8gbWFwLCBoaWRkZW4gYXQgb3VyIGNlbnRlciBwb2ludC5cblx0XHRcdC8vIFRyYXZlcnNlIGluIGFzY2VuZGluZyBvcmRlciB0byBtYWtlIHN1cmUgdGhhdCBpbm5lciBjaXJjbGVNYXJrZXJzIGFyZSBvbiB0b3Agb2YgZnVydGhlciBsZWdzLiBOb3JtYWwgbWFya2VycyBhcmUgcmUtb3JkZXJlZCBieSBuZXdQb3NpdGlvbi5cblx0XHRcdC8vIFRoZSByZXZlcnNlIG9yZGVyIHRyaWNrIG5vIGxvbmdlciBpbXByb3ZlcyBwZXJmb3JtYW5jZSBvbiBtb2Rlcm4gYnJvd3NlcnMuXG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgY2hpbGRNYXJrZXJzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdG0gPSBjaGlsZE1hcmtlcnNbaV07XG5cblx0XHRcdFx0bmV3UG9zID0gbWFwLmxheWVyUG9pbnRUb0xhdExuZyhwb3NpdGlvbnNbaV0pO1xuXG5cdFx0XHRcdC8vIEFkZCB0aGUgbGVnIGJlZm9yZSB0aGUgbWFya2VyLCBzbyB0aGF0IGluIGNhc2UgdGhlIGxhdHRlciBpcyBhIGNpcmNsZU1hcmtlciwgdGhlIGxlZyBpcyBiZWhpbmQgaXQuXG5cdFx0XHRcdGxlZyA9IG5ldyBMLlBvbHlsaW5lKFt0aGlzTGF5ZXJMYXRMbmcsIG5ld1Bvc10sIGxlZ09wdGlvbnMpO1xuXHRcdFx0XHRtYXAuYWRkTGF5ZXIobGVnKTtcblx0XHRcdFx0bS5fc3BpZGVyTGVnID0gbGVnO1xuXG5cdFx0XHRcdC8vIEV4cGxhbmF0aW9uczogaHR0cHM6Ly9qYWtlYXJjaGliYWxkLmNvbS8yMDEzL2FuaW1hdGVkLWxpbmUtZHJhd2luZy1zdmcvXG5cdFx0XHRcdC8vIEluIG91ciBjYXNlIHRoZSB0cmFuc2l0aW9uIHByb3BlcnR5IGlzIGRlY2xhcmVkIGluIHRoZSBDU1MgZmlsZS5cblx0XHRcdFx0aWYgKHN2Zykge1xuXHRcdFx0XHRcdGxlZ1BhdGggPSBsZWcuX3BhdGg7XG5cdFx0XHRcdFx0bGVnTGVuZ3RoID0gbGVnUGF0aC5nZXRUb3RhbExlbmd0aCgpICsgMC4xOyAvLyBOZWVkIGEgc21hbGwgZXh0cmEgbGVuZ3RoIHRvIGF2b2lkIHJlbWFpbmluZyBkb3QgaW4gRmlyZWZveC5cblx0XHRcdFx0XHRsZWdQYXRoLnN0eWxlLnN0cm9rZURhc2hhcnJheSA9IGxlZ0xlbmd0aDsgLy8gSnVzdCAxIGxlbmd0aCBpcyBlbm91Z2gsIGl0IHdpbGwgYmUgZHVwbGljYXRlZC5cblx0XHRcdFx0XHRsZWdQYXRoLnN0eWxlLnN0cm9rZURhc2hvZmZzZXQgPSBsZWdMZW5ndGg7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBJZiBpdCBpcyBhIG1hcmtlciwgYWRkIGl0IG5vdyBhbmQgd2UnbGwgYW5pbWF0ZSBpdCBvdXRcblx0XHRcdFx0aWYgKG0uc2V0WkluZGV4T2Zmc2V0KSB7XG5cdFx0XHRcdFx0bS5zZXRaSW5kZXhPZmZzZXQoMTAwMDAwMCk7IC8vIE1ha2Ugbm9ybWFsIG1hcmtlcnMgYXBwZWFyIG9uIHRvcCBvZiBFVkVSWVRISU5HXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG0uY2x1c3RlckhpZGUpIHtcblx0XHRcdFx0XHRtLmNsdXN0ZXJIaWRlKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdC8vIFZlY3RvcnMganVzdCBnZXQgaW1tZWRpYXRlbHkgYWRkZWRcblx0XHRcdFx0ZmcuYWRkTGF5ZXIobSk7XG5cblx0XHRcdFx0aWYgKG0uX3NldFBvcykge1xuXHRcdFx0XHRcdG0uX3NldFBvcyh0aGlzTGF5ZXJQb3MpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGdyb3VwLl9mb3JjZUxheW91dCgpO1xuXHRcdFx0Z3JvdXAuX2FuaW1hdGlvblN0YXJ0KCk7XG5cblx0XHRcdC8vIFJldmVhbCBtYXJrZXJzIGFuZCBzcGlkZXIgbGVncy5cblx0XHRcdGZvciAoaSA9IGNoaWxkTWFya2Vycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHRuZXdQb3MgPSBtYXAubGF5ZXJQb2ludFRvTGF0TG5nKHBvc2l0aW9uc1tpXSk7XG5cdFx0XHRcdG0gPSBjaGlsZE1hcmtlcnNbaV07XG5cblx0XHRcdFx0Ly9Nb3ZlIG1hcmtlciB0byBuZXcgcG9zaXRpb25cblx0XHRcdFx0bS5fcHJlU3BpZGVyZnlMYXRsbmcgPSBtLl9sYXRsbmc7XG5cdFx0XHRcdG0uc2V0TGF0TG5nKG5ld1Bvcyk7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAobS5jbHVzdGVyU2hvdykge1xuXHRcdFx0XHRcdG0uY2x1c3RlclNob3coKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEFuaW1hdGUgbGVnIChhbmltYXRpb24gaXMgYWN0dWFsbHkgZGVsZWdhdGVkIHRvIENTUyB0cmFuc2l0aW9uKS5cblx0XHRcdFx0aWYgKHN2Zykge1xuXHRcdFx0XHRcdGxlZyA9IG0uX3NwaWRlckxlZztcblx0XHRcdFx0XHRsZWdQYXRoID0gbGVnLl9wYXRoO1xuXHRcdFx0XHRcdGxlZ1BhdGguc3R5bGUuc3Ryb2tlRGFzaG9mZnNldCA9IDA7XG5cdFx0XHRcdFx0Ly9sZWdQYXRoLnN0eWxlLnN0cm9rZU9wYWNpdHkgPSBmaW5hbExlZ09wYWNpdHk7XG5cdFx0XHRcdFx0bGVnLnNldFN0eWxlKHtvcGFjaXR5OiBmaW5hbExlZ09wYWNpdHl9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy5zZXRPcGFjaXR5KDAuMyk7XG5cblx0XHRcdGdyb3VwLl9pZ25vcmVNb3ZlID0gZmFsc2U7XG5cblx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRncm91cC5fYW5pbWF0aW9uRW5kKCk7XG5cdFx0XHRcdGdyb3VwLmZpcmUoJ3NwaWRlcmZpZWQnLCB7XG5cdFx0XHRcdFx0Y2x1c3RlcjogbWUsXG5cdFx0XHRcdFx0bWFya2VyczogY2hpbGRNYXJrZXJzXG5cdFx0XHRcdH0pO1xuXHRcdFx0fSwgMjAwKTtcblx0XHR9LFxuXG5cdFx0X2FuaW1hdGlvblVuc3BpZGVyZnk6IGZ1bmN0aW9uICh6b29tRGV0YWlscykge1xuXHRcdFx0dmFyIG1lID0gdGhpcyxcblx0XHRcdFx0Z3JvdXAgPSB0aGlzLl9ncm91cCxcblx0XHRcdFx0bWFwID0gZ3JvdXAuX21hcCxcblx0XHRcdFx0ZmcgPSBncm91cC5fZmVhdHVyZUdyb3VwLFxuXHRcdFx0XHR0aGlzTGF5ZXJQb3MgPSB6b29tRGV0YWlscyA/IG1hcC5fbGF0TG5nVG9OZXdMYXllclBvaW50KHRoaXMuX2xhdGxuZywgem9vbURldGFpbHMuem9vbSwgem9vbURldGFpbHMuY2VudGVyKSA6IG1hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKSxcblx0XHRcdFx0Y2hpbGRNYXJrZXJzID0gdGhpcy5nZXRBbGxDaGlsZE1hcmtlcnMobnVsbCwgdHJ1ZSksXG5cdFx0XHRcdHN2ZyA9IEwuUGF0aC5TVkcsXG5cdFx0XHRcdG0sIGksIGxlZywgbGVnUGF0aCwgbGVnTGVuZ3RoLCBub25BbmltYXRhYmxlO1xuXG5cdFx0XHRncm91cC5faWdub3JlTW92ZSA9IHRydWU7XG5cdFx0XHRncm91cC5fYW5pbWF0aW9uU3RhcnQoKTtcblxuXHRcdFx0Ly9NYWtlIHVzIHZpc2libGUgYW5kIGJyaW5nIHRoZSBjaGlsZCBtYXJrZXJzIGJhY2sgaW5cblx0XHRcdHRoaXMuc2V0T3BhY2l0eSgxKTtcblx0XHRcdGZvciAoaSA9IGNoaWxkTWFya2Vycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHRtID0gY2hpbGRNYXJrZXJzW2ldO1xuXG5cdFx0XHRcdC8vTWFya2VyIHdhcyBhZGRlZCB0byB1cyBhZnRlciB3ZSB3ZXJlIHNwaWRlcmZpZWRcblx0XHRcdFx0aWYgKCFtLl9wcmVTcGlkZXJmeUxhdGxuZykge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly9DbG9zZSBhbnkgcG9wdXAgb24gdGhlIG1hcmtlciBmaXJzdCwgb3RoZXJ3aXNlIHNldHRpbmcgdGhlIGxvY2F0aW9uIG9mIHRoZSBtYXJrZXIgd2lsbCBtYWtlIHRoZSBtYXAgc2Nyb2xsXG5cdFx0XHRcdG0uY2xvc2VQb3B1cCgpO1xuXG5cdFx0XHRcdC8vRml4IHVwIHRoZSBsb2NhdGlvbiB0byB0aGUgcmVhbCBvbmVcblx0XHRcdFx0bS5zZXRMYXRMbmcobS5fcHJlU3BpZGVyZnlMYXRsbmcpO1xuXHRcdFx0XHRkZWxldGUgbS5fcHJlU3BpZGVyZnlMYXRsbmc7XG5cblx0XHRcdFx0Ly9IYWNrIG92ZXJyaWRlIHRoZSBsb2NhdGlvbiB0byBiZSBvdXIgY2VudGVyXG5cdFx0XHRcdG5vbkFuaW1hdGFibGUgPSB0cnVlO1xuXHRcdFx0XHRpZiAobS5fc2V0UG9zKSB7XG5cdFx0XHRcdFx0bS5fc2V0UG9zKHRoaXNMYXllclBvcyk7XG5cdFx0XHRcdFx0bm9uQW5pbWF0YWJsZSA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChtLmNsdXN0ZXJIaWRlKSB7XG5cdFx0XHRcdFx0bS5jbHVzdGVySGlkZSgpO1xuXHRcdFx0XHRcdG5vbkFuaW1hdGFibGUgPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAobm9uQW5pbWF0YWJsZSkge1xuXHRcdFx0XHRcdGZnLnJlbW92ZUxheWVyKG0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQW5pbWF0ZSB0aGUgc3BpZGVyIGxlZyBiYWNrIGluIChhbmltYXRpb24gaXMgYWN0dWFsbHkgZGVsZWdhdGVkIHRvIENTUyB0cmFuc2l0aW9uKS5cblx0XHRcdFx0aWYgKHN2Zykge1xuXHRcdFx0XHRcdGxlZyA9IG0uX3NwaWRlckxlZztcblx0XHRcdFx0XHRsZWdQYXRoID0gbGVnLl9wYXRoO1xuXHRcdFx0XHRcdGxlZ0xlbmd0aCA9IGxlZ1BhdGguZ2V0VG90YWxMZW5ndGgoKSArIDAuMTtcblx0XHRcdFx0XHRsZWdQYXRoLnN0eWxlLnN0cm9rZURhc2hvZmZzZXQgPSBsZWdMZW5ndGg7XG5cdFx0XHRcdFx0bGVnLnNldFN0eWxlKHtvcGFjaXR5OiAwfSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Z3JvdXAuX2lnbm9yZU1vdmUgPSBmYWxzZTtcblxuXHRcdFx0c2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdC8vSWYgd2UgaGF2ZSBvbmx5IDw9IG9uZSBjaGlsZCBsZWZ0IHRoZW4gdGhhdCBtYXJrZXIgd2lsbCBiZSBzaG93biBvbiB0aGUgbWFwIHNvIGRvbid0IHJlbW92ZSBpdCFcblx0XHRcdFx0dmFyIHN0aWxsVGhlcmVDaGlsZENvdW50ID0gMDtcblx0XHRcdFx0Zm9yIChpID0gY2hpbGRNYXJrZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRcdFx0bSA9IGNoaWxkTWFya2Vyc1tpXTtcblx0XHRcdFx0XHRpZiAobS5fc3BpZGVyTGVnKSB7XG5cdFx0XHRcdFx0XHRzdGlsbFRoZXJlQ2hpbGRDb3VudCsrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cblx0XHRcdFx0Zm9yIChpID0gY2hpbGRNYXJrZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRcdFx0bSA9IGNoaWxkTWFya2Vyc1tpXTtcblxuXHRcdFx0XHRcdGlmICghbS5fc3BpZGVyTGVnKSB7IC8vSGFzIGFscmVhZHkgYmVlbiB1bnNwaWRlcmZpZWRcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChtLmNsdXN0ZXJTaG93KSB7XG5cdFx0XHRcdFx0XHRtLmNsdXN0ZXJTaG93KCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChtLnNldFpJbmRleE9mZnNldCkge1xuXHRcdFx0XHRcdFx0bS5zZXRaSW5kZXhPZmZzZXQoMCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKHN0aWxsVGhlcmVDaGlsZENvdW50ID4gMSkge1xuXHRcdFx0XHRcdFx0ZmcucmVtb3ZlTGF5ZXIobSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0bWFwLnJlbW92ZUxheWVyKG0uX3NwaWRlckxlZyk7XG5cdFx0XHRcdFx0ZGVsZXRlIG0uX3NwaWRlckxlZztcblx0XHRcdFx0fVxuXHRcdFx0XHRncm91cC5fYW5pbWF0aW9uRW5kKCk7XG5cdFx0XHRcdGdyb3VwLmZpcmUoJ3Vuc3BpZGVyZmllZCcsIHtcblx0XHRcdFx0XHRjbHVzdGVyOiBtZSxcblx0XHRcdFx0XHRtYXJrZXJzOiBjaGlsZE1hcmtlcnNcblx0XHRcdFx0fSk7XG5cdFx0XHR9LCAyMDApO1xuXHRcdH1cblx0fSk7XG5cblxuXHRMLk1hcmtlckNsdXN0ZXJHcm91cC5pbmNsdWRlKHtcblx0XHQvL1RoZSBNYXJrZXJDbHVzdGVyIGN1cnJlbnRseSBzcGlkZXJmaWVkIChpZiBhbnkpXG5cdFx0X3NwaWRlcmZpZWQ6IG51bGwsXG5cblx0XHR1bnNwaWRlcmZ5OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGlzLl91bnNwaWRlcmZ5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0fSxcblxuXHRcdF9zcGlkZXJmaWVyT25BZGQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoaXMuX21hcC5vbignY2xpY2snLCB0aGlzLl91bnNwaWRlcmZ5V3JhcHBlciwgdGhpcyk7XG5cblx0XHRcdGlmICh0aGlzLl9tYXAub3B0aW9ucy56b29tQW5pbWF0aW9uKSB7XG5cdFx0XHRcdHRoaXMuX21hcC5vbignem9vbXN0YXJ0JywgdGhpcy5fdW5zcGlkZXJmeVpvb21TdGFydCwgdGhpcyk7XG5cdFx0XHR9XG5cdFx0XHQvL0Jyb3dzZXJzIHdpdGhvdXQgem9vbUFuaW1hdGlvbiBvciBhIGJpZyB6b29tIGRvbid0IGZpcmUgem9vbXN0YXJ0XG5cdFx0XHR0aGlzLl9tYXAub24oJ3pvb21lbmQnLCB0aGlzLl9ub2FuaW1hdGlvblVuc3BpZGVyZnksIHRoaXMpO1xuXG5cdFx0XHRpZiAoIUwuQnJvd3Nlci50b3VjaCkge1xuXHRcdFx0XHR0aGlzLl9tYXAuZ2V0UmVuZGVyZXIodGhpcyk7XG5cdFx0XHRcdC8vTmVlZHMgdG8gaGFwcGVuIGluIHRoZSBwYWdlbG9hZCwgbm90IGFmdGVyLCBvciBhbmltYXRpb25zIGRvbid0IHdvcmsgaW4gd2Via2l0XG5cdFx0XHRcdC8vICBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzg0NTUyMDAvc3ZnLWFuaW1hdGUtd2l0aC1keW5hbWljYWxseS1hZGRlZC1lbGVtZW50c1xuXHRcdFx0XHQvL0Rpc2FibGUgb24gdG91Y2ggYnJvd3NlcnMgYXMgdGhlIGFuaW1hdGlvbiBtZXNzZXMgdXAgb24gYSB0b3VjaCB6b29tIGFuZCBpc24ndCB2ZXJ5IG5vdGljYWJsZVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRfc3BpZGVyZmllck9uUmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGlzLl9tYXAub2ZmKCdjbGljaycsIHRoaXMuX3Vuc3BpZGVyZnlXcmFwcGVyLCB0aGlzKTtcblx0XHRcdHRoaXMuX21hcC5vZmYoJ3pvb21zdGFydCcsIHRoaXMuX3Vuc3BpZGVyZnlab29tU3RhcnQsIHRoaXMpO1xuXHRcdFx0dGhpcy5fbWFwLm9mZignem9vbWFuaW0nLCB0aGlzLl91bnNwaWRlcmZ5Wm9vbUFuaW0sIHRoaXMpO1xuXHRcdFx0dGhpcy5fbWFwLm9mZignem9vbWVuZCcsIHRoaXMuX25vYW5pbWF0aW9uVW5zcGlkZXJmeSwgdGhpcyk7XG5cblx0XHRcdC8vRW5zdXJlIHRoYXQgbWFya2VycyBhcmUgYmFjayB3aGVyZSB0aGV5IHNob3VsZCBiZVxuXHRcdFx0Ly8gVXNlIG5vIGFuaW1hdGlvbiB0byBhdm9pZCBhIHN0aWNreSBsZWFmbGV0LWNsdXN0ZXItYW5pbSBjbGFzcyBvbiBtYXBQYW5lXG5cdFx0XHR0aGlzLl9ub2FuaW1hdGlvblVuc3BpZGVyZnkoKTtcblx0XHR9LFxuXG5cdFx0Ly9PbiB6b29tIHN0YXJ0IHdlIGFkZCBhIHpvb21hbmltIGhhbmRsZXIgc28gdGhhdCB3ZSBhcmUgZ3VhcmFudGVlZCB0byBiZSBsYXN0IChhZnRlciBtYXJrZXJzIGFyZSBhbmltYXRlZClcblx0XHQvL1RoaXMgbWVhbnMgd2UgY2FuIGRlZmluZSB0aGUgYW5pbWF0aW9uIHRoZXkgZG8gcmF0aGVyIHRoYW4gTWFya2VycyBkb2luZyBhbiBhbmltYXRpb24gdG8gdGhlaXIgYWN0dWFsIGxvY2F0aW9uXG5cdFx0X3Vuc3BpZGVyZnlab29tU3RhcnQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmICghdGhpcy5fbWFwKSB7IC8vTWF5IGhhdmUgYmVlbiByZW1vdmVkIGZyb20gdGhlIG1hcCBieSBhIHpvb21FbmQgaGFuZGxlclxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX21hcC5vbignem9vbWFuaW0nLCB0aGlzLl91bnNwaWRlcmZ5Wm9vbUFuaW0sIHRoaXMpO1xuXHRcdH0sXG5cblx0XHRfdW5zcGlkZXJmeVpvb21BbmltOiBmdW5jdGlvbiAoem9vbURldGFpbHMpIHtcblx0XHRcdC8vV2FpdCB1bnRpbCB0aGUgZmlyc3Qgem9vbWFuaW0gYWZ0ZXIgdGhlIHVzZXIgaGFzIGZpbmlzaGVkIHRvdWNoLXpvb21pbmcgYmVmb3JlIHJ1bm5pbmcgdGhlIGFuaW1hdGlvblxuXHRcdFx0aWYgKEwuRG9tVXRpbC5oYXNDbGFzcyh0aGlzLl9tYXAuX21hcFBhbmUsICdsZWFmbGV0LXRvdWNoaW5nJykpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9tYXAub2ZmKCd6b29tYW5pbScsIHRoaXMuX3Vuc3BpZGVyZnlab29tQW5pbSwgdGhpcyk7XG5cdFx0XHR0aGlzLl91bnNwaWRlcmZ5KHpvb21EZXRhaWxzKTtcblx0XHR9LFxuXG5cdFx0X3Vuc3BpZGVyZnlXcmFwcGVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHQvLy8gPHN1bW1hcnk+X3Vuc3BpZGVyZnkgYnV0IHBhc3NlcyBubyBhcmd1bWVudHM8L3N1bW1hcnk+XG5cdFx0XHR0aGlzLl91bnNwaWRlcmZ5KCk7XG5cdFx0fSxcblxuXHRcdF91bnNwaWRlcmZ5OiBmdW5jdGlvbiAoem9vbURldGFpbHMpIHtcblx0XHRcdGlmICh0aGlzLl9zcGlkZXJmaWVkKSB7XG5cdFx0XHRcdHRoaXMuX3NwaWRlcmZpZWQudW5zcGlkZXJmeSh6b29tRGV0YWlscyk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdF9ub2FuaW1hdGlvblVuc3BpZGVyZnk6IGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmICh0aGlzLl9zcGlkZXJmaWVkKSB7XG5cdFx0XHRcdHRoaXMuX3NwaWRlcmZpZWQuX25vYW5pbWF0aW9uVW5zcGlkZXJmeSgpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvL0lmIHRoZSBnaXZlbiBsYXllciBpcyBjdXJyZW50bHkgYmVpbmcgc3BpZGVyZmllZCB0aGVuIHdlIHVuc3BpZGVyZnkgaXQgc28gaXQgaXNuJ3Qgb24gdGhlIG1hcCBhbnltb3JlIGV0Y1xuXHRcdF91bnNwaWRlcmZ5TGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xuXHRcdFx0aWYgKGxheWVyLl9zcGlkZXJMZWcpIHtcblx0XHRcdFx0dGhpcy5fZmVhdHVyZUdyb3VwLnJlbW92ZUxheWVyKGxheWVyKTtcblxuXHRcdFx0XHRpZiAobGF5ZXIuY2x1c3RlclNob3cpIHtcblx0XHRcdFx0XHRsYXllci5jbHVzdGVyU2hvdygpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly9Qb3NpdGlvbiB3aWxsIGJlIGZpeGVkIHVwIGltbWVkaWF0ZWx5IGluIF9hbmltYXRpb25VbnNwaWRlcmZ5XG5cdFx0XHRcdGlmIChsYXllci5zZXRaSW5kZXhPZmZzZXQpIHtcblx0XHRcdFx0XHRsYXllci5zZXRaSW5kZXhPZmZzZXQoMCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLl9tYXAucmVtb3ZlTGF5ZXIobGF5ZXIuX3NwaWRlckxlZyk7XG5cdFx0XHRcdGRlbGV0ZSBsYXllci5fc3BpZGVyTGVnO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cblx0LyoqXG5cdCAqIEFkZHMgMSBwdWJsaWMgbWV0aG9kIHRvIE1DRyBhbmQgMSB0byBMLk1hcmtlciB0byBmYWNpbGl0YXRlIGNoYW5naW5nXG5cdCAqIG1hcmtlcnMnIGljb24gb3B0aW9ucyBhbmQgcmVmcmVzaGluZyB0aGVpciBpY29uIGFuZCB0aGVpciBwYXJlbnQgY2x1c3RlcnNcblx0ICogYWNjb3JkaW5nbHkgKGNhc2Ugd2hlcmUgdGhlaXIgaWNvbkNyZWF0ZUZ1bmN0aW9uIHVzZXMgZGF0YSBvZiBjaGlsZE1hcmtlcnNcblx0ICogdG8gbWFrZSB1cCB0aGUgY2x1c3RlciBpY29uKS5cblx0ICovXG5cblxuXHRMLk1hcmtlckNsdXN0ZXJHcm91cC5pbmNsdWRlKHtcblx0XHQvKipcblx0XHQgKiBVcGRhdGVzIHRoZSBpY29uIG9mIGFsbCBjbHVzdGVycyB3aGljaCBhcmUgcGFyZW50cyBvZiB0aGUgZ2l2ZW4gbWFya2VyKHMpLlxuXHRcdCAqIEluIHNpbmdsZU1hcmtlck1vZGUsIGFsc28gdXBkYXRlcyB0aGUgZ2l2ZW4gbWFya2VyKHMpIGljb24uXG5cdFx0ICogQHBhcmFtIGxheWVycyBMLk1hcmtlckNsdXN0ZXJHcm91cHxMLkxheWVyR3JvdXB8QXJyYXkoTC5NYXJrZXIpfE1hcChMLk1hcmtlcil8XG5cdFx0ICogTC5NYXJrZXJDbHVzdGVyfEwuTWFya2VyIChvcHRpb25hbCkgbGlzdCBvZiBtYXJrZXJzIChvciBzaW5nbGUgbWFya2VyKSB3aG9zZSBwYXJlbnRcblx0XHQgKiBjbHVzdGVycyBuZWVkIHRvIGJlIHVwZGF0ZWQuIElmIG5vdCBwcm92aWRlZCwgcmV0cmlldmVzIGFsbCBjaGlsZCBtYXJrZXJzIG9mIHRoaXMuXG5cdFx0ICogQHJldHVybnMge0wuTWFya2VyQ2x1c3Rlckdyb3VwfVxuXHRcdCAqL1xuXHRcdHJlZnJlc2hDbHVzdGVyczogZnVuY3Rpb24gKGxheWVycykge1xuXHRcdFx0aWYgKCFsYXllcnMpIHtcblx0XHRcdFx0bGF5ZXJzID0gdGhpcy5fdG9wQ2x1c3RlckxldmVsLmdldEFsbENoaWxkTWFya2VycygpO1xuXHRcdFx0fSBlbHNlIGlmIChsYXllcnMgaW5zdGFuY2VvZiBMLk1hcmtlckNsdXN0ZXJHcm91cCkge1xuXHRcdFx0XHRsYXllcnMgPSBsYXllcnMuX3RvcENsdXN0ZXJMZXZlbC5nZXRBbGxDaGlsZE1hcmtlcnMoKTtcblx0XHRcdH0gZWxzZSBpZiAobGF5ZXJzIGluc3RhbmNlb2YgTC5MYXllckdyb3VwKSB7XG5cdFx0XHRcdGxheWVycyA9IGxheWVycy5fbGF5ZXJzO1xuXHRcdFx0fSBlbHNlIGlmIChsYXllcnMgaW5zdGFuY2VvZiBMLk1hcmtlckNsdXN0ZXIpIHtcblx0XHRcdFx0bGF5ZXJzID0gbGF5ZXJzLmdldEFsbENoaWxkTWFya2VycygpO1xuXHRcdFx0fSBlbHNlIGlmIChsYXllcnMgaW5zdGFuY2VvZiBMLk1hcmtlcikge1xuXHRcdFx0XHRsYXllcnMgPSBbbGF5ZXJzXTtcblx0XHRcdH0gLy8gZWxzZTogbXVzdCBiZSBhbiBBcnJheShMLk1hcmtlcil8TWFwKEwuTWFya2VyKVxuXHRcdFx0dGhpcy5fZmxhZ1BhcmVudHNJY29uc05lZWRVcGRhdGUobGF5ZXJzKTtcblx0XHRcdHRoaXMuX3JlZnJlc2hDbHVzdGVyc0ljb25zKCk7XG5cblx0XHRcdC8vIEluIGNhc2Ugb2Ygc2luZ2xlTWFya2VyTW9kZSwgYWxzbyByZS1kcmF3IHRoZSBtYXJrZXJzLlxuXHRcdFx0aWYgKHRoaXMub3B0aW9ucy5zaW5nbGVNYXJrZXJNb2RlKSB7XG5cdFx0XHRcdHRoaXMuX3JlZnJlc2hTaW5nbGVNYXJrZXJNb2RlTWFya2VycyhsYXllcnMpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogU2ltcGx5IGZsYWdzIGFsbCBwYXJlbnQgY2x1c3RlcnMgb2YgdGhlIGdpdmVuIG1hcmtlcnMgYXMgaGF2aW5nIGEgXCJkaXJ0eVwiIGljb24uXG5cdFx0ICogQHBhcmFtIGxheWVycyBBcnJheShMLk1hcmtlcil8TWFwKEwuTWFya2VyKSBsaXN0IG9mIG1hcmtlcnMuXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHRfZmxhZ1BhcmVudHNJY29uc05lZWRVcGRhdGU6IGZ1bmN0aW9uIChsYXllcnMpIHtcblx0XHRcdHZhciBpZCwgcGFyZW50O1xuXG5cdFx0XHQvLyBBc3N1bWVzIGxheWVycyBpcyBhbiBBcnJheSBvciBhbiBPYmplY3Qgd2hvc2UgcHJvdG90eXBlIGlzIG5vbi1lbnVtZXJhYmxlLlxuXHRcdFx0Zm9yIChpZCBpbiBsYXllcnMpIHtcblx0XHRcdFx0Ly8gRmxhZyBwYXJlbnQgY2x1c3RlcnMnIGljb24gYXMgXCJkaXJ0eVwiLCBhbGwgdGhlIHdheSB1cC5cblx0XHRcdFx0Ly8gRHVtYiBwcm9jZXNzIHRoYXQgZmxhZ3MgbXVsdGlwbGUgdGltZXMgdXBwZXIgcGFyZW50cywgYnV0IHN0aWxsXG5cdFx0XHRcdC8vIG11Y2ggbW9yZSBlZmZpY2llbnQgdGhhbiB0cnlpbmcgdG8gYmUgc21hcnQgYW5kIG1ha2Ugc2hvcnQgbGlzdHMsXG5cdFx0XHRcdC8vIGF0IGxlYXN0IGluIHRoZSBjYXNlIG9mIGEgaGllcmFyY2h5IGZvbGxvd2luZyBhIHBvd2VyIGxhdzpcblx0XHRcdFx0Ly8gaHR0cDovL2pzcGVyZi5jb20vZmxhZy1ub2Rlcy1pbi1wb3dlci1oaWVyYXJjaHkvMlxuXHRcdFx0XHRwYXJlbnQgPSBsYXllcnNbaWRdLl9fcGFyZW50O1xuXHRcdFx0XHR3aGlsZSAocGFyZW50KSB7XG5cdFx0XHRcdFx0cGFyZW50Ll9pY29uTmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdFx0XHRcdHBhcmVudCA9IHBhcmVudC5fX3BhcmVudDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBSZS1kcmF3cyB0aGUgaWNvbiBvZiB0aGUgc3VwcGxpZWQgbWFya2Vycy5cblx0XHQgKiBUbyBiZSB1c2VkIGluIHNpbmdsZU1hcmtlck1vZGUgb25seS5cblx0XHQgKiBAcGFyYW0gbGF5ZXJzIEFycmF5KEwuTWFya2VyKXxNYXAoTC5NYXJrZXIpIGxpc3Qgb2YgbWFya2Vycy5cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdF9yZWZyZXNoU2luZ2xlTWFya2VyTW9kZU1hcmtlcnM6IGZ1bmN0aW9uIChsYXllcnMpIHtcblx0XHRcdHZhciBpZCwgbGF5ZXI7XG5cblx0XHRcdGZvciAoaWQgaW4gbGF5ZXJzKSB7XG5cdFx0XHRcdGxheWVyID0gbGF5ZXJzW2lkXTtcblxuXHRcdFx0XHQvLyBNYWtlIHN1cmUgd2UgZG8gbm90IG92ZXJyaWRlIG1hcmtlcnMgdGhhdCBkbyBub3QgYmVsb25nIHRvIFRISVMgZ3JvdXAuXG5cdFx0XHRcdGlmICh0aGlzLmhhc0xheWVyKGxheWVyKSkge1xuXHRcdFx0XHRcdC8vIE5lZWQgdG8gcmUtY3JlYXRlIHRoZSBpY29uIGZpcnN0LCB0aGVuIHJlLWRyYXcgdGhlIG1hcmtlci5cblx0XHRcdFx0XHRsYXllci5zZXRJY29uKHRoaXMuX292ZXJyaWRlTWFya2VySWNvbihsYXllcikpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcblxuXHRMLk1hcmtlci5pbmNsdWRlKHtcblx0XHQvKipcblx0XHQgKiBVcGRhdGVzIHRoZSBnaXZlbiBvcHRpb25zIGluIHRoZSBtYXJrZXIncyBpY29uIGFuZCByZWZyZXNoZXMgdGhlIG1hcmtlci5cblx0XHQgKiBAcGFyYW0gb3B0aW9ucyBtYXAgb2JqZWN0IG9mIGljb24gb3B0aW9ucy5cblx0XHQgKiBAcGFyYW0gZGlyZWN0bHlSZWZyZXNoQ2x1c3RlcnMgYm9vbGVhbiAob3B0aW9uYWwpIHRydWUgdG8gdHJpZ2dlclxuXHRcdCAqIE1DRy5yZWZyZXNoQ2x1c3RlcnNPZigpIHJpZ2h0IGF3YXkgd2l0aCB0aGlzIHNpbmdsZSBtYXJrZXIuXG5cdFx0ICogQHJldHVybnMge0wuTWFya2VyfVxuXHRcdCAqL1xuXHRcdHJlZnJlc2hJY29uT3B0aW9uczogZnVuY3Rpb24gKG9wdGlvbnMsIGRpcmVjdGx5UmVmcmVzaENsdXN0ZXJzKSB7XG5cdFx0XHR2YXIgaWNvbiA9IHRoaXMub3B0aW9ucy5pY29uO1xuXG5cdFx0XHRMLnNldE9wdGlvbnMoaWNvbiwgb3B0aW9ucyk7XG5cblx0XHRcdHRoaXMuc2V0SWNvbihpY29uKTtcblxuXHRcdFx0Ly8gU2hvcnRjdXQgdG8gcmVmcmVzaCB0aGUgYXNzb2NpYXRlZCBNQ0cgY2x1c3RlcnMgcmlnaHQgYXdheS5cblx0XHRcdC8vIFRvIGJlIHVzZWQgd2hlbiByZWZyZXNoaW5nIGEgc2luZ2xlIG1hcmtlci5cblx0XHRcdC8vIE90aGVyd2lzZSwgYmV0dGVyIHVzZSBNQ0cucmVmcmVzaENsdXN0ZXJzKCkgb25jZSBhdCB0aGUgZW5kIHdpdGhcblx0XHRcdC8vIHRoZSBsaXN0IG9mIG1vZGlmaWVkIG1hcmtlcnMuXG5cdFx0XHRpZiAoZGlyZWN0bHlSZWZyZXNoQ2x1c3RlcnMgJiYgdGhpcy5fX3BhcmVudCkge1xuXHRcdFx0XHR0aGlzLl9fcGFyZW50Ll9ncm91cC5yZWZyZXNoQ2x1c3RlcnModGhpcyk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0fSk7XG5cblx0ZXhwb3J0cy5NYXJrZXJDbHVzdGVyR3JvdXAgPSBNYXJrZXJDbHVzdGVyR3JvdXA7XG5cdGV4cG9ydHMuTWFya2VyQ2x1c3RlciA9IE1hcmtlckNsdXN0ZXI7XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGVhZmxldC5tYXJrZXJjbHVzdGVyLXNyYy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/leaflet.markercluster/dist/leaflet.markercluster-src.js\n");

/***/ })

};
;